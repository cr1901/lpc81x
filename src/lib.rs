# ! [ cfg_attr ( feature = "rt" , feature ( asm ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( core_intrinsics ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( linkage ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( macro_reexport ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( naked_functions ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( used ) ) ] # ! [ doc = "Peripheral access API for LPC800 microcontrollers (generated using svd2rust v0.11.1)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.11.1/svd2rust/#peripheral-api" ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
#[macro_reexport(default_handler, exception)]
#[cfg(feature = "rt")]
extern crate cortex_m_rt ;
extern crate bare_metal ;
extern crate vcell ;
use core::ops::Deref;
use bare_metal::Peripheral;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn SPI0() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn SPI1() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn UART0() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn UART1() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn UART2() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn I2C() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn SCT() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn MRT() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn CMP() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn WDT() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn BOD() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn FLASH_IRQ() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn WKT() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT0() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT1() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT2() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT3() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT4() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT5() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT6() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(non_snake_case)]
    #[allow(private_no_mangle_fns)]
    #[cfg(feature = "rt")]
    #[linkage = "weak"]
    #[naked]
    #[no_mangle]
    extern "C" fn PININT7() {
        unsafe {
            asm ! ( "b DEFAULT_HANDLER" :: :: "volatile" );
            ::core::intrinsics::unreachable()
        }
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS: [Option<extern "C" fn()>; 32] = [
        Some(SPI0),
        Some(SPI1),
        None,
        Some(UART0),
        Some(UART1),
        Some(UART2),
        None,
        None,
        Some(I2C),
        Some(SCT),
        Some(MRT),
        Some(CMP),
        Some(WDT),
        Some(BOD),
        Some(FLASH_IRQ),
        Some(WKT),
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        Some(PININT0),
        Some(PININT1),
        Some(PININT2),
        Some(PININT3),
        Some(PININT4),
        Some(PININT5),
        Some(PININT6),
        Some(PININT7),
    ];
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - SPI0"]
        SPI0,
        #[doc = "1 - SPI1"]
        SPI1,
        #[doc = "3 - UART0"]
        UART0,
        #[doc = "4 - UART1"]
        UART1,
        #[doc = "5 - UART2"]
        UART2,
        #[doc = "8 - I2C"]
        I2C,
        #[doc = "9 - SCT"]
        SCT,
        #[doc = "10 - MRT"]
        MRT,
        #[doc = "11 - CMP"]
        CMP,
        #[doc = "12 - WDT"]
        WDT,
        #[doc = "13 - BOD"]
        BOD,
        #[doc = "14 - FLASH_IRQ"]
        FLASH_IRQ,
        #[doc = "15 - WKT"]
        WKT,
        #[doc = "24 - PININT0"]
        PININT0,
        #[doc = "25 - PININT1"]
        PININT1,
        #[doc = "26 - PININT2"]
        PININT2,
        #[doc = "27 - PININT3"]
        PININT3,
        #[doc = "28 - PININT4"]
        PININT4,
        #[doc = "29 - PININT5"]
        PININT5,
        #[doc = "30 - PININT6"]
        PININT6,
        #[doc = "31 - PININT7"]
        PININT7,
    }
    unsafe impl Nr for Interrupt {
        #[inline(always)]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::SPI0 => 0,
                Interrupt::SPI1 => 1,
                Interrupt::UART0 => 3,
                Interrupt::UART1 => 4,
                Interrupt::UART2 => 5,
                Interrupt::I2C => 8,
                Interrupt::SCT => 9,
                Interrupt::MRT => 10,
                Interrupt::CMP => 11,
                Interrupt::WDT => 12,
                Interrupt::BOD => 13,
                Interrupt::FLASH_IRQ => 14,
                Interrupt::WKT => 15,
                Interrupt::PININT0 => 24,
                Interrupt::PININT1 => 25,
                Interrupt::PININT2 => 26,
                Interrupt::PININT3 => 27,
                Interrupt::PININT4 => 28,
                Interrupt::PININT5 => 29,
                Interrupt::PININT6 => 30,
                Interrupt::PININT7 => 31,
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ident = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::FPB;
pub use cortex_m::peripheral::FPU;
pub use cortex_m::peripheral::ITM;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::SYST;
pub use cortex_m::peripheral::TPIU;
#[doc = "Windowed Watchdog Timer (WWDT)"]
pub const WWDT: Peripheral<WWDT> = unsafe { Peripheral::new(1073741824) };
#[doc = "Windowed Watchdog Timer (WWDT)"]
pub mod wwdt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
        pub mod_: MOD,
        #[doc = "0x04 - Watchdog timer constant register. This 24-bit register determines the time-out value."]
        pub tc: TC,
        #[doc = "0x08 - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
        pub feed: FEED,
        #[doc = "0x0c - Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
        pub tv: TV,
        _reserved0: [u8; 4usize],
        #[doc = "0x14 - Watchdog Warning Interrupt compare value."]
        pub warnint: WARNINT,
        #[doc = "0x18 - Watchdog Window compare value."]
        pub window: WINDOW,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub struct MOD {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub mod mod_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MOD {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDENR {
            #[doc = "The watchdog timer is stopped."]
            STOPPED,
            #[doc = "The watchdog timer is running."]
            RUNNING,
        }
        impl WDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDENR::STOPPED => false,
                    WDENR::RUNNING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDENR {
                match value {
                    false => WDENR::STOPPED,
                    true => WDENR::RUNNING,
                }
            }
            #[doc = "Checks if the value of the field is `STOPPED`"]
            #[inline(always)]
            pub fn is_stopped(&self) -> bool {
                *self == WDENR::STOPPED
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline(always)]
            pub fn is_running(&self) -> bool {
                *self == WDENR::RUNNING
            }
        }
        #[doc = "Possible values of the field `WDRESET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDRESETR {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            NORESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            RESET,
        }
        impl WDRESETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDRESETR::NORESET => false,
                    WDRESETR::RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDRESETR {
                match value {
                    false => WDRESETR::NORESET,
                    true => WDRESETR::RESET,
                }
            }
            #[doc = "Checks if the value of the field is `NORESET`"]
            #[inline(always)]
            pub fn is_noreset(&self) -> bool {
                *self == WDRESETR::NORESET
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                *self == WDRESETR::RESET
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTOFR {
            bits: bool,
        }
        impl WDTOFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDINTR {
            bits: bool,
        }
        impl WDINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WDPROTECT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDPROTECTR {
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            THE_WATCHDOG_TIME_OU0,
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            THE_WATCHDOG_TIME_OU1,
        }
        impl WDPROTECTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDPROTECTR::THE_WATCHDOG_TIME_OU0 => false,
                    WDPROTECTR::THE_WATCHDOG_TIME_OU1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDPROTECTR {
                match value {
                    false => WDPROTECTR::THE_WATCHDOG_TIME_OU0,
                    true => WDPROTECTR::THE_WATCHDOG_TIME_OU1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_WATCHDOG_TIME_OU0`"]
            #[inline(always)]
            pub fn is_the_watchdog_time_ou0(&self) -> bool {
                *self == WDPROTECTR::THE_WATCHDOG_TIME_OU0
            }
            #[doc = "Checks if the value of the field is `THE_WATCHDOG_TIME_OU1`"]
            #[inline(always)]
            pub fn is_the_watchdog_time_ou1(&self) -> bool {
                *self == WDPROTECTR::THE_WATCHDOG_TIME_OU1
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOCKR {
            bits: bool,
        }
        impl LOCKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `WDEN`"]
        pub enum WDENW {
            #[doc = "The watchdog timer is stopped."]
            STOPPED,
            #[doc = "The watchdog timer is running."]
            RUNNING,
        }
        impl WDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDENW::STOPPED => false,
                    WDENW::RUNNING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog timer is stopped."]
            #[inline(always)]
            pub fn stopped(self) -> &'a mut W {
                self.variant(WDENW::STOPPED)
            }
            #[doc = "The watchdog timer is running."]
            #[inline(always)]
            pub fn running(self) -> &'a mut W {
                self.variant(WDENW::RUNNING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDRESET`"]
        pub enum WDRESETW {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            NORESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            RESET,
        }
        impl WDRESETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDRESETW::NORESET => false,
                    WDRESETW::RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDRESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDRESETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDRESETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "A watchdog timeout will not cause a chip reset."]
            #[inline(always)]
            pub fn noreset(self) -> &'a mut W {
                self.variant(WDRESETW::NORESET)
            }
            #[doc = "A watchdog timeout will cause a chip reset."]
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(WDRESETW::RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDPROTECT`"]
        pub enum WDPROTECTW {
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            THE_WATCHDOG_TIME_OU0,
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            THE_WATCHDOG_TIME_OU1,
        }
        impl WDPROTECTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDPROTECTW::THE_WATCHDOG_TIME_OU0 => false,
                    WDPROTECTW::THE_WATCHDOG_TIME_OU1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDPROTECTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDPROTECTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDPROTECTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog time-out value (TC) can be changed at any time."]
            #[inline(always)]
            pub fn the_watchdog_time_ou0(self) -> &'a mut W {
                self.variant(WDPROTECTW::THE_WATCHDOG_TIME_OU0)
            }
            #[doc = "The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW."]
            #[inline(always)]
            pub fn the_watchdog_time_ou1(self) -> &'a mut W {
                self.variant(WDPROTECTW::THE_WATCHDOG_TIME_OU1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1, it cannot be rewritten with a 0."]
            #[inline(always)]
            pub fn wden(&self) -> WDENR {
                WDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0."]
            #[inline(always)]
            pub fn wdreset(&self) -> WDRESETR {
                WDRESETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline(always)]
            pub fn wdtof(&self) -> WDTOFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDTOFR { bits }
            }
            #[doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline(always)]
            pub fn wdint(&self) -> WDINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDINTR { bits }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset."]
            #[inline(always)]
            pub fn wdprotect(&self) -> WDPROTECTR {
                WDPROTECTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the watchdog oscillator. This bit can be set once by software and is only cleared by any reset."]
            #[inline(always)]
            pub fn lock(&self) -> LOCKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LOCKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Watchdog enable bit. Once this bit has been written with a 1, it cannot be rewritten with a 0."]
            #[inline(always)]
            pub fn wden(&mut self) -> _WDENW {
                _WDENW { w: self }
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0."]
            #[inline(always)]
            pub fn wdreset(&mut self) -> _WDRESETW {
                _WDRESETW { w: self }
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline(always)]
            pub fn wdtof(&mut self) -> _WDTOFW {
                _WDTOFW { w: self }
            }
            #[doc = "Bit 3 - Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline(always)]
            pub fn wdint(&mut self) -> _WDINTW {
                _WDINTW { w: self }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit can be set once by software and is only cleared by a reset."]
            #[inline(always)]
            pub fn wdprotect(&mut self) -> _WDPROTECTW {
                _WDPROTECTW { w: self }
            }
            #[doc = "Bit 5 - A 1 in this bit prevents disabling or powering down the watchdog oscillator. This bit can be set once by software and is only cleared by any reset."]
            #[inline(always)]
            pub fn lock(&mut self) -> _LOCKW {
                _LOCKW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer constant register. This 24-bit register determines the time-out value."]
    pub struct TC {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog timer constant register. This 24-bit register determines the time-out value."]
    pub mod tc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog time-out value."]
            #[inline(always)]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 255 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog time-out value."]
            #[inline(always)]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub struct FEED {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub mod feed {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FEED {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FEEDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Feed value should be 0xAA followed by 0x55."]
            #[inline(always)]
            pub fn feed(&mut self) -> _FEEDW {
                _FEEDW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
    pub struct TV {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer."]
    pub mod tv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TV {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Counter timer value."]
            #[inline(always)]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub struct WARNINT {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub mod warnint {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WARNINT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WARNINTR {
            bits: u16,
        }
        impl WARNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WARNINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WARNINTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 1023;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline(always)]
            pub fn warnint(&self) -> WARNINTR {
                let bits = {
                    const MASK: u16 = 1023;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                WARNINTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline(always)]
            pub fn warnint(&mut self) -> _WARNINTW {
                _WARNINTW { w: self }
            }
        }
    }
    #[doc = "Watchdog Window compare value."]
    pub struct WINDOW {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog Window compare value."]
    pub mod window {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WINDOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINDOWR {
            bits: u32,
        }
        impl WINDOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINDOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINDOWW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline(always)]
            pub fn window(&self) -> WINDOWR {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WINDOWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 16777215 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline(always)]
            pub fn window(&mut self) -> _WINDOWW {
                _WINDOWW { w: self }
            }
        }
    }
}
#[doc = "Windowed Watchdog Timer (WWDT)"]
pub struct WWDT {
    register_block: wwdt::RegisterBlock,
}
impl Deref for WWDT {
    type Target = wwdt::RegisterBlock;
    fn deref(&self) -> &wwdt::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Multi-Rate Timer (MRT)"]
pub const MRT: Peripheral<MRT> = unsafe { Peripheral::new(1073758208) };
#[doc = "Multi-Rate Timer (MRT)"]
pub mod mrt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval0: INTVAL,
        #[doc = "0x04 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer0: TIMER,
        #[doc = "0x08 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl0: CTRL,
        #[doc = "0x0c - MRT0 Status register."]
        pub stat0: STAT,
        #[doc = "0x10 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval1: INTVAL,
        #[doc = "0x14 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer1: TIMER,
        #[doc = "0x18 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl1: CTRL,
        #[doc = "0x1c - MRT0 Status register."]
        pub stat1: STAT,
        #[doc = "0x20 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval2: INTVAL,
        #[doc = "0x24 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer2: TIMER,
        #[doc = "0x28 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl2: CTRL,
        #[doc = "0x2c - MRT0 Status register."]
        pub stat2: STAT,
        #[doc = "0x30 - MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
        pub intval3: INTVAL,
        #[doc = "0x34 - MRT0 Timer register. This register reads the value of the down-counter."]
        pub timer3: TIMER,
        #[doc = "0x38 - MRT0 Control register. This register controls the MRT0 modes."]
        pub ctrl3: CTRL,
        #[doc = "0x3c - MRT0 Status register."]
        pub stat3: STAT,
        _reserved0: [u8; 180usize],
        #[doc = "0xf4 - Idle channel register. This register returns the number of the first idle channel."]
        pub idle_ch: IDLE_CH,
        #[doc = "0xf8 - Global interrupt flag register"]
        pub irq_flag: IRQ_FLAG,
    }
    #[doc = "MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
    pub struct INTVAL {
        register: VolatileCell<u32>,
    }
    #[doc = "MRT0 Time interval value register. This value is loaded into the TIMER0 register."]
    pub mod intval {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTVAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IVALUER {
            bits: u32,
        }
        impl IVALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LOAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOADR {
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            NO_FORCE_LOAD_THE_L,
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            FORCE_LOAD_THE_INTV,
        }
        impl LOADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOADR::NO_FORCE_LOAD_THE_L => false,
                    LOADR::FORCE_LOAD_THE_INTV => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOADR {
                match value {
                    false => LOADR::NO_FORCE_LOAD_THE_L,
                    true => LOADR::FORCE_LOAD_THE_INTV,
                }
            }
            #[doc = "Checks if the value of the field is `NO_FORCE_LOAD_THE_L`"]
            #[inline(always)]
            pub fn is_no_force_load_the_l(&self) -> bool {
                *self == LOADR::NO_FORCE_LOAD_THE_L
            }
            #[doc = "Checks if the value of the field is `FORCE_LOAD_THE_INTV`"]
            #[inline(always)]
            pub fn is_force_load_the_intv(&self) -> bool {
                *self == LOADR::FORCE_LOAD_THE_INTV
            }
        }
        #[doc = r" Proxy"]
        pub struct _IVALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IVALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 16777215;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOAD`"]
        pub enum LOADW {
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            NO_FORCE_LOAD_THE_L,
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            FORCE_LOAD_THE_INTV,
        }
        impl LOADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOADW::NO_FORCE_LOAD_THE_L => false,
                    LOADW::FORCE_LOAD_THE_INTV => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LOADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected."]
            #[inline(always)]
            pub fn no_force_load_the_l(self) -> &'a mut W {
                self.variant(LOADW::NO_FORCE_LOAD_THE_L)
            }
            #[doc = "Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running."]
            #[inline(always)]
            pub fn force_load_the_intv(self) -> &'a mut W {
                self.variant(LOADW::FORCE_LOAD_THE_INTV)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately. If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval."]
            #[inline(always)]
            pub fn ivalue(&self) -> IVALUER {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                IVALUER { bits }
            }
            #[doc = "Bit 31 - Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0."]
            #[inline(always)]
            pub fn load(&self) -> LOADR {
                LOADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately. If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval."]
            #[inline(always)]
            pub fn ivalue(&mut self) -> _IVALUEW {
                _IVALUEW { w: self }
            }
            #[doc = "Bit 31 - Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0."]
            #[inline(always)]
            pub fn load(&mut self) -> _LOADW {
                _LOADW { w: self }
            }
        }
    }
    #[doc = "MRT0 Timer register. This register reads the value of the down-counter."]
    pub struct TIMER {
        register: VolatileCell<u32>,
    }
    #[doc = "MRT0 Timer register. This register reads the value of the down-counter."]
    pub mod timer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TIMER {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF)."]
            #[inline(always)]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 16777215;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
    }
    #[doc = "MRT0 Control register. This register controls the MRT0 modes."]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "MRT0 Control register. This register controls the MRT0 modes."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTENR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl INTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INTENR::DISABLE_ => false,
                    INTENR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INTENR {
                match value {
                    false => INTENR::DISABLE_,
                    true => INTENR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == INTENR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == INTENR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Repeat interrupt mode."]
            REPEAT_INTERRUPT_MOD,
            #[doc = "One-shot interrupt mode."]
            ONE_SHOT_INTERRUPT_M,
            #[doc = "One-shot bus stall mode."]
            ONE_SHOT_BUS_STALL_M,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::REPEAT_INTERRUPT_MOD => 0,
                    MODER::ONE_SHOT_INTERRUPT_M => 1,
                    MODER::ONE_SHOT_BUS_STALL_M => 2,
                    MODER::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::REPEAT_INTERRUPT_MOD,
                    1 => MODER::ONE_SHOT_INTERRUPT_M,
                    2 => MODER::ONE_SHOT_BUS_STALL_M,
                    3 => MODER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `REPEAT_INTERRUPT_MOD`"]
            #[inline(always)]
            pub fn is_repeat_interrupt_mod(&self) -> bool {
                *self == MODER::REPEAT_INTERRUPT_MOD
            }
            #[doc = "Checks if the value of the field is `ONE_SHOT_INTERRUPT_M`"]
            #[inline(always)]
            pub fn is_one_shot_interrupt_m(&self) -> bool {
                *self == MODER::ONE_SHOT_INTERRUPT_M
            }
            #[doc = "Checks if the value of the field is `ONE_SHOT_BUS_STALL_M`"]
            #[inline(always)]
            pub fn is_one_shot_bus_stall_m(&self) -> bool {
                *self == MODER::ONE_SHOT_BUS_STALL_M
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == MODER::RESERVED_
            }
        }
        #[doc = "Values that can be written to the field `INTEN`"]
        pub enum INTENW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl INTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INTENW::DISABLE_ => false,
                    INTENW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(INTENW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(INTENW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Repeat interrupt mode."]
            REPEAT_INTERRUPT_MOD,
            #[doc = "One-shot interrupt mode."]
            ONE_SHOT_INTERRUPT_M,
            #[doc = "One-shot bus stall mode."]
            ONE_SHOT_BUS_STALL_M,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::REPEAT_INTERRUPT_MOD => 0,
                    MODEW::ONE_SHOT_INTERRUPT_M => 1,
                    MODEW::ONE_SHOT_BUS_STALL_M => 2,
                    MODEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Repeat interrupt mode."]
            #[inline(always)]
            pub fn repeat_interrupt_mod(self) -> &'a mut W {
                self.variant(MODEW::REPEAT_INTERRUPT_MOD)
            }
            #[doc = "One-shot interrupt mode."]
            #[inline(always)]
            pub fn one_shot_interrupt_m(self) -> &'a mut W {
                self.variant(MODEW::ONE_SHOT_INTERRUPT_M)
            }
            #[doc = "One-shot bus stall mode."]
            #[inline(always)]
            pub fn one_shot_bus_stall_m(self) -> &'a mut W {
                self.variant(MODEW::ONE_SHOT_BUS_STALL_M)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(MODEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable the TIMERn interrupt."]
            #[inline(always)]
            pub fn inten(&self) -> INTENR {
                INTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:2 - Selects timer mode."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable the TIMERn interrupt."]
            #[inline(always)]
            pub fn inten(&mut self) -> _INTENW {
                _INTENW { w: self }
            }
            #[doc = "Bits 1:2 - Selects timer mode."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
        }
    }
    #[doc = "MRT0 Status register."]
    pub struct STAT {
        register: VolatileCell<u32>,
    }
    #[doc = "MRT0 Status register."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INTFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTFLAGR {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl INTFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INTFLAGR::NO_PENDING_INTERRUPT => false,
                    INTFLAGR::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INTFLAGR {
                match value {
                    false => INTFLAGR::NO_PENDING_INTERRUPT,
                    true => INTFLAGR::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == INTFLAGR::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline(always)]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == INTFLAGR::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `RUN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RUNR {
            #[doc = "Idle state. TIMERn is stopped."]
            IDLE_STATE_TIMERN_I,
            #[doc = "Running. TIMERn is running."]
            RUNNING_TIMERN_IS_R,
        }
        impl RUNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RUNR::IDLE_STATE_TIMERN_I => false,
                    RUNR::RUNNING_TIMERN_IS_R => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RUNR {
                match value {
                    false => RUNR::IDLE_STATE_TIMERN_I,
                    true => RUNR::RUNNING_TIMERN_IS_R,
                }
            }
            #[doc = "Checks if the value of the field is `IDLE_STATE_TIMERN_I`"]
            #[inline(always)]
            pub fn is_idle_state_timern_i(&self) -> bool {
                *self == RUNR::IDLE_STATE_TIMERN_I
            }
            #[doc = "Checks if the value of the field is `RUNNING_TIMERN_IS_R`"]
            #[inline(always)]
            pub fn is_running_timern_is_r(&self) -> bool {
                *self == RUNR::RUNNING_TIMERN_IS_R
            }
        }
        #[doc = "Values that can be written to the field `INTFLAG`"]
        pub enum INTFLAGW {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl INTFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INTFLAGW::NO_PENDING_INTERRUPT => false,
                    INTFLAGW::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INTFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline(always)]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(INTFLAGW::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline(always)]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(INTFLAGW::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RUN`"]
        pub enum RUNW {
            #[doc = "Idle state. TIMERn is stopped."]
            IDLE_STATE_TIMERN_I,
            #[doc = "Running. TIMERn is running."]
            RUNNING_TIMERN_IS_R,
        }
        impl RUNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RUNW::IDLE_STATE_TIMERN_I => false,
                    RUNW::RUNNING_TIMERN_IS_R => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RUNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RUNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Idle state. TIMERn is stopped."]
            #[inline(always)]
            pub fn idle_state_timern_i(self) -> &'a mut W {
                self.variant(RUNW::IDLE_STATE_TIMERN_I)
            }
            #[doc = "Running. TIMERn is running."]
            #[inline(always)]
            pub fn running_timern_is_r(self) -> &'a mut W {
                self.variant(RUNW::RUNNING_TIMERN_IS_R)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Monitors the interrupt flag."]
            #[inline(always)]
            pub fn intflag(&self) -> INTFLAGR {
                INTFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Indicates the state of TIMERn. This bit is read-only."]
            #[inline(always)]
            pub fn run(&self) -> RUNR {
                RUNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Monitors the interrupt flag."]
            #[inline(always)]
            pub fn intflag(&mut self) -> _INTFLAGW {
                _INTFLAGW { w: self }
            }
            #[doc = "Bit 1 - Indicates the state of TIMERn. This bit is read-only."]
            #[inline(always)]
            pub fn run(&mut self) -> _RUNW {
                _RUNW { w: self }
            }
        }
    }
    #[doc = "Idle channel register. This register returns the number of the first idle channel."]
    pub struct IDLE_CH {
        register: VolatileCell<u32>,
    }
    #[doc = "Idle channel register. This register returns the number of the first idle channel."]
    pub mod idle_ch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IDLE_CH {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHANR {
            bits: u8,
        }
        impl CHANR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 4:7 - Idle channel. Reading the CHAN bits, returns the lowest idle timer channel. If all timer channels are running, CHAN = ."]
            #[inline(always)]
            pub fn chan(&self) -> CHANR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHANR { bits }
            }
        }
    }
    #[doc = "Global interrupt flag register"]
    pub struct IRQ_FLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "Global interrupt flag register"]
    pub mod irq_flag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRQ_FLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `GFLAG0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG0R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG0R::NO_PENDING_INTERRUPT => false,
                    GFLAG0R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GFLAG0R {
                match value {
                    false => GFLAG0R::NO_PENDING_INTERRUPT,
                    true => GFLAG0R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG0R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline(always)]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG0R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG1R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG1R::NO_PENDING_INTERRUPT => false,
                    GFLAG1R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GFLAG1R {
                match value {
                    false => GFLAG1R::NO_PENDING_INTERRUPT,
                    true => GFLAG1R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG1R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline(always)]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG1R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG2R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG2R::NO_PENDING_INTERRUPT => false,
                    GFLAG2R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GFLAG2R {
                match value {
                    false => GFLAG2R::NO_PENDING_INTERRUPT,
                    true => GFLAG2R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG2R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline(always)]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG2R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Possible values of the field `GFLAG3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GFLAG3R {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GFLAG3R::NO_PENDING_INTERRUPT => false,
                    GFLAG3R::PENDING_INTERRUPT_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GFLAG3R {
                match value {
                    false => GFLAG3R::NO_PENDING_INTERRUPT,
                    true => GFLAG3R::PENDING_INTERRUPT_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_PENDING_INTERRUPT`"]
            #[inline(always)]
            pub fn is_no_pending_interrupt(&self) -> bool {
                *self == GFLAG3R::NO_PENDING_INTERRUPT
            }
            #[doc = "Checks if the value of the field is `PENDING_INTERRUPT_T`"]
            #[inline(always)]
            pub fn is_pending_interrupt_t(&self) -> bool {
                *self == GFLAG3R::PENDING_INTERRUPT_T
            }
        }
        #[doc = "Values that can be written to the field `GFLAG0`"]
        pub enum GFLAG0W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG0W::NO_PENDING_INTERRUPT => false,
                    GFLAG0W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GFLAG0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline(always)]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG0W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline(always)]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG0W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG1`"]
        pub enum GFLAG1W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG1W::NO_PENDING_INTERRUPT => false,
                    GFLAG1W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GFLAG1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline(always)]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG1W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline(always)]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG1W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG2`"]
        pub enum GFLAG2W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG2W::NO_PENDING_INTERRUPT => false,
                    GFLAG2W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GFLAG2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline(always)]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG2W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline(always)]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG2W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GFLAG3`"]
        pub enum GFLAG3W {
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            NO_PENDING_INTERRUPT,
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request."]
            PENDING_INTERRUPT_T,
        }
        impl GFLAG3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GFLAG3W::NO_PENDING_INTERRUPT => false,
                    GFLAG3W::PENDING_INTERRUPT_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GFLAG3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _GFLAG3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GFLAG3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No pending interrupt. Writing a zero is equivalent to no operation."]
            #[inline(always)]
            pub fn no_pending_interrupt(self) -> &'a mut W {
                self.variant(GFLAG3W::NO_PENDING_INTERRUPT)
            }
            #[doc = "Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised. Writing a 1 to this bit clears the interrupt request."]
            #[inline(always)]
            pub fn pending_interrupt_t(self) -> &'a mut W {
                self.variant(GFLAG3W::PENDING_INTERRUPT_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Monitors the interrupt flag of TIMER0."]
            #[inline(always)]
            pub fn gflag0(&self) -> GFLAG0R {
                GFLAG0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Monitors the interrupt flag of TIMER1."]
            #[inline(always)]
            pub fn gflag1(&self) -> GFLAG1R {
                GFLAG1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Monitors the interrupt flag of TIMER2."]
            #[inline(always)]
            pub fn gflag2(&self) -> GFLAG2R {
                GFLAG2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Monitors the interrupt flag of TIMER3."]
            #[inline(always)]
            pub fn gflag3(&self) -> GFLAG3R {
                GFLAG3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Monitors the interrupt flag of TIMER0."]
            #[inline(always)]
            pub fn gflag0(&mut self) -> _GFLAG0W {
                _GFLAG0W { w: self }
            }
            #[doc = "Bit 1 - Monitors the interrupt flag of TIMER1."]
            #[inline(always)]
            pub fn gflag1(&mut self) -> _GFLAG1W {
                _GFLAG1W { w: self }
            }
            #[doc = "Bit 2 - Monitors the interrupt flag of TIMER2."]
            #[inline(always)]
            pub fn gflag2(&mut self) -> _GFLAG2W {
                _GFLAG2W { w: self }
            }
            #[doc = "Bit 3 - Monitors the interrupt flag of TIMER3."]
            #[inline(always)]
            pub fn gflag3(&mut self) -> _GFLAG3W {
                _GFLAG3W { w: self }
            }
        }
    }
}
#[doc = "Multi-Rate Timer (MRT)"]
pub struct MRT {
    register_block: mrt::RegisterBlock,
}
impl Deref for MRT {
    type Target = mrt::RegisterBlock;
    fn deref(&self) -> &mrt::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Self wake-up timer (WKT)"]
pub const WKT: Peripheral<WKT> = unsafe { Peripheral::new(1073774592) };
#[doc = "Self wake-up timer (WKT)"]
pub mod wkt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Self wake-up timer control register."]
        pub ctrl: CTRL,
        _reserved0: [u8; 8usize],
        #[doc = "0x0c - Counter register."]
        pub count: COUNT,
    }
    #[doc = "Self wake-up timer control register."]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Self wake-up timer control register."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CLKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKSELR {
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            DIVIDED_IRC_CLOCK_T,
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            LOW_POWER_CLOCK_THI,
        }
        impl CLKSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKSELR::DIVIDED_IRC_CLOCK_T => false,
                    CLKSELR::LOW_POWER_CLOCK_THI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLKSELR {
                match value {
                    false => CLKSELR::DIVIDED_IRC_CLOCK_T,
                    true => CLKSELR::LOW_POWER_CLOCK_THI,
                }
            }
            #[doc = "Checks if the value of the field is `DIVIDED_IRC_CLOCK_T`"]
            #[inline(always)]
            pub fn is_divided_irc_clock_t(&self) -> bool {
                *self == CLKSELR::DIVIDED_IRC_CLOCK_T
            }
            #[doc = "Checks if the value of the field is `LOW_POWER_CLOCK_THI`"]
            #[inline(always)]
            pub fn is_low_power_clock_thi(&self) -> bool {
                *self == CLKSELR::LOW_POWER_CLOCK_THI
            }
        }
        #[doc = "Possible values of the field `ALARMFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALARMFLAGR {
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            NO_TIME_OUT_THE_SEL,
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            TIME_OUT_THE_SELF_W,
        }
        impl ALARMFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ALARMFLAGR::NO_TIME_OUT_THE_SEL => false,
                    ALARMFLAGR::TIME_OUT_THE_SELF_W => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ALARMFLAGR {
                match value {
                    false => ALARMFLAGR::NO_TIME_OUT_THE_SEL,
                    true => ALARMFLAGR::TIME_OUT_THE_SELF_W,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT_THE_SEL`"]
            #[inline(always)]
            pub fn is_no_time_out_the_sel(&self) -> bool {
                *self == ALARMFLAGR::NO_TIME_OUT_THE_SEL
            }
            #[doc = "Checks if the value of the field is `TIME_OUT_THE_SELF_W`"]
            #[inline(always)]
            pub fn is_time_out_the_self_w(&self) -> bool {
                *self == ALARMFLAGR::TIME_OUT_THE_SELF_W
            }
        }
        #[doc = "Possible values of the field `CLEARCTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLEARCTRR {
            #[doc = "No effect. Reading this bit always returns 0."]
            NO_EFFECT_READING_T,
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            CLEAR_THE_COUNTER_C,
        }
        impl CLEARCTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLEARCTRR::NO_EFFECT_READING_T => false,
                    CLEARCTRR::CLEAR_THE_COUNTER_C => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLEARCTRR {
                match value {
                    false => CLEARCTRR::NO_EFFECT_READING_T,
                    true => CLEARCTRR::CLEAR_THE_COUNTER_C,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_READING_T`"]
            #[inline(always)]
            pub fn is_no_effect_reading_t(&self) -> bool {
                *self == CLEARCTRR::NO_EFFECT_READING_T
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_COUNTER_C`"]
            #[inline(always)]
            pub fn is_clear_the_counter_c(&self) -> bool {
                *self == CLEARCTRR::CLEAR_THE_COUNTER_C
            }
        }
        #[doc = "Values that can be written to the field `CLKSEL`"]
        pub enum CLKSELW {
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            DIVIDED_IRC_CLOCK_T,
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            LOW_POWER_CLOCK_THI,
        }
        impl CLKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKSELW::DIVIDED_IRC_CLOCK_T => false,
                    CLKSELW::LOW_POWER_CLOCK_THI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes."]
            #[inline(always)]
            pub fn divided_irc_clock_t(self) -> &'a mut W {
                self.variant(CLKSELW::DIVIDED_IRC_CLOCK_T)
            }
            #[doc = "Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed."]
            #[inline(always)]
            pub fn low_power_clock_thi(self) -> &'a mut W {
                self.variant(CLKSELW::LOW_POWER_CLOCK_THI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ALARMFLAG`"]
        pub enum ALARMFLAGW {
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            NO_TIME_OUT_THE_SEL,
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            TIME_OUT_THE_SELF_W,
        }
        impl ALARMFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ALARMFLAGW::NO_TIME_OUT_THE_SEL => false,
                    ALARMFLAGW::TIME_OUT_THE_SELF_W => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ALARMFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ALARMFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ALARMFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect."]
            #[inline(always)]
            pub fn no_time_out_the_sel(self) -> &'a mut W {
                self.variant(ALARMFLAGW::NO_TIME_OUT_THE_SEL)
            }
            #[doc = "Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?"]
            #[inline(always)]
            pub fn time_out_the_self_w(self) -> &'a mut W {
                self.variant(ALARMFLAGW::TIME_OUT_THE_SELF_W)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLEARCTR`"]
        pub enum CLEARCTRW {
            #[doc = "No effect. Reading this bit always returns 0."]
            NO_EFFECT_READING_T,
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            CLEAR_THE_COUNTER_C,
        }
        impl CLEARCTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLEARCTRW::NO_EFFECT_READING_T => false,
                    CLEARCTRW::CLEAR_THE_COUNTER_C => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLEARCTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLEARCTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLEARCTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect. Reading this bit always returns 0."]
            #[inline(always)]
            pub fn no_effect_reading_t(self) -> &'a mut W {
                self.variant(CLEARCTRW::NO_EFFECT_READING_T)
            }
            #[doc = "Clear the counter. Counting is halted until a new count value is loaded."]
            #[inline(always)]
            pub fn clear_the_counter_c(self) -> &'a mut W {
                self.variant(CLEARCTRW::CLEAR_THE_COUNTER_C)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Select the self wake-up timer clock source."]
            #[inline(always)]
            pub fn clksel(&self) -> CLKSELR {
                CLKSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Wake-up or alarm timer flag."]
            #[inline(always)]
            pub fn alarmflag(&self) -> ALARMFLAGR {
                ALARMFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Clears the self wake-up timer."]
            #[inline(always)]
            pub fn clearctr(&self) -> CLEARCTRR {
                CLEARCTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Select the self wake-up timer clock source."]
            #[inline(always)]
            pub fn clksel(&mut self) -> _CLKSELW {
                _CLKSELW { w: self }
            }
            #[doc = "Bit 1 - Wake-up or alarm timer flag."]
            #[inline(always)]
            pub fn alarmflag(&mut self) -> _ALARMFLAGW {
                _ALARMFLAGW { w: self }
            }
            #[doc = "Bit 2 - Clears the self wake-up timer."]
            #[inline(always)]
            pub fn clearctr(&mut self) -> _CLEARCTRW {
                _CLEARCTRW { w: self }
            }
        }
    }
    #[doc = "Counter register."]
    pub struct COUNT {
        register: VolatileCell<u32>,
    }
    #[doc = "Counter register."]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u32,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALUEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - A write to this register pre-loads start count value into the timer and starts the count-down sequence. A read reflects the current value of the timer."]
            #[inline(always)]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                VALUER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - A write to this register pre-loads start count value into the timer and starts the count-down sequence. A read reflects the current value of the timer."]
            #[inline(always)]
            pub fn value(&mut self) -> _VALUEW {
                _VALUEW { w: self }
            }
        }
    }
}
#[doc = "Self wake-up timer (WKT)"]
pub struct WKT {
    register_block: wkt::RegisterBlock,
}
impl Deref for WKT {
    type Target = wkt::RegisterBlock;
    fn deref(&self) -> &wkt::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Switch matrix (SWM)"]
pub const SWM: Peripheral<SWM> = unsafe { Peripheral::new(1073790976) };
#[doc = "Switch matrix (SWM)"]
pub mod swm {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS"]
        pub pinassign0: PINASSIGN0,
        #[doc = "0x04 - Pin assign register 1. Assign movable functions U0_SCLC, U1_TXD, U1_RXD"]
        pub pinassign1: PINASSIGN1,
        #[doc = "0x08 - Pin assign register 2. Assign movable functions U2_TXD, U2_RXD"]
        pub pinassign2: PINASSIGN2,
        #[doc = "0x0c - Pin assignregister 3. Assign movable function SPI0_SCK"]
        pub pinassign3: PINASSIGN3,
        #[doc = "0x10 - Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL, SPI1_SCK"]
        pub pinassign4: PINASSIGN4,
        #[doc = "0x14 - Pin assign register 5. Assign movable functions SPI1_MOSI, SPI1_MISO, SPI1_SSEL, CTIN_0"]
        pub pinassign5: PINASSIGN5,
        #[doc = "0x18 - Pin assign register 6. Assign movable functions CTIN_1, CTIN_2, CTIN_3, CTOUT_0"]
        pub pinassign6: PINASSIGN6,
        #[doc = "0x1c - Pin assign egister 7. Assign movable functions CTOUT_1, CTOUT_2, CTOUT_3, I2C_SDA"]
        pub pinassign7: PINASSIGN7,
        #[doc = "0x20 - Pin assign register 8. Assign movable functions I2C_SCL, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
        pub pinassign8: PINASSIGN8,
        _reserved0: [u8; 412usize],
        #[doc = "0x1c0 - Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP"]
        pub pinenable0: PINENABLE0,
    }
    #[doc = "Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS"]
    pub struct PINASSIGN0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS"]
    pub mod pinassign0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_TXD_OR {
            bits: u8,
        }
        impl U0_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_RXD_IR {
            bits: u8,
        }
        impl U0_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_RTS_OR {
            bits: u8,
        }
        impl U0_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_CTS_IR {
            bits: u8,
        }
        impl U0_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U0_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_txd_o(&self) -> U0_TXD_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_TXD_OR { bits }
            }
            #[doc = "Bits 8:15 - U0_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_rxd_i(&self) -> U0_RXD_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_RXD_IR { bits }
            }
            #[doc = "Bits 16:23 - U0_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_rts_o(&self) -> U0_RTS_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_RTS_OR { bits }
            }
            #[doc = "Bits 24:31 - U0_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_cts_i(&self) -> U0_CTS_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_CTS_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U0_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_txd_o(&mut self) -> _U0_TXD_OW {
                _U0_TXD_OW { w: self }
            }
            #[doc = "Bits 8:15 - U0_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_rxd_i(&mut self) -> _U0_RXD_IW {
                _U0_RXD_IW { w: self }
            }
            #[doc = "Bits 16:23 - U0_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_rts_o(&mut self) -> _U0_RTS_OW {
                _U0_RTS_OW { w: self }
            }
            #[doc = "Bits 24:31 - U0_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_cts_i(&mut self) -> _U0_CTS_IW {
                _U0_CTS_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 1. Assign movable functions U0_SCLC, U1_TXD, U1_RXD"]
    pub struct PINASSIGN1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 1. Assign movable functions U0_SCLC, U1_TXD, U1_RXD"]
    pub mod pinassign1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U0_SCLK_IOR {
            bits: u8,
        }
        impl U0_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_TXD_OR {
            bits: u8,
        }
        impl U1_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_RXD_IR {
            bits: u8,
        }
        impl U1_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_RTS_OR {
            bits: u8,
        }
        impl U1_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U0_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U0_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U0_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_sclk_io(&self) -> U0_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U0_SCLK_IOR { bits }
            }
            #[doc = "Bits 8:15 - U1_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_txd_o(&self) -> U1_TXD_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_TXD_OR { bits }
            }
            #[doc = "Bits 16:23 - U1_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_rxd_i(&self) -> U1_RXD_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_RXD_IR { bits }
            }
            #[doc = "Bits 24:31 - U1_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_rts_o(&self) -> U1_RTS_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_RTS_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U0_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u0_sclk_io(&mut self) -> _U0_SCLK_IOW {
                _U0_SCLK_IOW { w: self }
            }
            #[doc = "Bits 8:15 - U1_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_txd_o(&mut self) -> _U1_TXD_OW {
                _U1_TXD_OW { w: self }
            }
            #[doc = "Bits 16:23 - U1_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_rxd_i(&mut self) -> _U1_RXD_IW {
                _U1_RXD_IW { w: self }
            }
            #[doc = "Bits 24:31 - U1_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_rts_o(&mut self) -> _U1_RTS_OW {
                _U1_RTS_OW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 2. Assign movable functions U2_TXD, U2_RXD"]
    pub struct PINASSIGN2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 2. Assign movable functions U2_TXD, U2_RXD"]
    pub mod pinassign2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_CTS_IR {
            bits: u8,
        }
        impl U1_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U1_SCLK_IOR {
            bits: u8,
        }
        impl U1_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_TXD_OR {
            bits: u8,
        }
        impl U2_TXD_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_RXD_IR {
            bits: u8,
        }
        impl U2_RXD_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U1_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U1_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_TXD_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_TXD_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_RXD_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_RXD_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U1_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_cts_i(&self) -> U1_CTS_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_CTS_IR { bits }
            }
            #[doc = "Bits 8:15 - U1_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_sclk_io(&self) -> U1_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U1_SCLK_IOR { bits }
            }
            #[doc = "Bits 16:23 - U2_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_txd_o(&self) -> U2_TXD_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_TXD_OR { bits }
            }
            #[doc = "Bits 24:31 - U2_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_rxd_i(&self) -> U2_RXD_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_RXD_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U1_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_cts_i(&mut self) -> _U1_CTS_IW {
                _U1_CTS_IW { w: self }
            }
            #[doc = "Bits 8:15 - U1_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u1_sclk_io(&mut self) -> _U1_SCLK_IOW {
                _U1_SCLK_IOW { w: self }
            }
            #[doc = "Bits 16:23 - U2_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_txd_o(&mut self) -> _U2_TXD_OW {
                _U2_TXD_OW { w: self }
            }
            #[doc = "Bits 24:31 - U2_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_rxd_i(&mut self) -> _U2_RXD_IW {
                _U2_RXD_IW { w: self }
            }
        }
    }
    #[doc = "Pin assignregister 3. Assign movable function SPI0_SCK"]
    pub struct PINASSIGN3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assignregister 3. Assign movable function SPI0_SCK"]
    pub mod pinassign3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_RTS_OR {
            bits: u8,
        }
        impl U2_RTS_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_CTS_IR {
            bits: u8,
        }
        impl U2_CTS_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct U2_SCLK_IOR {
            bits: u8,
        }
        impl U2_SCLK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SCK_IOR {
            bits: u8,
        }
        impl SPI0_SCK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_RTS_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_RTS_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_CTS_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_CTS_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _U2_SCLK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _U2_SCLK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SCK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SCK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - U2_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_rts_o(&self) -> U2_RTS_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_RTS_OR { bits }
            }
            #[doc = "Bits 8:15 - U2_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_cts_i(&self) -> U2_CTS_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_CTS_IR { bits }
            }
            #[doc = "Bits 16:23 - U2_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_sclk_io(&self) -> U2_SCLK_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                U2_SCLK_IOR { bits }
            }
            #[doc = "Bits 24:31 - SPI0_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_sck_io(&self) -> SPI0_SCK_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SCK_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - U2_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_rts_o(&mut self) -> _U2_RTS_OW {
                _U2_RTS_OW { w: self }
            }
            #[doc = "Bits 8:15 - U2_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_cts_i(&mut self) -> _U2_CTS_IW {
                _U2_CTS_IW { w: self }
            }
            #[doc = "Bits 16:23 - U2_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn u2_sclk_io(&mut self) -> _U2_SCLK_IOW {
                _U2_SCLK_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SPI0_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_sck_io(&mut self) -> _SPI0_SCK_IOW {
                _SPI0_SCK_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL, SPI1_SCK"]
    pub struct PINASSIGN4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL, SPI1_SCK"]
    pub mod pinassign4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_MOSI_IOR {
            bits: u8,
        }
        impl SPI0_MOSI_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_MISO_IOR {
            bits: u8,
        }
        impl SPI0_MISO_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI0_SSEL_IOR {
            bits: u8,
        }
        impl SPI0_SSEL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_SCK_IOR {
            bits: u8,
        }
        impl SPI1_SCK_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_MOSI_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_MOSI_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_MISO_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_MISO_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_SSEL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_SSEL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_SCK_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_SCK_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SPI0_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_mosi_io(&self) -> SPI0_MOSI_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_MOSI_IOR { bits }
            }
            #[doc = "Bits 8:15 - SPI0_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_miso_io(&self) -> SPI0_MISO_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_MISO_IOR { bits }
            }
            #[doc = "Bits 16:23 - SPI0_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_ssel_io(&self) -> SPI0_SSEL_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI0_SSEL_IOR { bits }
            }
            #[doc = "Bits 24:31 - SPI1_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_sck_io(&self) -> SPI1_SCK_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_SCK_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SPI0_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_mosi_io(&mut self) -> _SPI0_MOSI_IOW {
                _SPI0_MOSI_IOW { w: self }
            }
            #[doc = "Bits 8:15 - SPI0_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_miso_io(&mut self) -> _SPI0_MISO_IOW {
                _SPI0_MISO_IOW { w: self }
            }
            #[doc = "Bits 16:23 - SPI0_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi0_ssel_io(&mut self) -> _SPI0_SSEL_IOW {
                _SPI0_SSEL_IOW { w: self }
            }
            #[doc = "Bits 24:31 - SPI1_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_sck_io(&mut self) -> _SPI1_SCK_IOW {
                _SPI1_SCK_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 5. Assign movable functions SPI1_MOSI, SPI1_MISO, SPI1_SSEL, CTIN_0"]
    pub struct PINASSIGN5 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 5. Assign movable functions SPI1_MOSI, SPI1_MISO, SPI1_SSEL, CTIN_0"]
    pub mod pinassign5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_MOSI_IOR {
            bits: u8,
        }
        impl SPI1_MOSI_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_MISO_IOR {
            bits: u8,
        }
        impl SPI1_MISO_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct SPI1_SSEL_IOR {
            bits: u8,
        }
        impl SPI1_SSEL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTIN_0_IR {
            bits: u8,
        }
        impl CTIN_0_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_MOSI_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_MOSI_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_MISO_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_MISO_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_SSEL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_SSEL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIN_0_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIN_0_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SPI1_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_mosi_io(&self) -> SPI1_MOSI_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_MOSI_IOR { bits }
            }
            #[doc = "Bits 8:15 - SPI1_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_miso_io(&self) -> SPI1_MISO_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_MISO_IOR { bits }
            }
            #[doc = "Bits 16:23 - SPI1_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_ssel_io(&self) -> SPI1_SSEL_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SPI1_SSEL_IOR { bits }
            }
            #[doc = "Bits 24:31 - CTIN_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_0_i(&self) -> CTIN_0_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTIN_0_IR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SPI1_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_mosi_io(&mut self) -> _SPI1_MOSI_IOW {
                _SPI1_MOSI_IOW { w: self }
            }
            #[doc = "Bits 8:15 - SPI1_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_miso_io(&mut self) -> _SPI1_MISO_IOW {
                _SPI1_MISO_IOW { w: self }
            }
            #[doc = "Bits 16:23 - SPI1_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn spi1_ssel_io(&mut self) -> _SPI1_SSEL_IOW {
                _SPI1_SSEL_IOW { w: self }
            }
            #[doc = "Bits 24:31 - CTIN_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_0_i(&mut self) -> _CTIN_0_IW {
                _CTIN_0_IW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 6. Assign movable functions CTIN_1, CTIN_2, CTIN_3, CTOUT_0"]
    pub struct PINASSIGN6 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 6. Assign movable functions CTIN_1, CTIN_2, CTIN_3, CTOUT_0"]
    pub mod pinassign6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTIN_1_IR {
            bits: u8,
        }
        impl CTIN_1_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTIN_2_IR {
            bits: u8,
        }
        impl CTIN_2_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTIN_3_IR {
            bits: u8,
        }
        impl CTIN_3_IR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTOUT_0_OR {
            bits: u8,
        }
        impl CTOUT_0_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIN_1_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIN_1_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIN_2_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIN_2_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIN_3_IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIN_3_IW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTOUT_0_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTOUT_0_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CTIN_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_1_i(&self) -> CTIN_1_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTIN_1_IR { bits }
            }
            #[doc = "Bits 8:15 - CTIN_2function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_2_i(&self) -> CTIN_2_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTIN_2_IR { bits }
            }
            #[doc = "Bits 16:23 - CTIN_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_3_i(&self) -> CTIN_3_IR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTIN_3_IR { bits }
            }
            #[doc = "Bits 24:31 - CTOUT_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_0_o(&self) -> CTOUT_0_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTOUT_0_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - CTIN_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_1_i(&mut self) -> _CTIN_1_IW {
                _CTIN_1_IW { w: self }
            }
            #[doc = "Bits 8:15 - CTIN_2function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_2_i(&mut self) -> _CTIN_2_IW {
                _CTIN_2_IW { w: self }
            }
            #[doc = "Bits 16:23 - CTIN_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctin_3_i(&mut self) -> _CTIN_3_IW {
                _CTIN_3_IW { w: self }
            }
            #[doc = "Bits 24:31 - CTOUT_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_0_o(&mut self) -> _CTOUT_0_OW {
                _CTOUT_0_OW { w: self }
            }
        }
    }
    #[doc = "Pin assign egister 7. Assign movable functions CTOUT_1, CTOUT_2, CTOUT_3, I2C_SDA"]
    pub struct PINASSIGN7 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign egister 7. Assign movable functions CTOUT_1, CTOUT_2, CTOUT_3, I2C_SDA"]
    pub mod pinassign7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTOUT_1_OR {
            bits: u8,
        }
        impl CTOUT_1_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTOUT_2_OR {
            bits: u8,
        }
        impl CTOUT_2_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTOUT_3_OR {
            bits: u8,
        }
        impl CTOUT_3_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C_SDA_IOR {
            bits: u8,
        }
        impl I2C_SDA_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTOUT_1_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTOUT_1_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTOUT_2_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTOUT_2_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTOUT_3_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTOUT_3_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C_SDA_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C_SDA_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CTOUT_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_1_o(&self) -> CTOUT_1_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTOUT_1_OR { bits }
            }
            #[doc = "Bits 8:15 - CTOUT_2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_2_o(&self) -> CTOUT_2_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTOUT_2_OR { bits }
            }
            #[doc = "Bits 16:23 - CTOUT_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_3_o(&self) -> CTOUT_3_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTOUT_3_OR { bits }
            }
            #[doc = "Bits 24:31 - I2C_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn i2c_sda_io(&self) -> I2C_SDA_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C_SDA_IOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - CTOUT_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_1_o(&mut self) -> _CTOUT_1_OW {
                _CTOUT_1_OW { w: self }
            }
            #[doc = "Bits 8:15 - CTOUT_2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_2_o(&mut self) -> _CTOUT_2_OW {
                _CTOUT_2_OW { w: self }
            }
            #[doc = "Bits 16:23 - CTOUT_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn ctout_3_o(&mut self) -> _CTOUT_3_OW {
                _CTOUT_3_OW { w: self }
            }
            #[doc = "Bits 24:31 - I2C_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn i2c_sda_io(&mut self) -> _I2C_SDA_IOW {
                _I2C_SDA_IOW { w: self }
            }
        }
    }
    #[doc = "Pin assign register 8. Assign movable functions I2C_SCL, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
    pub struct PINASSIGN8 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin assign register 8. Assign movable functions I2C_SCL, ACMP_O, CLKOUT, GPIO_INT_BMAT"]
    pub mod pinassign8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINASSIGN8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2C_SCL_IOR {
            bits: u8,
        }
        impl I2C_SCL_IOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACMP_O_OR {
            bits: u8,
        }
        impl ACMP_O_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKOUT_OR {
            bits: u8,
        }
        impl CLKOUT_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPIO_INT_BMAT_OR {
            bits: u8,
        }
        impl GPIO_INT_BMAT_OR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C_SCL_IOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C_SCL_IOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_O_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_O_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKOUT_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKOUT_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_INT_BMAT_OW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_INT_BMAT_OW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - I2C_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn i2c_scl_io(&self) -> I2C_SCL_IOR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                I2C_SCL_IOR { bits }
            }
            #[doc = "Bits 8:15 - ACMP_O_O function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn acmp_o_o(&self) -> ACMP_O_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACMP_O_OR { bits }
            }
            #[doc = "Bits 16:23 - CLKOUT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn clkout_o(&self) -> CLKOUT_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKOUT_OR { bits }
            }
            #[doc = "Bits 24:31 - GPIO_INT_BMAT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn gpio_int_bmat_o(&self) -> GPIO_INT_BMAT_OR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GPIO_INT_BMAT_OR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 4294967295 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - I2C_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn i2c_scl_io(&mut self) -> _I2C_SCL_IOW {
                _I2C_SCL_IOW { w: self }
            }
            #[doc = "Bits 8:15 - ACMP_O_O function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn acmp_o_o(&mut self) -> _ACMP_O_OW {
                _ACMP_O_OW { w: self }
            }
            #[doc = "Bits 16:23 - CLKOUT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn clkout_o(&mut self) -> _CLKOUT_OW {
                _CLKOUT_OW { w: self }
            }
            #[doc = "Bits 24:31 - GPIO_INT_BMAT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11)."]
            #[inline(always)]
            pub fn gpio_int_bmat_o(&mut self) -> _GPIO_INT_BMAT_OW {
                _GPIO_INT_BMAT_OW { w: self }
            }
        }
    }
    #[doc = "Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP"]
    pub struct PINENABLE0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP"]
    pub mod pinenable0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINENABLE0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ACMP_I1_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I1_ENR {
            #[doc = "Enable ACMP_I1. This function is enabled on pin PIO0_0."]
            ENABLE_ACMP_I1_THIS,
            #[doc = "Disable ACMP_I1. GPIO function PIO0_0 (default) or any other movable function can be assigned to pin PIO0_0."]
            DISABLE_ACMP_I1_GPI,
        }
        impl ACMP_I1_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I1_ENR::ENABLE_ACMP_I1_THIS => false,
                    ACMP_I1_ENR::DISABLE_ACMP_I1_GPI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMP_I1_ENR {
                match value {
                    false => ACMP_I1_ENR::ENABLE_ACMP_I1_THIS,
                    true => ACMP_I1_ENR::DISABLE_ACMP_I1_GPI,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_ACMP_I1_THIS`"]
            #[inline(always)]
            pub fn is_enable_acmp_i1_this(&self) -> bool {
                *self == ACMP_I1_ENR::ENABLE_ACMP_I1_THIS
            }
            #[doc = "Checks if the value of the field is `DISABLE_ACMP_I1_GPI`"]
            #[inline(always)]
            pub fn is_disable_acmp_i1_gpi(&self) -> bool {
                *self == ACMP_I1_ENR::DISABLE_ACMP_I1_GPI
            }
        }
        #[doc = "Possible values of the field `ACMP_I2_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_I2_ENR {
            #[doc = "Enable ACMP_I2. This function is enabled on pin PIO0_1."]
            ENABLE_ACMP_I2_THIS,
            #[doc = "Disable ACMP_I2. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin PIO0_1."]
            DISABLE_ACMP_I2_GPI,
        }
        impl ACMP_I2_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_I2_ENR::ENABLE_ACMP_I2_THIS => false,
                    ACMP_I2_ENR::DISABLE_ACMP_I2_GPI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMP_I2_ENR {
                match value {
                    false => ACMP_I2_ENR::ENABLE_ACMP_I2_THIS,
                    true => ACMP_I2_ENR::DISABLE_ACMP_I2_GPI,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_ACMP_I2_THIS`"]
            #[inline(always)]
            pub fn is_enable_acmp_i2_this(&self) -> bool {
                *self == ACMP_I2_ENR::ENABLE_ACMP_I2_THIS
            }
            #[doc = "Checks if the value of the field is `DISABLE_ACMP_I2_GPI`"]
            #[inline(always)]
            pub fn is_disable_acmp_i2_gpi(&self) -> bool {
                *self == ACMP_I2_ENR::DISABLE_ACMP_I2_GPI
            }
        }
        #[doc = "Possible values of the field `SWCLK_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWCLK_ENR {
            #[doc = "Enable SWCLK. This function is enabled on pin PIO0_3."]
            ENABLE_SWCLK_THIS_F,
            #[doc = "Disable SWCLK. GPIO function PIO0_3 is selected on this pin. Any other movable function can be assigned to pin PIO0_3."]
            DISABLE_SWCLK_GPIO_,
        }
        impl SWCLK_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SWCLK_ENR::ENABLE_SWCLK_THIS_F => false,
                    SWCLK_ENR::DISABLE_SWCLK_GPIO_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SWCLK_ENR {
                match value {
                    false => SWCLK_ENR::ENABLE_SWCLK_THIS_F,
                    true => SWCLK_ENR::DISABLE_SWCLK_GPIO_,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_SWCLK_THIS_F`"]
            #[inline(always)]
            pub fn is_enable_swclk_this_f(&self) -> bool {
                *self == SWCLK_ENR::ENABLE_SWCLK_THIS_F
            }
            #[doc = "Checks if the value of the field is `DISABLE_SWCLK_GPIO_`"]
            #[inline(always)]
            pub fn is_disable_swclk_gpio_(&self) -> bool {
                *self == SWCLK_ENR::DISABLE_SWCLK_GPIO_
            }
        }
        #[doc = "Possible values of the field `SWDIO_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWDIO_ENR {
            #[doc = "Enable SWDIO. This function is enabled on pin PIO0_2."]
            ENABLE_SWDIO_THIS_F,
            #[doc = "Disable SWDIO. GPIO function PIO0_2 is selected on this pin. Any other movable function can be assigned to pin PIO0_2."]
            DISABLE_SWDIO_GPIO_,
        }
        impl SWDIO_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SWDIO_ENR::ENABLE_SWDIO_THIS_F => false,
                    SWDIO_ENR::DISABLE_SWDIO_GPIO_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SWDIO_ENR {
                match value {
                    false => SWDIO_ENR::ENABLE_SWDIO_THIS_F,
                    true => SWDIO_ENR::DISABLE_SWDIO_GPIO_,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_SWDIO_THIS_F`"]
            #[inline(always)]
            pub fn is_enable_swdio_this_f(&self) -> bool {
                *self == SWDIO_ENR::ENABLE_SWDIO_THIS_F
            }
            #[doc = "Checks if the value of the field is `DISABLE_SWDIO_GPIO_`"]
            #[inline(always)]
            pub fn is_disable_swdio_gpio_(&self) -> bool {
                *self == SWDIO_ENR::DISABLE_SWDIO_GPIO_
            }
        }
        #[doc = "Possible values of the field `XTALIN_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALIN_ENR {
            #[doc = "Enable XTALIN. This function is enabled on pin PIO0_8."]
            ENABLE_XTALIN_THIS_,
            #[doc = "Disable XTALIN. GPIO function PIO0_8 (default) or any other movable function can be assigned to pin PIO0_8."]
            DISABLE_XTALIN_GPIO,
        }
        impl XTALIN_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    XTALIN_ENR::ENABLE_XTALIN_THIS_ => false,
                    XTALIN_ENR::DISABLE_XTALIN_GPIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> XTALIN_ENR {
                match value {
                    false => XTALIN_ENR::ENABLE_XTALIN_THIS_,
                    true => XTALIN_ENR::DISABLE_XTALIN_GPIO,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_XTALIN_THIS_`"]
            #[inline(always)]
            pub fn is_enable_xtalin_this_(&self) -> bool {
                *self == XTALIN_ENR::ENABLE_XTALIN_THIS_
            }
            #[doc = "Checks if the value of the field is `DISABLE_XTALIN_GPIO`"]
            #[inline(always)]
            pub fn is_disable_xtalin_gpio(&self) -> bool {
                *self == XTALIN_ENR::DISABLE_XTALIN_GPIO
            }
        }
        #[doc = "Possible values of the field `XTALOUT_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALOUT_ENR {
            #[doc = "Enable XTALOUT. This function is enabled on pin PIO0_9."]
            ENABLE_XTALOUT_THIS,
            #[doc = "Disable XTALOUT. GPIO function PIO0_9 (default) or any other movable function can be assigned to pin PIO0_9."]
            DISABLE_XTALOUT_GPI,
        }
        impl XTALOUT_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    XTALOUT_ENR::ENABLE_XTALOUT_THIS => false,
                    XTALOUT_ENR::DISABLE_XTALOUT_GPI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> XTALOUT_ENR {
                match value {
                    false => XTALOUT_ENR::ENABLE_XTALOUT_THIS,
                    true => XTALOUT_ENR::DISABLE_XTALOUT_GPI,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_XTALOUT_THIS`"]
            #[inline(always)]
            pub fn is_enable_xtalout_this(&self) -> bool {
                *self == XTALOUT_ENR::ENABLE_XTALOUT_THIS
            }
            #[doc = "Checks if the value of the field is `DISABLE_XTALOUT_GPI`"]
            #[inline(always)]
            pub fn is_disable_xtalout_gpi(&self) -> bool {
                *self == XTALOUT_ENR::DISABLE_XTALOUT_GPI
            }
        }
        #[doc = "Possible values of the field `RESET_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESET_ENR {
            #[doc = "Enable RESET. This function is enabled on pin PIO0_5."]
            ENABLE_RESET_THIS_F,
            #[doc = "Disable RESET. GPIO function PIO0_5 is selected on this pin. Any other movable function can be assigned to pin PIO0_5."]
            DISABLE_RESET_GPIO_,
        }
        impl RESET_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RESET_ENR::ENABLE_RESET_THIS_F => false,
                    RESET_ENR::DISABLE_RESET_GPIO_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RESET_ENR {
                match value {
                    false => RESET_ENR::ENABLE_RESET_THIS_F,
                    true => RESET_ENR::DISABLE_RESET_GPIO_,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_RESET_THIS_F`"]
            #[inline(always)]
            pub fn is_enable_reset_this_f(&self) -> bool {
                *self == RESET_ENR::ENABLE_RESET_THIS_F
            }
            #[doc = "Checks if the value of the field is `DISABLE_RESET_GPIO_`"]
            #[inline(always)]
            pub fn is_disable_reset_gpio_(&self) -> bool {
                *self == RESET_ENR::DISABLE_RESET_GPIO_
            }
        }
        #[doc = "Possible values of the field `CLKIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKINR {
            #[doc = "Enable CLKIN. This function is enabled on pin PIO0_1."]
            ENABLE_CLKIN_THIS_F,
            #[doc = "Disable CLKIN. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin CLKIN."]
            DISABLE_CLKIN_GPIO_,
        }
        impl CLKINR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKINR::ENABLE_CLKIN_THIS_F => false,
                    CLKINR::DISABLE_CLKIN_GPIO_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLKINR {
                match value {
                    false => CLKINR::ENABLE_CLKIN_THIS_F,
                    true => CLKINR::DISABLE_CLKIN_GPIO_,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_CLKIN_THIS_F`"]
            #[inline(always)]
            pub fn is_enable_clkin_this_f(&self) -> bool {
                *self == CLKINR::ENABLE_CLKIN_THIS_F
            }
            #[doc = "Checks if the value of the field is `DISABLE_CLKIN_GPIO_`"]
            #[inline(always)]
            pub fn is_disable_clkin_gpio_(&self) -> bool {
                *self == CLKINR::DISABLE_CLKIN_GPIO_
            }
        }
        #[doc = "Possible values of the field `VDDCMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VDDCMPR {
            #[doc = "Enable VDDCMP. This function is enabled on pin PIO0_6."]
            ENABLE_VDDCMP_THIS_,
            #[doc = "Disable VDDCMP. GPIO function PIO0_6 (default) or any other movable function can be assigned to pin PIO0_6."]
            DISABLE_VDDCMP_GPIO,
        }
        impl VDDCMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    VDDCMPR::ENABLE_VDDCMP_THIS_ => false,
                    VDDCMPR::DISABLE_VDDCMP_GPIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> VDDCMPR {
                match value {
                    false => VDDCMPR::ENABLE_VDDCMP_THIS_,
                    true => VDDCMPR::DISABLE_VDDCMP_GPIO,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE_VDDCMP_THIS_`"]
            #[inline(always)]
            pub fn is_enable_vddcmp_this_(&self) -> bool {
                *self == VDDCMPR::ENABLE_VDDCMP_THIS_
            }
            #[doc = "Checks if the value of the field is `DISABLE_VDDCMP_GPIO`"]
            #[inline(always)]
            pub fn is_disable_vddcmp_gpio(&self) -> bool {
                *self == VDDCMPR::DISABLE_VDDCMP_GPIO
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I1_EN`"]
        pub enum ACMP_I1_ENW {
            #[doc = "Enable ACMP_I1. This function is enabled on pin PIO0_0."]
            ENABLE_ACMP_I1_THIS,
            #[doc = "Disable ACMP_I1. GPIO function PIO0_0 (default) or any other movable function can be assigned to pin PIO0_0."]
            DISABLE_ACMP_I1_GPI,
        }
        impl ACMP_I1_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I1_ENW::ENABLE_ACMP_I1_THIS => false,
                    ACMP_I1_ENW::DISABLE_ACMP_I1_GPI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I1_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I1_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMP_I1_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable ACMP_I1. This function is enabled on pin PIO0_0."]
            #[inline(always)]
            pub fn enable_acmp_i1_this(self) -> &'a mut W {
                self.variant(ACMP_I1_ENW::ENABLE_ACMP_I1_THIS)
            }
            #[doc = "Disable ACMP_I1. GPIO function PIO0_0 (default) or any other movable function can be assigned to pin PIO0_0."]
            #[inline(always)]
            pub fn disable_acmp_i1_gpi(self) -> &'a mut W {
                self.variant(ACMP_I1_ENW::DISABLE_ACMP_I1_GPI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_I2_EN`"]
        pub enum ACMP_I2_ENW {
            #[doc = "Enable ACMP_I2. This function is enabled on pin PIO0_1."]
            ENABLE_ACMP_I2_THIS,
            #[doc = "Disable ACMP_I2. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin PIO0_1."]
            DISABLE_ACMP_I2_GPI,
        }
        impl ACMP_I2_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_I2_ENW::ENABLE_ACMP_I2_THIS => false,
                    ACMP_I2_ENW::DISABLE_ACMP_I2_GPI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_I2_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_I2_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMP_I2_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable ACMP_I2. This function is enabled on pin PIO0_1."]
            #[inline(always)]
            pub fn enable_acmp_i2_this(self) -> &'a mut W {
                self.variant(ACMP_I2_ENW::ENABLE_ACMP_I2_THIS)
            }
            #[doc = "Disable ACMP_I2. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin PIO0_1."]
            #[inline(always)]
            pub fn disable_acmp_i2_gpi(self) -> &'a mut W {
                self.variant(ACMP_I2_ENW::DISABLE_ACMP_I2_GPI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWCLK_EN`"]
        pub enum SWCLK_ENW {
            #[doc = "Enable SWCLK. This function is enabled on pin PIO0_3."]
            ENABLE_SWCLK_THIS_F,
            #[doc = "Disable SWCLK. GPIO function PIO0_3 is selected on this pin. Any other movable function can be assigned to pin PIO0_3."]
            DISABLE_SWCLK_GPIO_,
        }
        impl SWCLK_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWCLK_ENW::ENABLE_SWCLK_THIS_F => false,
                    SWCLK_ENW::DISABLE_SWCLK_GPIO_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWCLK_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWCLK_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWCLK_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable SWCLK. This function is enabled on pin PIO0_3."]
            #[inline(always)]
            pub fn enable_swclk_this_f(self) -> &'a mut W {
                self.variant(SWCLK_ENW::ENABLE_SWCLK_THIS_F)
            }
            #[doc = "Disable SWCLK. GPIO function PIO0_3 is selected on this pin. Any other movable function can be assigned to pin PIO0_3."]
            #[inline(always)]
            pub fn disable_swclk_gpio_(self) -> &'a mut W {
                self.variant(SWCLK_ENW::DISABLE_SWCLK_GPIO_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWDIO_EN`"]
        pub enum SWDIO_ENW {
            #[doc = "Enable SWDIO. This function is enabled on pin PIO0_2."]
            ENABLE_SWDIO_THIS_F,
            #[doc = "Disable SWDIO. GPIO function PIO0_2 is selected on this pin. Any other movable function can be assigned to pin PIO0_2."]
            DISABLE_SWDIO_GPIO_,
        }
        impl SWDIO_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWDIO_ENW::ENABLE_SWDIO_THIS_F => false,
                    SWDIO_ENW::DISABLE_SWDIO_GPIO_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWDIO_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWDIO_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWDIO_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable SWDIO. This function is enabled on pin PIO0_2."]
            #[inline(always)]
            pub fn enable_swdio_this_f(self) -> &'a mut W {
                self.variant(SWDIO_ENW::ENABLE_SWDIO_THIS_F)
            }
            #[doc = "Disable SWDIO. GPIO function PIO0_2 is selected on this pin. Any other movable function can be assigned to pin PIO0_2."]
            #[inline(always)]
            pub fn disable_swdio_gpio_(self) -> &'a mut W {
                self.variant(SWDIO_ENW::DISABLE_SWDIO_GPIO_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XTALIN_EN`"]
        pub enum XTALIN_ENW {
            #[doc = "Enable XTALIN. This function is enabled on pin PIO0_8."]
            ENABLE_XTALIN_THIS_,
            #[doc = "Disable XTALIN. GPIO function PIO0_8 (default) or any other movable function can be assigned to pin PIO0_8."]
            DISABLE_XTALIN_GPIO,
        }
        impl XTALIN_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    XTALIN_ENW::ENABLE_XTALIN_THIS_ => false,
                    XTALIN_ENW::DISABLE_XTALIN_GPIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALIN_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALIN_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XTALIN_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable XTALIN. This function is enabled on pin PIO0_8."]
            #[inline(always)]
            pub fn enable_xtalin_this_(self) -> &'a mut W {
                self.variant(XTALIN_ENW::ENABLE_XTALIN_THIS_)
            }
            #[doc = "Disable XTALIN. GPIO function PIO0_8 (default) or any other movable function can be assigned to pin PIO0_8."]
            #[inline(always)]
            pub fn disable_xtalin_gpio(self) -> &'a mut W {
                self.variant(XTALIN_ENW::DISABLE_XTALIN_GPIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `XTALOUT_EN`"]
        pub enum XTALOUT_ENW {
            #[doc = "Enable XTALOUT. This function is enabled on pin PIO0_9."]
            ENABLE_XTALOUT_THIS,
            #[doc = "Disable XTALOUT. GPIO function PIO0_9 (default) or any other movable function can be assigned to pin PIO0_9."]
            DISABLE_XTALOUT_GPI,
        }
        impl XTALOUT_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    XTALOUT_ENW::ENABLE_XTALOUT_THIS => false,
                    XTALOUT_ENW::DISABLE_XTALOUT_GPI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALOUT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALOUT_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: XTALOUT_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable XTALOUT. This function is enabled on pin PIO0_9."]
            #[inline(always)]
            pub fn enable_xtalout_this(self) -> &'a mut W {
                self.variant(XTALOUT_ENW::ENABLE_XTALOUT_THIS)
            }
            #[doc = "Disable XTALOUT. GPIO function PIO0_9 (default) or any other movable function can be assigned to pin PIO0_9."]
            #[inline(always)]
            pub fn disable_xtalout_gpi(self) -> &'a mut W {
                self.variant(XTALOUT_ENW::DISABLE_XTALOUT_GPI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESET_EN`"]
        pub enum RESET_ENW {
            #[doc = "Enable RESET. This function is enabled on pin PIO0_5."]
            ENABLE_RESET_THIS_F,
            #[doc = "Disable RESET. GPIO function PIO0_5 is selected on this pin. Any other movable function can be assigned to pin PIO0_5."]
            DISABLE_RESET_GPIO_,
        }
        impl RESET_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESET_ENW::ENABLE_RESET_THIS_F => false,
                    RESET_ENW::DISABLE_RESET_GPIO_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESET_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESET_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RESET_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable RESET. This function is enabled on pin PIO0_5."]
            #[inline(always)]
            pub fn enable_reset_this_f(self) -> &'a mut W {
                self.variant(RESET_ENW::ENABLE_RESET_THIS_F)
            }
            #[doc = "Disable RESET. GPIO function PIO0_5 is selected on this pin. Any other movable function can be assigned to pin PIO0_5."]
            #[inline(always)]
            pub fn disable_reset_gpio_(self) -> &'a mut W {
                self.variant(RESET_ENW::DISABLE_RESET_GPIO_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKIN`"]
        pub enum CLKINW {
            #[doc = "Enable CLKIN. This function is enabled on pin PIO0_1."]
            ENABLE_CLKIN_THIS_F,
            #[doc = "Disable CLKIN. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin CLKIN."]
            DISABLE_CLKIN_GPIO_,
        }
        impl CLKINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKINW::ENABLE_CLKIN_THIS_F => false,
                    CLKINW::DISABLE_CLKIN_GPIO_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKINW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable CLKIN. This function is enabled on pin PIO0_1."]
            #[inline(always)]
            pub fn enable_clkin_this_f(self) -> &'a mut W {
                self.variant(CLKINW::ENABLE_CLKIN_THIS_F)
            }
            #[doc = "Disable CLKIN. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin CLKIN."]
            #[inline(always)]
            pub fn disable_clkin_gpio_(self) -> &'a mut W {
                self.variant(CLKINW::DISABLE_CLKIN_GPIO_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `VDDCMP`"]
        pub enum VDDCMPW {
            #[doc = "Enable VDDCMP. This function is enabled on pin PIO0_6."]
            ENABLE_VDDCMP_THIS_,
            #[doc = "Disable VDDCMP. GPIO function PIO0_6 (default) or any other movable function can be assigned to pin PIO0_6."]
            DISABLE_VDDCMP_GPIO,
        }
        impl VDDCMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    VDDCMPW::ENABLE_VDDCMP_THIS_ => false,
                    VDDCMPW::DISABLE_VDDCMP_GPIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VDDCMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VDDCMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: VDDCMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable VDDCMP. This function is enabled on pin PIO0_6."]
            #[inline(always)]
            pub fn enable_vddcmp_this_(self) -> &'a mut W {
                self.variant(VDDCMPW::ENABLE_VDDCMP_THIS_)
            }
            #[doc = "Disable VDDCMP. GPIO function PIO0_6 (default) or any other movable function can be assigned to pin PIO0_6."]
            #[inline(always)]
            pub fn disable_vddcmp_gpio(self) -> &'a mut W {
                self.variant(VDDCMPW::DISABLE_VDDCMP_GPIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn acmp_i1_en(&self) -> ACMP_I1_ENR {
                ACMP_I1_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use ACMP_I2, disable the CLKIN function in bit 7 of this register and enable ACMP_I2."]
            #[inline(always)]
            pub fn acmp_i2_en(&self) -> ACMP_I2_ENR {
                ACMP_I2_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn swclk_en(&self) -> SWCLK_ENR {
                SWCLK_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn swdio_en(&self) -> SWDIO_ENR {
                SWDIO_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn xtalin_en(&self) -> XTALIN_ENR {
                XTALIN_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn xtalout_en(&self) -> XTALOUT_ENR {
                XTALOUT_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn reset_en(&self) -> RESET_ENR {
                RESET_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use CLKIN, disable ACMP_I2 in bit 1 of this register and enable CLKIN."]
            #[inline(always)]
            pub fn clkin(&self) -> CLKINR {
                CLKINR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn vddcmp(&self) -> VDDCMPR {
                VDDCMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 435 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn acmp_i1_en(&mut self) -> _ACMP_I1_ENW {
                _ACMP_I1_ENW { w: self }
            }
            #[doc = "Bit 1 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use ACMP_I2, disable the CLKIN function in bit 7 of this register and enable ACMP_I2."]
            #[inline(always)]
            pub fn acmp_i2_en(&mut self) -> _ACMP_I2_ENW {
                _ACMP_I2_ENW { w: self }
            }
            #[doc = "Bit 2 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn swclk_en(&mut self) -> _SWCLK_ENW {
                _SWCLK_ENW { w: self }
            }
            #[doc = "Bit 3 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn swdio_en(&mut self) -> _SWDIO_ENW {
                _SWDIO_ENW { w: self }
            }
            #[doc = "Bit 4 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn xtalin_en(&mut self) -> _XTALIN_ENW {
                _XTALIN_ENW { w: self }
            }
            #[doc = "Bit 5 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn xtalout_en(&mut self) -> _XTALOUT_ENW {
                _XTALOUT_ENW { w: self }
            }
            #[doc = "Bit 6 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default."]
            #[inline(always)]
            pub fn reset_en(&mut self) -> _RESET_ENW {
                _RESET_ENW { w: self }
            }
            #[doc = "Bit 7 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use CLKIN, disable ACMP_I2 in bit 1 of this register and enable CLKIN."]
            #[inline(always)]
            pub fn clkin(&mut self) -> _CLKINW {
                _CLKINW { w: self }
            }
            #[doc = "Bit 8 - Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin."]
            #[inline(always)]
            pub fn vddcmp(&mut self) -> _VDDCMPW {
                _VDDCMPW { w: self }
            }
        }
    }
}
#[doc = "Switch matrix (SWM)"]
pub struct SWM {
    register_block: swm::RegisterBlock,
}
impl Deref for SWM {
    type Target = swm::RegisterBlock;
    fn deref(&self) -> &swm::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Power Management Unit (PMU)"]
pub const PMU: Peripheral<PMU> = unsafe { Peripheral::new(1073872896) };
#[doc = "Power Management Unit (PMU)"]
pub mod pmu {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Power control register"]
        pub pcon: PCON,
        #[doc = "0x04 - General purpose register 0"]
        pub gpreg0: GPREG,
        #[doc = "0x08 - General purpose register 0"]
        pub gpreg1: GPREG,
        #[doc = "0x0c - General purpose register 0"]
        pub gpreg2: GPREG,
        #[doc = "0x10 - General purpose register 0"]
        pub gpreg3: GPREG,
        #[doc = "0x14 - Deep power-down control register"]
        pub dpdctrl: DPDCTRL,
    }
    #[doc = "Power control register"]
    pub struct PCON {
        register: VolatileCell<u32>,
    }
    #[doc = "Power control register"]
    pub mod pcon {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PCON {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PMR {
            #[doc = "Default. The part is in active or sleep mode."]
            DEFAULT_THE_PART_IS,
            #[doc = "ARM WFI will enter Deep-sleep mode."]
            ARM_WFI_WILL_ENTER_D0,
            #[doc = "ARM WFI will enter Power-down mode."]
            ARM_WFI_WILL_ENTER_P,
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)."]
            ARM_WFI_WILL_ENTER_D1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PMR::DEFAULT_THE_PART_IS => 0,
                    PMR::ARM_WFI_WILL_ENTER_D0 => 1,
                    PMR::ARM_WFI_WILL_ENTER_P => 2,
                    PMR::ARM_WFI_WILL_ENTER_D1 => 3,
                    PMR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PMR {
                match value {
                    0 => PMR::DEFAULT_THE_PART_IS,
                    1 => PMR::ARM_WFI_WILL_ENTER_D0,
                    2 => PMR::ARM_WFI_WILL_ENTER_P,
                    3 => PMR::ARM_WFI_WILL_ENTER_D1,
                    i => PMR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DEFAULT_THE_PART_IS`"]
            #[inline(always)]
            pub fn is_default_the_part_is(&self) -> bool {
                *self == PMR::DEFAULT_THE_PART_IS
            }
            #[doc = "Checks if the value of the field is `ARM_WFI_WILL_ENTER_D0`"]
            #[inline(always)]
            pub fn is_arm_wfi_will_enter_d0(&self) -> bool {
                *self == PMR::ARM_WFI_WILL_ENTER_D0
            }
            #[doc = "Checks if the value of the field is `ARM_WFI_WILL_ENTER_P`"]
            #[inline(always)]
            pub fn is_arm_wfi_will_enter_p(&self) -> bool {
                *self == PMR::ARM_WFI_WILL_ENTER_P
            }
            #[doc = "Checks if the value of the field is `ARM_WFI_WILL_ENTER_D1`"]
            #[inline(always)]
            pub fn is_arm_wfi_will_enter_d1(&self) -> bool {
                *self == PMR::ARM_WFI_WILL_ENTER_D1
            }
        }
        #[doc = r" Value of the field"]
        pub struct NODPDR {
            bits: bool,
        }
        impl NODPDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `SLEEPFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPFLAGR {
            #[doc = "Read: No power-down mode entered. LPC11Uxx is in Active mode. Write: No effect."]
            READ_NO_POWER_DOWN_,
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            READ_SLEEPDEEP_SLE,
        }
        impl SLEEPFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLEEPFLAGR::READ_NO_POWER_DOWN_ => false,
                    SLEEPFLAGR::READ_SLEEPDEEP_SLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLEEPFLAGR {
                match value {
                    false => SLEEPFLAGR::READ_NO_POWER_DOWN_,
                    true => SLEEPFLAGR::READ_SLEEPDEEP_SLE,
                }
            }
            #[doc = "Checks if the value of the field is `READ_NO_POWER_DOWN_`"]
            #[inline(always)]
            pub fn is_read_no_power_down_(&self) -> bool {
                *self == SLEEPFLAGR::READ_NO_POWER_DOWN_
            }
            #[doc = "Checks if the value of the field is `READ_SLEEPDEEP_SLE`"]
            #[inline(always)]
            pub fn is_read_sleepdeep_sle(&self) -> bool {
                *self == SLEEPFLAGR::READ_SLEEPDEEP_SLE
            }
        }
        #[doc = "Possible values of the field `DPDFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DPDFLAGR {
            #[doc = "Read: Deep power-down mode  not entered. Write: No effect."]
            READ_DEEP_POWER_DOW0,
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            READ_DEEP_POWER_DOW1,
        }
        impl DPDFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    DPDFLAGR::READ_DEEP_POWER_DOW0 => false,
                    DPDFLAGR::READ_DEEP_POWER_DOW1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> DPDFLAGR {
                match value {
                    false => DPDFLAGR::READ_DEEP_POWER_DOW0,
                    true => DPDFLAGR::READ_DEEP_POWER_DOW1,
                }
            }
            #[doc = "Checks if the value of the field is `READ_DEEP_POWER_DOW0`"]
            #[inline(always)]
            pub fn is_read_deep_power_dow0(&self) -> bool {
                *self == DPDFLAGR::READ_DEEP_POWER_DOW0
            }
            #[doc = "Checks if the value of the field is `READ_DEEP_POWER_DOW1`"]
            #[inline(always)]
            pub fn is_read_deep_power_dow1(&self) -> bool {
                *self == DPDFLAGR::READ_DEEP_POWER_DOW1
            }
        }
        #[doc = "Values that can be written to the field `PM`"]
        pub enum PMW {
            #[doc = "Default. The part is in active or sleep mode."]
            DEFAULT_THE_PART_IS,
            #[doc = "ARM WFI will enter Deep-sleep mode."]
            ARM_WFI_WILL_ENTER_D0,
            #[doc = "ARM WFI will enter Power-down mode."]
            ARM_WFI_WILL_ENTER_P,
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)."]
            ARM_WFI_WILL_ENTER_D1,
        }
        impl PMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PMW::DEFAULT_THE_PART_IS => 0,
                    PMW::ARM_WFI_WILL_ENTER_D0 => 1,
                    PMW::ARM_WFI_WILL_ENTER_P => 2,
                    PMW::ARM_WFI_WILL_ENTER_D1 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PMW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Default. The part is in active or sleep mode."]
            #[inline(always)]
            pub fn default_the_part_is(self) -> &'a mut W {
                self.variant(PMW::DEFAULT_THE_PART_IS)
            }
            #[doc = "ARM WFI will enter Deep-sleep mode."]
            #[inline(always)]
            pub fn arm_wfi_will_enter_d0(self) -> &'a mut W {
                self.variant(PMW::ARM_WFI_WILL_ENTER_D0)
            }
            #[doc = "ARM WFI will enter Power-down mode."]
            #[inline(always)]
            pub fn arm_wfi_will_enter_p(self) -> &'a mut W {
                self.variant(PMW::ARM_WFI_WILL_ENTER_P)
            }
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down)."]
            #[inline(always)]
            pub fn arm_wfi_will_enter_d1(self) -> &'a mut W {
                self.variant(PMW::ARM_WFI_WILL_ENTER_D1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NODPDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NODPDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLEEPFLAG`"]
        pub enum SLEEPFLAGW {
            #[doc = "Read: No power-down mode entered. LPC11Uxx is in Active mode. Write: No effect."]
            READ_NO_POWER_DOWN_,
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            READ_SLEEPDEEP_SLE,
        }
        impl SLEEPFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLEEPFLAGW::READ_NO_POWER_DOWN_ => false,
                    SLEEPFLAGW::READ_SLEEPDEEP_SLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLEEPFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read: No power-down mode entered. LPC11Uxx is in Active mode. Write: No effect."]
            #[inline(always)]
            pub fn read_no_power_down_(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::READ_NO_POWER_DOWN_)
            }
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            #[inline(always)]
            pub fn read_sleepdeep_sle(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::READ_SLEEPDEEP_SLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DPDFLAG`"]
        pub enum DPDFLAGW {
            #[doc = "Read: Deep power-down mode  not entered. Write: No effect."]
            READ_DEEP_POWER_DOW0,
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            READ_DEEP_POWER_DOW1,
        }
        impl DPDFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    DPDFLAGW::READ_DEEP_POWER_DOW0 => false,
                    DPDFLAGW::READ_DEEP_POWER_DOW1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPDFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPDFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DPDFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read: Deep power-down mode not entered. Write: No effect."]
            #[inline(always)]
            pub fn read_deep_power_dow0(self) -> &'a mut W {
                self.variant(DPDFLAGW::READ_DEEP_POWER_DOW0)
            }
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            #[inline(always)]
            pub fn read_deep_power_dow1(self) -> &'a mut W {
                self.variant(DPDFLAGW::READ_DEEP_POWER_DOW1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Power mode"]
            #[inline(always)]
            pub fn pm(&self) -> PMR {
                PMR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked."]
            #[inline(always)]
            pub fn nodpd(&self) -> NODPDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NODPDR { bits }
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline(always)]
            pub fn sleepflag(&self) -> SLEEPFLAGR {
                SLEEPFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline(always)]
            pub fn dpdflag(&self) -> DPDFLAGR {
                DPDFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Power mode"]
            #[inline(always)]
            pub fn pm(&mut self) -> _PMW {
                _PMW { w: self }
            }
            #[doc = "Bit 3 - A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed. This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked."]
            #[inline(always)]
            pub fn nodpd(&mut self) -> _NODPDW {
                _NODPDW { w: self }
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline(always)]
            pub fn sleepflag(&mut self) -> _SLEEPFLAGW {
                _SLEEPFLAGW { w: self }
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline(always)]
            pub fn dpdflag(&mut self) -> _DPDFLAGW {
                _DPDFLAGW { w: self }
            }
        }
    }
    #[doc = "General purpose register 0"]
    pub struct GPREG {
        register: VolatileCell<u32>,
    }
    #[doc = "General purpose register 0"]
    pub mod gpreg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GPREG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPDATAR {
            bits: u32,
        }
        impl GPDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPDATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPDATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline(always)]
            pub fn gpdata(&self) -> GPDATAR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                GPDATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline(always)]
            pub fn gpdata(&mut self) -> _GPDATAW {
                _GPDATAW { w: self }
            }
        }
    }
    #[doc = "Deep power-down control register"]
    pub struct DPDCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Deep power-down control register"]
    pub mod dpdctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DPDCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WAKEUPHYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEUPHYSR {
            #[doc = "Disabled. Hysteresis for WAKUP pin disabled."]
            DISABLED_HYSTERESIS,
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            ENABLED_HYSTERESIS_,
        }
        impl WAKEUPHYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEUPHYSR::DISABLED_HYSTERESIS => false,
                    WAKEUPHYSR::ENABLED_HYSTERESIS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WAKEUPHYSR {
                match value {
                    false => WAKEUPHYSR::DISABLED_HYSTERESIS,
                    true => WAKEUPHYSR::ENABLED_HYSTERESIS_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_HYSTERESIS`"]
            #[inline(always)]
            pub fn is_disabled_hysteresis(&self) -> bool {
                *self == WAKEUPHYSR::DISABLED_HYSTERESIS
            }
            #[doc = "Checks if the value of the field is `ENABLED_HYSTERESIS_`"]
            #[inline(always)]
            pub fn is_enabled_hysteresis_(&self) -> bool {
                *self == WAKEUPHYSR::ENABLED_HYSTERESIS_
            }
        }
        #[doc = "Possible values of the field `WAKEPAD_DISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEPAD_DISABLER {
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            ENABLED_THE_WAKE_UP,
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            DISABLED_SETTING_TH,
        }
        impl WAKEPAD_DISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEPAD_DISABLER::ENABLED_THE_WAKE_UP => false,
                    WAKEPAD_DISABLER::DISABLED_SETTING_TH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WAKEPAD_DISABLER {
                match value {
                    false => WAKEPAD_DISABLER::ENABLED_THE_WAKE_UP,
                    true => WAKEPAD_DISABLER::DISABLED_SETTING_TH,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_WAKE_UP`"]
            #[inline(always)]
            pub fn is_enabled_the_wake_up(&self) -> bool {
                *self == WAKEPAD_DISABLER::ENABLED_THE_WAKE_UP
            }
            #[doc = "Checks if the value of the field is `DISABLED_SETTING_TH`"]
            #[inline(always)]
            pub fn is_disabled_setting_th(&self) -> bool {
                *self == WAKEPAD_DISABLER::DISABLED_SETTING_TH
            }
        }
        #[doc = "Possible values of the field `LPOSCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPOSCENR {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LPOSCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LPOSCENR::DISABLED_ => false,
                    LPOSCENR::ENABLED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LPOSCENR {
                match value {
                    false => LPOSCENR::DISABLED_,
                    true => LPOSCENR::ENABLED_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_`"]
            #[inline(always)]
            pub fn is_disabled_(&self) -> bool {
                *self == LPOSCENR::DISABLED_
            }
            #[doc = "Checks if the value of the field is `ENABLED_`"]
            #[inline(always)]
            pub fn is_enabled_(&self) -> bool {
                *self == LPOSCENR::ENABLED_
            }
        }
        #[doc = "Possible values of the field `LPOSCDPDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPOSCDPDENR {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LPOSCDPDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LPOSCDPDENR::DISABLED_ => false,
                    LPOSCDPDENR::ENABLED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LPOSCDPDENR {
                match value {
                    false => LPOSCDPDENR::DISABLED_,
                    true => LPOSCDPDENR::ENABLED_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_`"]
            #[inline(always)]
            pub fn is_disabled_(&self) -> bool {
                *self == LPOSCDPDENR::DISABLED_
            }
            #[doc = "Checks if the value of the field is `ENABLED_`"]
            #[inline(always)]
            pub fn is_enabled_(&self) -> bool {
                *self == LPOSCDPDENR::ENABLED_
            }
        }
        #[doc = "Values that can be written to the field `WAKEUPHYS`"]
        pub enum WAKEUPHYSW {
            #[doc = "Disabled. Hysteresis for WAKUP pin disabled."]
            DISABLED_HYSTERESIS,
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            ENABLED_HYSTERESIS_,
        }
        impl WAKEUPHYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEUPHYSW::DISABLED_HYSTERESIS => false,
                    WAKEUPHYSW::ENABLED_HYSTERESIS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPHYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPHYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKEUPHYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Hysteresis for WAKUP pin disabled."]
            #[inline(always)]
            pub fn disabled_hysteresis(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::DISABLED_HYSTERESIS)
            }
            #[doc = "Enabled. Hysteresis for WAKEUP pin enabled."]
            #[inline(always)]
            pub fn enabled_hysteresis_(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::ENABLED_HYSTERESIS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WAKEPAD_DISABLE`"]
        pub enum WAKEPAD_DISABLEW {
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            ENABLED_THE_WAKE_UP,
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            DISABLED_SETTING_TH,
        }
        impl WAKEPAD_DISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEPAD_DISABLEW::ENABLED_THE_WAKE_UP => false,
                    WAKEPAD_DISABLEW::DISABLED_SETTING_TH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEPAD_DISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEPAD_DISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WAKEPAD_DISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled. The wake-up function is enabled on pin PIO0_4."]
            #[inline(always)]
            pub fn enabled_the_wake_up(self) -> &'a mut W {
                self.variant(WAKEPAD_DISABLEW::ENABLED_THE_WAKE_UP)
            }
            #[doc = "Disabled. Setting this bit disables the wake-up function on pin PIO0_4."]
            #[inline(always)]
            pub fn disabled_setting_th(self) -> &'a mut W {
                self.variant(WAKEPAD_DISABLEW::DISABLED_SETTING_TH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPOSCEN`"]
        pub enum LPOSCENW {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LPOSCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPOSCENW::DISABLED_ => false,
                    LPOSCENW::ENABLED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPOSCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPOSCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPOSCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline(always)]
            pub fn disabled_(self) -> &'a mut W {
                self.variant(LPOSCENW::DISABLED_)
            }
            #[doc = "Enabled."]
            #[inline(always)]
            pub fn enabled_(self) -> &'a mut W {
                self.variant(LPOSCENW::ENABLED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPOSCDPDEN`"]
        pub enum LPOSCDPDENW {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LPOSCDPDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPOSCDPDENW::DISABLED_ => false,
                    LPOSCDPDENW::ENABLED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPOSCDPDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPOSCDPDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LPOSCDPDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline(always)]
            pub fn disabled_(self) -> &'a mut W {
                self.variant(LPOSCDPDENW::DISABLED_)
            }
            #[doc = "Enabled."]
            #[inline(always)]
            pub fn enabled_(self) -> &'a mut W {
                self.variant(LPOSCDPDENW::ENABLED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - WAKEUP pin hysteresis enable"]
            #[inline(always)]
            pub fn wakeuphys(&self) -> WAKEUPHYSR {
                WAKEUPHYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the self wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used."]
            #[inline(always)]
            pub fn wakepad_disable(&self) -> WAKEPAD_DISABLER {
                WAKEPAD_DISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable the low-power oscillator for use with the 10 kHz self wake-up timer clock. You must set this bit if the CLKSEL bit in the self wake-up timer CTRL bit is set. Do not enable the low-power oscillator if the self wake-up timer is clocked by the divided IRC."]
            #[inline(always)]
            pub fn lposcen(&self) -> LPOSCENR {
                LPOSCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable the low-power oscillator in Deep power-down mode. Setting this bit causes the low-power oscillator to remain running during Deep power-down mode provided that bit 12 in this register is set as well. You must set this bit for the self wake-up timer to be able to wake up the part from Deep power-down mode. Do not set this bit unless you must use the self wake-up timer to wake up from Deep power-down mode."]
            #[inline(always)]
            pub fn lposcdpden(&self) -> LPOSCDPDENR {
                LPOSCDPDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - WAKEUP pin hysteresis enable"]
            #[inline(always)]
            pub fn wakeuphys(&mut self) -> _WAKEUPHYSW {
                _WAKEUPHYSW { w: self }
            }
            #[doc = "Bit 1 - WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the self wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used."]
            #[inline(always)]
            pub fn wakepad_disable(&mut self) -> _WAKEPAD_DISABLEW {
                _WAKEPAD_DISABLEW { w: self }
            }
            #[doc = "Bit 2 - Enable the low-power oscillator for use with the 10 kHz self wake-up timer clock. You must set this bit if the CLKSEL bit in the self wake-up timer CTRL bit is set. Do not enable the low-power oscillator if the self wake-up timer is clocked by the divided IRC."]
            #[inline(always)]
            pub fn lposcen(&mut self) -> _LPOSCENW {
                _LPOSCENW { w: self }
            }
            #[doc = "Bit 3 - Enable the low-power oscillator in Deep power-down mode. Setting this bit causes the low-power oscillator to remain running during Deep power-down mode provided that bit 12 in this register is set as well. You must set this bit for the self wake-up timer to be able to wake up the part from Deep power-down mode. Do not set this bit unless you must use the self wake-up timer to wake up from Deep power-down mode."]
            #[inline(always)]
            pub fn lposcdpden(&mut self) -> _LPOSCDPDENW {
                _LPOSCDPDENW { w: self }
            }
        }
    }
}
#[doc = "Power Management Unit (PMU)"]
pub struct PMU {
    register_block: pmu::RegisterBlock,
}
impl Deref for PMU {
    type Target = pmu::RegisterBlock;
    fn deref(&self) -> &pmu::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Analog comparator"]
pub const CMP: Peripheral<CMP> = unsafe { Peripheral::new(1073889280) };
#[doc = "Analog comparator"]
pub mod cmp {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Comparator control register"]
        pub ctrl: CTRL,
        #[doc = "0x04 - Voltage ladder register"]
        pub lad: LAD,
    }
    #[doc = "Comparator control register"]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Comparator control register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EDGESEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EDGESELR {
            #[doc = "Falling edges"]
            FALLING_EDGES,
            #[doc = "Rising edges"]
            RISING_EDGES,
            #[doc = "Both edges"]
            BOTH_EDGES0,
            #[doc = "Both edges"]
            BOTH_EDGES1,
        }
        impl EDGESELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    EDGESELR::FALLING_EDGES => 0,
                    EDGESELR::RISING_EDGES => 1,
                    EDGESELR::BOTH_EDGES0 => 2,
                    EDGESELR::BOTH_EDGES1 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> EDGESELR {
                match value {
                    0 => EDGESELR::FALLING_EDGES,
                    1 => EDGESELR::RISING_EDGES,
                    2 => EDGESELR::BOTH_EDGES0,
                    3 => EDGESELR::BOTH_EDGES1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES`"]
            #[inline(always)]
            pub fn is_falling_edges(&self) -> bool {
                *self == EDGESELR::FALLING_EDGES
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES`"]
            #[inline(always)]
            pub fn is_rising_edges(&self) -> bool {
                *self == EDGESELR::RISING_EDGES
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES0`"]
            #[inline(always)]
            pub fn is_both_edges0(&self) -> bool {
                *self == EDGESELR::BOTH_EDGES0
            }
            #[doc = "Checks if the value of the field is `BOTH_EDGES1`"]
            #[inline(always)]
            pub fn is_both_edges1(&self) -> bool {
                *self == EDGESELR::BOTH_EDGES1
            }
        }
        #[doc = "Possible values of the field `COMPSA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPSAR {
            #[doc = "Comparator output  is used directly."]
            DIRECT,
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            SYNCH,
        }
        impl COMPSAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPSAR::DIRECT => false,
                    COMPSAR::SYNCH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> COMPSAR {
                match value {
                    false => COMPSAR::DIRECT,
                    true => COMPSAR::SYNCH,
                }
            }
            #[doc = "Checks if the value of the field is `DIRECT`"]
            #[inline(always)]
            pub fn is_direct(&self) -> bool {
                *self == COMPSAR::DIRECT
            }
            #[doc = "Checks if the value of the field is `SYNCH`"]
            #[inline(always)]
            pub fn is_synch(&self) -> bool {
                *self == COMPSAR::SYNCH
            }
        }
        #[doc = "Possible values of the field `COMP_VP_SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP_VP_SELR {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "Internal reference voltage"]
            INTERNAL_REFERENCE_V,
        }
        impl COMP_VP_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMP_VP_SELR::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VP_SELR::ACMP_I1 => 1,
                    COMP_VP_SELR::ACMP_I2 => 2,
                    COMP_VP_SELR::INTERNAL_REFERENCE_V => 6,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMP_VP_SELR {
                match value {
                    0 => COMP_VP_SELR::VOLTAGE_LADDER_OUTPU,
                    1 => COMP_VP_SELR::ACMP_I1,
                    2 => COMP_VP_SELR::ACMP_I2,
                    6 => COMP_VP_SELR::INTERNAL_REFERENCE_V,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VOLTAGE_LADDER_OUTPU`"]
            #[inline(always)]
            pub fn is_voltage_ladder_outpu(&self) -> bool {
                *self == COMP_VP_SELR::VOLTAGE_LADDER_OUTPU
            }
            #[doc = "Checks if the value of the field is `ACMP_I1`"]
            #[inline(always)]
            pub fn is_acmp_i1(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I1
            }
            #[doc = "Checks if the value of the field is `ACMP_I2`"]
            #[inline(always)]
            pub fn is_acmp_i2(&self) -> bool {
                *self == COMP_VP_SELR::ACMP_I2
            }
            #[doc = "Checks if the value of the field is `INTERNAL_REFERENCE_V`"]
            #[inline(always)]
            pub fn is_internal_reference_v(&self) -> bool {
                *self == COMP_VP_SELR::INTERNAL_REFERENCE_V
            }
        }
        #[doc = "Possible values of the field `COMP_VM_SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMP_VM_SELR {
            #[doc = "voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "Internal reference voltage"]
            INTERNAL_REFERENCE_V,
        }
        impl COMP_VM_SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMP_VM_SELR::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VM_SELR::ACMP_I1 => 1,
                    COMP_VM_SELR::ACMP_I2 => 2,
                    COMP_VM_SELR::INTERNAL_REFERENCE_V => 6,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMP_VM_SELR {
                match value {
                    0 => COMP_VM_SELR::VOLTAGE_LADDER_OUTPU,
                    1 => COMP_VM_SELR::ACMP_I1,
                    2 => COMP_VM_SELR::ACMP_I2,
                    6 => COMP_VM_SELR::INTERNAL_REFERENCE_V,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VOLTAGE_LADDER_OUTPU`"]
            #[inline(always)]
            pub fn is_voltage_ladder_outpu(&self) -> bool {
                *self == COMP_VM_SELR::VOLTAGE_LADDER_OUTPU
            }
            #[doc = "Checks if the value of the field is `ACMP_I1`"]
            #[inline(always)]
            pub fn is_acmp_i1(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I1
            }
            #[doc = "Checks if the value of the field is `ACMP_I2`"]
            #[inline(always)]
            pub fn is_acmp_i2(&self) -> bool {
                *self == COMP_VM_SELR::ACMP_I2
            }
            #[doc = "Checks if the value of the field is `INTERNAL_REFERENCE_V`"]
            #[inline(always)]
            pub fn is_internal_reference_v(&self) -> bool {
                *self == COMP_VM_SELR::INTERNAL_REFERENCE_V
            }
        }
        #[doc = r" Value of the field"]
        pub struct EDGECLRR {
            bits: bool,
        }
        impl EDGECLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPSTATR {
            bits: bool,
        }
        impl COMPSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPEDGER {
            bits: bool,
        }
        impl COMPEDGER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "None (the output will switch as the voltages cross)"]
            NONE_THE_OUTPUT_WIL,
            #[doc = "5 mV"]
            _5_MV,
            #[doc = "10 mV"]
            _10_MV,
            #[doc = "20 mV"]
            _20_MV,
        }
        impl HYSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    HYSR::NONE_THE_OUTPUT_WIL => 0,
                    HYSR::_5_MV => 1,
                    HYSR::_10_MV => 2,
                    HYSR::_20_MV => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> HYSR {
                match value {
                    0 => HYSR::NONE_THE_OUTPUT_WIL,
                    1 => HYSR::_5_MV,
                    2 => HYSR::_10_MV,
                    3 => HYSR::_20_MV,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NONE_THE_OUTPUT_WIL`"]
            #[inline(always)]
            pub fn is_none_the_output_wil(&self) -> bool {
                *self == HYSR::NONE_THE_OUTPUT_WIL
            }
            #[doc = "Checks if the value of the field is `_5_MV`"]
            #[inline(always)]
            pub fn is_5_mv(&self) -> bool {
                *self == HYSR::_5_MV
            }
            #[doc = "Checks if the value of the field is `_10_MV`"]
            #[inline(always)]
            pub fn is_10_mv(&self) -> bool {
                *self == HYSR::_10_MV
            }
            #[doc = "Checks if the value of the field is `_20_MV`"]
            #[inline(always)]
            pub fn is_20_mv(&self) -> bool {
                *self == HYSR::_20_MV
            }
        }
        #[doc = "Values that can be written to the field `EDGESEL`"]
        pub enum EDGESELW {
            #[doc = "Falling edges"]
            FALLING_EDGES,
            #[doc = "Rising edges"]
            RISING_EDGES,
            #[doc = "Both edges"]
            BOTH_EDGES0,
            #[doc = "Both edges"]
            BOTH_EDGES1,
        }
        impl EDGESELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EDGESELW::FALLING_EDGES => 0,
                    EDGESELW::RISING_EDGES => 1,
                    EDGESELW::BOTH_EDGES0 => 2,
                    EDGESELW::BOTH_EDGES1 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGESELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGESELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EDGESELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Falling edges"]
            #[inline(always)]
            pub fn falling_edges(self) -> &'a mut W {
                self.variant(EDGESELW::FALLING_EDGES)
            }
            #[doc = "Rising edges"]
            #[inline(always)]
            pub fn rising_edges(self) -> &'a mut W {
                self.variant(EDGESELW::RISING_EDGES)
            }
            #[doc = "Both edges"]
            #[inline(always)]
            pub fn both_edges0(self) -> &'a mut W {
                self.variant(EDGESELW::BOTH_EDGES0)
            }
            #[doc = "Both edges"]
            #[inline(always)]
            pub fn both_edges1(self) -> &'a mut W {
                self.variant(EDGESELW::BOTH_EDGES1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPSA`"]
        pub enum COMPSAW {
            #[doc = "Comparator output  is used directly."]
            DIRECT,
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            SYNCH,
        }
        impl COMPSAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPSAW::DIRECT => false,
                    COMPSAW::SYNCH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPSAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMPSAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Comparator output is used directly."]
            #[inline(always)]
            pub fn direct(self) -> &'a mut W {
                self.variant(COMPSAW::DIRECT)
            }
            #[doc = "Comparator output is synchronized to the bus clock for output to other modules."]
            #[inline(always)]
            pub fn synch(self) -> &'a mut W {
                self.variant(COMPSAW::SYNCH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMP_VP_SEL`"]
        pub enum COMP_VP_SELW {
            #[doc = "Voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "Internal reference voltage"]
            INTERNAL_REFERENCE_V,
        }
        impl COMP_VP_SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMP_VP_SELW::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VP_SELW::ACMP_I1 => 1,
                    COMP_VP_SELW::ACMP_I2 => 2,
                    COMP_VP_SELW::INTERNAL_REFERENCE_V => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP_VP_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP_VP_SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP_VP_SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Voltage ladder output"]
            #[inline(always)]
            pub fn voltage_ladder_outpu(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::VOLTAGE_LADDER_OUTPU)
            }
            #[doc = "ACMP_I1"]
            #[inline(always)]
            pub fn acmp_i1(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I1)
            }
            #[doc = "ACMP_I2"]
            #[inline(always)]
            pub fn acmp_i2(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::ACMP_I2)
            }
            #[doc = "Internal reference voltage"]
            #[inline(always)]
            pub fn internal_reference_v(self) -> &'a mut W {
                self.variant(COMP_VP_SELW::INTERNAL_REFERENCE_V)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMP_VM_SEL`"]
        pub enum COMP_VM_SELW {
            #[doc = "voltage ladder output"]
            VOLTAGE_LADDER_OUTPU,
            #[doc = "ACMP_I1"]
            ACMP_I1,
            #[doc = "ACMP_I2"]
            ACMP_I2,
            #[doc = "Internal reference voltage"]
            INTERNAL_REFERENCE_V,
        }
        impl COMP_VM_SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMP_VM_SELW::VOLTAGE_LADDER_OUTPU => 0,
                    COMP_VM_SELW::ACMP_I1 => 1,
                    COMP_VM_SELW::ACMP_I2 => 2,
                    COMP_VM_SELW::INTERNAL_REFERENCE_V => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMP_VM_SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMP_VM_SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMP_VM_SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "voltage ladder output"]
            #[inline(always)]
            pub fn voltage_ladder_outpu(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::VOLTAGE_LADDER_OUTPU)
            }
            #[doc = "ACMP_I1"]
            #[inline(always)]
            pub fn acmp_i1(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I1)
            }
            #[doc = "ACMP_I2"]
            #[inline(always)]
            pub fn acmp_i2(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::ACMP_I2)
            }
            #[doc = "Internal reference voltage"]
            #[inline(always)]
            pub fn internal_reference_v(self) -> &'a mut W {
                self.variant(COMP_VM_SELW::INTERNAL_REFERENCE_V)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPSTATW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPEDGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPEDGEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "None (the output will switch as the voltages cross)"]
            NONE_THE_OUTPUT_WIL,
            #[doc = "5 mV"]
            _5_MV,
            #[doc = "10 mV"]
            _10_MV,
            #[doc = "20 mV"]
            _20_MV,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    HYSW::NONE_THE_OUTPUT_WIL => 0,
                    HYSW::_5_MV => 1,
                    HYSW::_10_MV => 2,
                    HYSW::_20_MV => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "None (the output will switch as the voltages cross)"]
            #[inline(always)]
            pub fn none_the_output_wil(self) -> &'a mut W {
                self.variant(HYSW::NONE_THE_OUTPUT_WIL)
            }
            #[doc = "5 mV"]
            #[inline(always)]
            pub fn _5_mv(self) -> &'a mut W {
                self.variant(HYSW::_5_MV)
            }
            #[doc = "10 mV"]
            #[inline(always)]
            pub fn _10_mv(self) -> &'a mut W {
                self.variant(HYSW::_10_MV)
            }
            #[doc = "20 mV"]
            #[inline(always)]
            pub fn _20_mv(self) -> &'a mut W {
                self.variant(HYSW::_20_MV)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - This field controls which edges on the comparator output set the COMPEDGE bit (bit 23 below): 00 = Falling edges 01 = Rising edges 1x = Both edges"]
            #[inline(always)]
            pub fn edgesel(&self) -> EDGESELR {
                EDGESELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Comparator output control"]
            #[inline(always)]
            pub fn compsa(&self) -> COMPSAR {
                COMPSAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:10 - Selects positive voltage input"]
            #[inline(always)]
            pub fn comp_vp_sel(&self) -> COMP_VP_SELR {
                COMP_VP_SELR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Selects negative voltage input"]
            #[inline(always)]
            pub fn comp_vm_sel(&self) -> COMP_VM_SELR {
                COMP_VM_SELR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 20 - Interrupt clear bit. To clear the COMPEDGE bit and thus negate the interrupt request, toggle the EDGECLR bit by first writing a 1 and then a 0."]
            #[inline(always)]
            pub fn edgeclr(&self) -> EDGECLRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EDGECLRR { bits }
            }
            #[doc = "Bit 21 - Comparator status. This bit reflects the state of the comparator output."]
            #[inline(always)]
            pub fn compstat(&self) -> COMPSTATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMPSTATR { bits }
            }
            #[doc = "Bit 23 - Comparator edge-detect status."]
            #[inline(always)]
            pub fn compedge(&self) -> COMPEDGER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                COMPEDGER { bits }
            }
            #[doc = "Bits 25:26 - Controls the hysteresis of the comparator. When the comparator is outputting a certain state, this is the difference between the selected signals, in the opposite direction from the state being output, that will switch the output."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - This field controls which edges on the comparator output set the COMPEDGE bit (bit 23 below): 00 = Falling edges 01 = Rising edges 1x = Both edges"]
            #[inline(always)]
            pub fn edgesel(&mut self) -> _EDGESELW {
                _EDGESELW { w: self }
            }
            #[doc = "Bit 6 - Comparator output control"]
            #[inline(always)]
            pub fn compsa(&mut self) -> _COMPSAW {
                _COMPSAW { w: self }
            }
            #[doc = "Bits 8:10 - Selects positive voltage input"]
            #[inline(always)]
            pub fn comp_vp_sel(&mut self) -> _COMP_VP_SELW {
                _COMP_VP_SELW { w: self }
            }
            #[doc = "Bits 11:13 - Selects negative voltage input"]
            #[inline(always)]
            pub fn comp_vm_sel(&mut self) -> _COMP_VM_SELW {
                _COMP_VM_SELW { w: self }
            }
            #[doc = "Bit 20 - Interrupt clear bit. To clear the COMPEDGE bit and thus negate the interrupt request, toggle the EDGECLR bit by first writing a 1 and then a 0."]
            #[inline(always)]
            pub fn edgeclr(&mut self) -> _EDGECLRW {
                _EDGECLRW { w: self }
            }
            #[doc = "Bit 21 - Comparator status. This bit reflects the state of the comparator output."]
            #[inline(always)]
            pub fn compstat(&mut self) -> _COMPSTATW {
                _COMPSTATW { w: self }
            }
            #[doc = "Bit 23 - Comparator edge-detect status."]
            #[inline(always)]
            pub fn compedge(&mut self) -> _COMPEDGEW {
                _COMPEDGEW { w: self }
            }
            #[doc = "Bits 25:26 - Controls the hysteresis of the comparator. When the comparator is outputting a certain state, this is the difference between the selected signals, in the opposite direction from the state being output, that will switch the output."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
        }
    }
    #[doc = "Voltage ladder register"]
    pub struct LAD {
        register: VolatileCell<u32>,
    }
    #[doc = "Voltage ladder register"]
    pub mod lad {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LAD {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LADENR {
            bits: bool,
        }
        impl LADENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LADSELR {
            bits: u8,
        }
        impl LADSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `LADREF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LADREFR {
            #[doc = "Supply pin VDD"]
            SUPPLY_PIN_VDD,
            #[doc = "VDDCMP pin"]
            VDDCMP_PIN,
        }
        impl LADREFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LADREFR::SUPPLY_PIN_VDD => false,
                    LADREFR::VDDCMP_PIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LADREFR {
                match value {
                    false => LADREFR::SUPPLY_PIN_VDD,
                    true => LADREFR::VDDCMP_PIN,
                }
            }
            #[doc = "Checks if the value of the field is `SUPPLY_PIN_VDD`"]
            #[inline(always)]
            pub fn is_supply_pin_vdd(&self) -> bool {
                *self == LADREFR::SUPPLY_PIN_VDD
            }
            #[doc = "Checks if the value of the field is `VDDCMP_PIN`"]
            #[inline(always)]
            pub fn is_vddcmp_pin(&self) -> bool {
                *self == LADREFR::VDDCMP_PIN
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LADREF`"]
        pub enum LADREFW {
            #[doc = "Supply pin VDD"]
            SUPPLY_PIN_VDD,
            #[doc = "VDDCMP pin"]
            VDDCMP_PIN,
        }
        impl LADREFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LADREFW::SUPPLY_PIN_VDD => false,
                    LADREFW::VDDCMP_PIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LADREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LADREFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LADREFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Supply pin VDD"]
            #[inline(always)]
            pub fn supply_pin_vdd(self) -> &'a mut W {
                self.variant(LADREFW::SUPPLY_PIN_VDD)
            }
            #[doc = "VDDCMP pin"]
            #[inline(always)]
            pub fn vddcmp_pin(self) -> &'a mut W {
                self.variant(LADREFW::VDDCMP_PIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Voltage ladder enable"]
            #[inline(always)]
            pub fn laden(&self) -> LADENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LADENR { bits }
            }
            #[doc = "Bits 1:5 - Voltage ladder value. The reference voltage Vref depends on the LADREF bit below. 00000 = VSS 00001 = 1 x Vref/31 00010 = 2 x Vref/31 ... 11111 = Vref"]
            #[inline(always)]
            pub fn ladsel(&self) -> LADSELR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LADSELR { bits }
            }
            #[doc = "Bit 6 - Selects the reference voltage Vref for the voltage ladder:"]
            #[inline(always)]
            pub fn ladref(&self) -> LADREFR {
                LADREFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Voltage ladder enable"]
            #[inline(always)]
            pub fn laden(&mut self) -> _LADENW {
                _LADENW { w: self }
            }
            #[doc = "Bits 1:5 - Voltage ladder value. The reference voltage Vref depends on the LADREF bit below. 00000 = VSS 00001 = 1 x Vref/31 00010 = 2 x Vref/31 ... 11111 = Vref"]
            #[inline(always)]
            pub fn ladsel(&mut self) -> _LADSELW {
                _LADSELW { w: self }
            }
            #[doc = "Bit 6 - Selects the reference voltage Vref for the voltage ladder:"]
            #[inline(always)]
            pub fn ladref(&mut self) -> _LADREFW {
                _LADREFW { w: self }
            }
        }
    }
}
#[doc = "Analog comparator"]
pub struct CMP {
    register_block: cmp::RegisterBlock,
}
impl Deref for CMP {
    type Target = cmp::RegisterBlock;
    fn deref(&self) -> &cmp::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Flash controller"]
pub const FLASHCTRL: Peripheral<FLASHCTRL> = unsafe { Peripheral::new(1074003968) };
#[doc = "Flash controller"]
pub mod flashctrl {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        #[doc = "0x10 - Flash configuration register"]
        pub flashcfg: FLASHCFG,
        _reserved1: [u8; 12usize],
        #[doc = "0x20 - Signature start address register"]
        pub fmsstart: FMSSTART,
        #[doc = "0x24 - Signature stop-address register"]
        pub fmsstop: FMSSTOP,
        _reserved2: [u8; 4usize],
        #[doc = "0x2c - Signature Word"]
        pub fmsw0: FMSW0,
    }
    #[doc = "Flash configuration register"]
    pub struct FLASHCFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Flash configuration register"]
    pub mod flashcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FLASHCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FLASHTIM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHTIMR {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED_0,
            #[doc = "Reserved."]
            RESERVED_1,
        }
        impl FLASHTIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FLASHTIMR::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS => 1,
                    FLASHTIMR::RESERVED_0 => 2,
                    FLASHTIMR::RESERVED_1 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FLASHTIMR {
                match value {
                    0 => FLASHTIMR::_1_SYSTEM_CLOCK_FLASH,
                    1 => FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS,
                    2 => FLASHTIMR::RESERVED_0,
                    3 => FLASHTIMR::RESERVED_1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_1_SYSTEM_CLOCK_FLASH`"]
            #[inline(always)]
            pub fn is_1_system_clock_flash(&self) -> bool {
                *self == FLASHTIMR::_1_SYSTEM_CLOCK_FLASH
            }
            #[doc = "Checks if the value of the field is `_2_SYSTEM_CLOCKS_FLAS`"]
            #[inline(always)]
            pub fn is_2_system_clocks_flas(&self) -> bool {
                *self == FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS
            }
            #[doc = "Checks if the value of the field is `RESERVED_0`"]
            #[inline(always)]
            pub fn is_reserved_0(&self) -> bool {
                *self == FLASHTIMR::RESERVED_0
            }
            #[doc = "Checks if the value of the field is `RESERVED_1`"]
            #[inline(always)]
            pub fn is_reserved_1(&self) -> bool {
                *self == FLASHTIMR::RESERVED_1
            }
        }
        #[doc = "Values that can be written to the field `FLASHTIM`"]
        pub enum FLASHTIMW {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED_0,
            #[doc = "Reserved."]
            RESERVED_1,
        }
        impl FLASHTIMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FLASHTIMW::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS => 1,
                    FLASHTIMW::RESERVED_0 => 2,
                    FLASHTIMW::RESERVED_1 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHTIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHTIMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASHTIMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            #[inline(always)]
            pub fn _1_system_clock_flash(self) -> &'a mut W {
                self.variant(FLASHTIMW::_1_SYSTEM_CLOCK_FLASH)
            }
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 30 MHz)."]
            #[inline(always)]
            pub fn _2_system_clocks_flas(self) -> &'a mut W {
                self.variant(FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_0(self) -> &'a mut W {
                self.variant(FLASHTIMW::RESERVED_0)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_1(self) -> &'a mut W {
                self.variant(FLASHTIMW::RESERVED_1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline(always)]
            pub fn flashtim(&self) -> FLASHTIMR {
                FLASHTIMR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline(always)]
            pub fn flashtim(&mut self) -> _FLASHTIMW {
                _FLASHTIMW { w: self }
            }
        }
    }
    #[doc = "Signature start address register"]
    pub struct FMSSTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Signature start address register"]
    pub mod fmsstart {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTART {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: u32,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 131071;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline(always)]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: u32 = 131071;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STARTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline(always)]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
        }
    }
    #[doc = "Signature stop-address register"]
    pub struct FMSSTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Signature stop-address register"]
    pub mod fmsstop {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTOP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPAR {
            bits: u32,
        }
        impl STOPAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STRTBISTR {
            bits: bool,
        }
        impl STRTBISTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 131071;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STRTBISTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STRTBISTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes. If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111."]
            #[inline(always)]
            pub fn stopa(&self) -> STOPAR {
                let bits = {
                    const MASK: u32 = 131071;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STOPAR { bits }
            }
            #[doc = "Bit 31 - When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared."]
            #[inline(always)]
            pub fn strtbist(&self) -> STRTBISTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STRTBISTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes. If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111."]
            #[inline(always)]
            pub fn stopa(&mut self) -> _STOPAW {
                _STOPAW { w: self }
            }
            #[doc = "Bit 31 - When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared."]
            #[inline(always)]
            pub fn strtbist(&mut self) -> _STRTBISTW {
                _STRTBISTW { w: self }
            }
        }
    }
    #[doc = "Signature Word"]
    pub struct FMSW0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Signature Word"]
    pub mod fmsw0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIGR {
            bits: u32,
        }
        impl SIGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - 32-bit signature."]
            #[inline(always)]
            pub fn sig(&self) -> SIGR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SIGR { bits }
            }
        }
    }
}
#[doc = "Flash controller"]
pub struct FLASHCTRL {
    register_block: flashctrl::RegisterBlock,
}
impl Deref for FLASHCTRL {
    type Target = flashctrl::RegisterBlock;
    fn deref(&self) -> &flashctrl::RegisterBlock {
        &self.register_block
    }
}
#[doc = "I/O configuration (IOCON)"]
pub const IOCON: Peripheral<IOCON> = unsafe { Peripheral::new(1074020352) };
#[doc = "I/O configuration (IOCON)"]
pub mod iocon {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - I/O configuration for pin PIO0_17"]
        pub pio0_17: PIO0_17,
        #[doc = "0x04 - I/O configuration for pin PIO0_13"]
        pub pio0_13: PIO0_13,
        #[doc = "0x08 - I/O configuration for pin PIO0_12"]
        pub pio0_12: PIO0_12,
        #[doc = "0x0c - I/O configuration for pin PIO0_5/RESET"]
        pub pio0_5: PIO0_5,
        #[doc = "0x10 - I/O configuration for pin PIO0_4"]
        pub pio0_4: PIO0_4,
        #[doc = "0x14 - I/O configuration for pin PIO0_3/SWCLK"]
        pub pio0_3: PIO0_3,
        #[doc = "0x18 - I/O configuration for pin PIO0_2/SWDIO"]
        pub pio0_2: PIO0_2,
        #[doc = "0x1c - I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
        pub pio0_11: PIO0_11,
        #[doc = "0x20 - I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
        pub pio0_10: PIO0_10,
        #[doc = "0x24 - I/O configuration for pin PIO0_16"]
        pub pio0_16: PIO0_16,
        #[doc = "0x28 - I/O configuration for pin PIO0_15"]
        pub pio0_15: PIO0_15,
        #[doc = "0x2c - I/O configuration for pin PIO0_1/ACMP_I1/CLKIN"]
        pub pio0_1: PIO0_1,
        _reserved0: [u8; 4usize],
        #[doc = "0x34 - I/O configuration for pin PIO0_9/XTALOUT"]
        pub pio0_9: PIO0_9,
        #[doc = "0x38 - I/O configuration for pin PIO0_8/XTALIN"]
        pub pio0_8: PIO0_8,
        #[doc = "0x3c - I/O configuration for pin PIO0_7"]
        pub pio0_7: PIO0_7,
        #[doc = "0x40 - I/O configuration for pin PIO0_6/VDDCMP"]
        pub pio0_6: PIO0_6,
        #[doc = "0x44 - I/O configuration for pin PIO0_0/ACMP_I0"]
        pub pio0_0: PIO0_0,
        #[doc = "0x48 - I/O configuration for pin PIO0_14"]
        pub pio0_14: PIO0_14,
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub struct PIO0_17 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_17"]
    pub mod pio0_17 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_17 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_13"]
    pub struct PIO0_13 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_13"]
    pub mod pio0_13 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_13 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_12"]
    pub struct PIO0_12 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_12"]
    pub mod pio0_12 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_12 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_5/RESET"]
    pub struct PIO0_5 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_5/RESET"]
    pub mod pio0_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_4"]
    pub struct PIO0_4 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_4"]
    pub mod pio0_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_3/SWCLK"]
    pub struct PIO0_3 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_3/SWCLK"]
    pub mod pio0_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_2/SWDIO"]
    pub struct PIO0_2 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_2/SWDIO"]
    pub mod pio0_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input."]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
    pub struct PIO0_11 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin."]
    pub mod pio0_11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_MODE,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_MODE => 0,
                    I2CMODER::STANDARD_IO => 1,
                    I2CMODER::FAST_MODE_PLUS_I2C => 2,
                    I2CMODER::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_MODE,
                    1 => I2CMODER::STANDARD_IO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    3 => I2CMODER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_MODE`"]
            #[inline(always)]
            pub fn is_standard_mode(&self) -> bool {
                *self == I2CMODER::STANDARD_MODE
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO`"]
            #[inline(always)]
            pub fn is_standard_io(&self) -> bool {
                *self == I2CMODER::STANDARD_IO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline(always)]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == I2CMODER::RESERVED_
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_MODE,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_MODE => 0,
                    I2CMODEW::STANDARD_IO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                    I2CMODEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Standard mode/ Fast-mode I2C."]
            #[inline(always)]
            pub fn standard_mode(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_MODE)
            }
            #[doc = "Standard I/O functionality"]
            #[inline(always)]
            pub fn standard_io(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline(always)]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(I2CMODEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline(always)]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline(always)]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
    pub struct PIO0_10 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin."]
    pub mod pio0_10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_MODE,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_MODE => 0,
                    I2CMODER::STANDARD_IO => 1,
                    I2CMODER::FAST_MODE_PLUS_I2C => 2,
                    I2CMODER::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_MODE,
                    1 => I2CMODER::STANDARD_IO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    3 => I2CMODER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_MODE`"]
            #[inline(always)]
            pub fn is_standard_mode(&self) -> bool {
                *self == I2CMODER::STANDARD_MODE
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO`"]
            #[inline(always)]
            pub fn is_standard_io(&self) -> bool {
                *self == I2CMODER::STANDARD_IO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline(always)]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == I2CMODER::RESERVED_
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C."]
            STANDARD_MODE,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_MODE => 0,
                    I2CMODEW::STANDARD_IO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                    I2CMODEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Standard mode/ Fast-mode I2C."]
            #[inline(always)]
            pub fn standard_mode(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_MODE)
            }
            #[doc = "Standard I/O functionality"]
            #[inline(always)]
            pub fn standard_io(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline(always)]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(I2CMODEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline(always)]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 128 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline(always)]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_16"]
    pub struct PIO0_16 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_16"]
    pub mod pio0_16 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_16 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_15"]
    pub struct PIO0_15 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_15"]
    pub mod pio0_15 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_15 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_1/ACMP_I1/CLKIN"]
    pub struct PIO0_1 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_1/ACMP_I1/CLKIN"]
    pub mod pio0_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_9/XTALOUT"]
    pub struct PIO0_9 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_9/XTALOUT"]
    pub mod pio0_9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_8/XTALIN"]
    pub struct PIO0_8 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_8/XTALIN"]
    pub mod pio0_8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_7"]
    pub struct PIO0_7 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_7"]
    pub mod pio0_7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_6/VDDCMP"]
    pub struct PIO0_6 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_6/VDDCMP"]
    pub mod pio0_6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_0/ACMP_I0"]
    pub struct PIO0_0 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_0/ACMP_I0"]
    pub mod pio0_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_14"]
    pub struct PIO0_14 {
        register: VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_14"]
    pub mod pio0_14 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_14 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 1,
                    MODER::PULL_UP_RESISTOR_ENA => 2,
                    MODER::REPEATER_MODE_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline(always)]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline(always)]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline(always)]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE_`"]
            #[inline(always)]
            pub fn is_repeater_mode_(&self) -> bool {
                *self == MODER::REPEATER_MODE_
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE_ => false,
                    HYSR::ENABLE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE_,
                    true => HYSR::ENABLE_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == HYSR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `ENABLE_`"]
            #[inline(always)]
            pub fn is_enable_(&self) -> bool {
                *self == HYSR::ENABLE_
            }
        }
        #[doc = "Possible values of the field `INV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INVR {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    INVR::INPUT_NOT_INVERTED_ => false,
                    INVR::INPUT_INVERTED_HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> INVR {
                match value {
                    false => INVR::INPUT_NOT_INVERTED_,
                    true => INVR::INPUT_INVERTED_HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_NOT_INVERTED_`"]
            #[inline(always)]
            pub fn is_input_not_inverted_(&self) -> bool {
                *self == INVR::INPUT_NOT_INVERTED_
            }
            #[doc = "Checks if the value of the field is `INPUT_INVERTED_HIGH`"]
            #[inline(always)]
            pub fn is_input_inverted_high(&self) -> bool {
                *self == INVR::INPUT_INVERTED_HIGH
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::DISABLE_ => false,
                    ODR::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::DISABLE_,
                    true => ODR::OPEN_DRAIN_MODE_ENAB,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_`"]
            #[inline(always)]
            pub fn is_disable_(&self) -> bool {
                *self == ODR::DISABLE_
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_MODE_ENAB`"]
            #[inline(always)]
            pub fn is_open_drain_mode_enab(&self) -> bool {
                *self == ODR::OPEN_DRAIN_MODE_ENAB
            }
        }
        #[doc = "Possible values of the field `S_MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum S_MODER {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    S_MODER::BYPASS_INPUT_FILTER_ => 0,
                    S_MODER::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODER::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODER::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> S_MODER {
                match value {
                    0 => S_MODER::BYPASS_INPUT_FILTER_,
                    1 => S_MODER::_1_CLOCK_CYCLE_INPUT,
                    2 => S_MODER::_2_CLOCK_CYCLES_INPU,
                    3 => S_MODER::_3_CLOCK_CYCLES_INPU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `BYPASS_INPUT_FILTER_`"]
            #[inline(always)]
            pub fn is_bypass_input_filter_(&self) -> bool {
                *self == S_MODER::BYPASS_INPUT_FILTER_
            }
            #[doc = "Checks if the value of the field is `_1_CLOCK_CYCLE_INPUT`"]
            #[inline(always)]
            pub fn is_1_clock_cycle_input(&self) -> bool {
                *self == S_MODER::_1_CLOCK_CYCLE_INPUT
            }
            #[doc = "Checks if the value of the field is `_2_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_2_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_2_CLOCK_CYCLES_INPU
            }
            #[doc = "Checks if the value of the field is `_3_CLOCK_CYCLES_INPU`"]
            #[inline(always)]
            pub fn is_3_clock_cycles_inpu(&self) -> bool {
                *self == S_MODER::_3_CLOCK_CYCLES_INPU
            }
        }
        #[doc = "Possible values of the field `CLK_DIV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLK_DIVR {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLK_DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLK_DIVR::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVR::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVR::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVR::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVR::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVR::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVR::IOCONFILTRCLKDIV6_ => 6,
                    CLK_DIVR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLK_DIVR {
                match value {
                    0 => CLK_DIVR::IOCONFILTRCLKDIV0_,
                    1 => CLK_DIVR::IOCONFILTRCLKDIV1_,
                    2 => CLK_DIVR::IOCONFILTRCLKDIV2_,
                    3 => CLK_DIVR::IOCONFILTRCLKDIV3_,
                    4 => CLK_DIVR::IOCONFILTRCLKDIV4_,
                    5 => CLK_DIVR::IOCONFILTRCLKDIV5_,
                    6 => CLK_DIVR::IOCONFILTRCLKDIV6_,
                    i => CLK_DIVR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV0_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv0_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV0_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV1_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv1_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV1_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV2_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv2_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV2_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV3_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv3_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV3_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV4_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv4_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV4_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV5_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv5_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV5_
            }
            #[doc = "Checks if the value of the field is `IOCONFILTRCLKDIV6_`"]
            #[inline(always)]
            pub fn is_ioconfiltrclkdiv6_(&self) -> bool {
                *self == CLK_DIVR::IOCONFILTRCLKDIV6_
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled."]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled."]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode."]
            REPEATER_MODE_,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)."]
            #[inline(always)]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled."]
            #[inline(always)]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled."]
            #[inline(always)]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode."]
            #[inline(always)]
            pub fn repeater_mode_(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Enable."]
            ENABLE_,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE_ => false,
                    HYSW::ENABLE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(HYSW::DISABLE_)
            }
            #[doc = "Enable."]
            #[inline(always)]
            pub fn enable_(self) -> &'a mut W {
                self.variant(HYSW::ENABLE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INV`"]
        pub enum INVW {
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            INPUT_NOT_INVERTED_,
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            INPUT_INVERTED_HIGH,
        }
        impl INVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    INVW::INPUT_NOT_INVERTED_ => false,
                    INVW::INPUT_INVERTED_HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: INVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0)."]
            #[inline(always)]
            pub fn input_not_inverted_(self) -> &'a mut W {
                self.variant(INVW::INPUT_NOT_INVERTED_)
            }
            #[doc = "Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1)."]
            #[inline(always)]
            pub fn input_inverted_high(self) -> &'a mut W {
                self.variant(INVW::INPUT_INVERTED_HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Disable."]
            DISABLE_,
            #[doc = "Open-drain mode enabled.  This is not a true open-drain mode."]
            OPEN_DRAIN_MODE_ENAB,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::DISABLE_ => false,
                    ODW::OPEN_DRAIN_MODE_ENAB => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable."]
            #[inline(always)]
            pub fn disable_(self) -> &'a mut W {
                self.variant(ODW::DISABLE_)
            }
            #[doc = "Open-drain mode enabled. This is not a true open-drain mode."]
            #[inline(always)]
            pub fn open_drain_mode_enab(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_MODE_ENAB)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `S_MODE`"]
        pub enum S_MODEW {
            #[doc = "Bypass input filter."]
            BYPASS_INPUT_FILTER_,
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            _1_CLOCK_CYCLE_INPUT,
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            _2_CLOCK_CYCLES_INPU,
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            _3_CLOCK_CYCLES_INPU,
        }
        impl S_MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    S_MODEW::BYPASS_INPUT_FILTER_ => 0,
                    S_MODEW::_1_CLOCK_CYCLE_INPUT => 1,
                    S_MODEW::_2_CLOCK_CYCLES_INPU => 2,
                    S_MODEW::_3_CLOCK_CYCLES_INPU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _S_MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S_MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: S_MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Bypass input filter."]
            #[inline(always)]
            pub fn bypass_input_filter_(self) -> &'a mut W {
                self.variant(S_MODEW::BYPASS_INPUT_FILTER_)
            }
            #[doc = "1 clock cycle. Input pulses shorter than one filter clock are rejected."]
            #[inline(always)]
            pub fn _1_clock_cycle_input(self) -> &'a mut W {
                self.variant(S_MODEW::_1_CLOCK_CYCLE_INPUT)
            }
            #[doc = "2 clock cycles. Input pulses shorter than two filter clocks are rejected."]
            #[inline(always)]
            pub fn _2_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_2_CLOCK_CYCLES_INPU)
            }
            #[doc = "3 clock cycles. Input pulses shorter than three filter clocks are rejected."]
            #[inline(always)]
            pub fn _3_clock_cycles_inpu(self) -> &'a mut W {
                self.variant(S_MODEW::_3_CLOCK_CYCLES_INPU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLK_DIV`"]
        pub enum CLK_DIVW {
            #[doc = "IOCONFILTRCLKDIV0."]
            IOCONFILTRCLKDIV0_,
            #[doc = "IOCONFILTRCLKDIV1."]
            IOCONFILTRCLKDIV1_,
            #[doc = "IOCONFILTRCLKDIV2."]
            IOCONFILTRCLKDIV2_,
            #[doc = "IOCONFILTRCLKDIV3."]
            IOCONFILTRCLKDIV3_,
            #[doc = "IOCONFILTRCLKDIV4."]
            IOCONFILTRCLKDIV4_,
            #[doc = "IOCONFILTRCLKDIV5."]
            IOCONFILTRCLKDIV5_,
            #[doc = "IOCONFILTRCLKDIV6."]
            IOCONFILTRCLKDIV6_,
        }
        impl CLK_DIVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLK_DIVW::IOCONFILTRCLKDIV0_ => 0,
                    CLK_DIVW::IOCONFILTRCLKDIV1_ => 1,
                    CLK_DIVW::IOCONFILTRCLKDIV2_ => 2,
                    CLK_DIVW::IOCONFILTRCLKDIV3_ => 3,
                    CLK_DIVW::IOCONFILTRCLKDIV4_ => 4,
                    CLK_DIVW::IOCONFILTRCLKDIV5_ => 5,
                    CLK_DIVW::IOCONFILTRCLKDIV6_ => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLK_DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLK_DIVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLK_DIVW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IOCONFILTRCLKDIV0."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv0_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV0_)
            }
            #[doc = "IOCONFILTRCLKDIV1."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv1_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV1_)
            }
            #[doc = "IOCONFILTRCLKDIV2."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv2_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV2_)
            }
            #[doc = "IOCONFILTRCLKDIV3."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv3_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV3_)
            }
            #[doc = "IOCONFILTRCLKDIV4."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv4_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV4_)
            }
            #[doc = "IOCONFILTRCLKDIV5."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv5_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV5_)
            }
            #[doc = "IOCONFILTRCLKDIV6."]
            #[inline(always)]
            pub fn ioconfiltrclkdiv6_(self) -> &'a mut W {
                self.variant(CLK_DIVW::IOCONFILTRCLKDIV6_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&self) -> INVR {
                INVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&self) -> S_MODER {
                S_MODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&self) -> CLK_DIVR {
                CLK_DIVR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 144 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline(always)]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis."]
            #[inline(always)]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 6 - Invert input"]
            #[inline(always)]
            pub fn inv(&mut self) -> _INVW {
                _INVW { w: self }
            }
            #[doc = "Bit 10 - Open-drain mode."]
            #[inline(always)]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
            #[doc = "Bits 11:12 - Digital filter sample mode."]
            #[inline(always)]
            pub fn s_mode(&mut self) -> _S_MODEW {
                _S_MODEW { w: self }
            }
            #[doc = "Bits 13:15 - Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved."]
            #[inline(always)]
            pub fn clk_div(&mut self) -> _CLK_DIVW {
                _CLK_DIVW { w: self }
            }
        }
    }
}
#[doc = "I/O configuration (IOCON)"]
pub struct IOCON {
    register_block: iocon::RegisterBlock,
}
impl Deref for IOCON {
    type Target = iocon::RegisterBlock;
    fn deref(&self) -> &iocon::RegisterBlock {
        &self.register_block
    }
}
#[doc = "System configuration (SYSCON)"]
pub const SYSCON: Peripheral<SYSCON> = unsafe { Peripheral::new(1074036736) };
#[doc = "System configuration (SYSCON)"]
pub mod syscon {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - System memory remap"]
        pub sysmemremap: SYSMEMREMAP,
        #[doc = "0x04 - Peripheral reset control"]
        pub presetctrl: PRESETCTRL,
        #[doc = "0x08 - System PLL control"]
        pub syspllctrl: SYSPLLCTRL,
        #[doc = "0x0c - System PLL status"]
        pub syspllstat: SYSPLLSTAT,
        _reserved0: [u8; 16usize],
        #[doc = "0x20 - System oscillator control"]
        pub sysoscctrl: SYSOSCCTRL,
        #[doc = "0x24 - Watchdog oscillator control"]
        pub wdtoscctrl: WDTOSCCTRL,
        _reserved1: [u8; 8usize],
        #[doc = "0x30 - System reset status register"]
        pub sysrststat: SYSRSTSTAT,
        _reserved2: [u8; 12usize],
        #[doc = "0x40 - System PLL clock source select"]
        pub syspllclksel: SYSPLLCLKSEL,
        #[doc = "0x44 - System PLL clock source update enable"]
        pub syspllclkuen: SYSPLLCLKUEN,
        _reserved3: [u8; 40usize],
        #[doc = "0x70 - Main clock source select"]
        pub mainclksel: MAINCLKSEL,
        #[doc = "0x74 - Main clock source update enable"]
        pub mainclkuen: MAINCLKUEN,
        #[doc = "0x78 - System clock divider"]
        pub sysahbclkdiv: SYSAHBCLKDIV,
        _reserved4: [u8; 4usize],
        #[doc = "0x80 - System clock control"]
        pub sysahbclkctrl: SYSAHBCLKCTRL,
        _reserved5: [u8; 16usize],
        #[doc = "0x94 - UART clock divider"]
        pub uartclkdiv: UARTCLKDIV,
        _reserved6: [u8; 72usize],
        #[doc = "0xe0 - CLKOUT clock source select"]
        pub clkoutsel: CLKOUTSEL,
        #[doc = "0xe4 - CLKOUT clock source update enable"]
        pub clkoutuen: CLKOUTUEN,
        #[doc = "0xe8 - CLKOUT clock divider"]
        pub clkoutdiv: CLKOUTDIV,
        _reserved7: [u8; 4usize],
        #[doc = "0xf0 - UART fractional generator divider value"]
        pub uartfrgdiv: UARTFRGDIV,
        #[doc = "0xf4 - UART fractional generator multiplier value"]
        pub uartfrgmult: UARTFRGMULT,
        _reserved8: [u8; 4usize],
        #[doc = "0xfc - External trace buffer command register"]
        pub exttracecmd: EXTTRACECMD,
        #[doc = "0x100 - POR captured PIO status 0"]
        pub pioporcap0: PIOPORCAP0,
        _reserved9: [u8; 48usize],
        #[doc = "0x134 - Peripheral clock 6 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv6: IOCONCLKDIV6,
        #[doc = "0x138 - Peripheral clock 5 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv5: IOCONCLKDIV5,
        #[doc = "0x13c - Peripheral clock 4 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv4: IOCONCLKDIV4,
        #[doc = "0x140 - Peripheral clock 3 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv3: IOCONCLKDIV3,
        #[doc = "0x144 - Peripheral clock 2 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv2: IOCONCLKDIV2,
        #[doc = "0x148 - Peripheral clock 1 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv1: IOCONCLKDIV1,
        #[doc = "0x14c - Peripheral clock 0 to the IOCON block for programmable glitch filter"]
        pub ioconclkdiv0: IOCONCLKDIV0,
        #[doc = "0x150 - Brown-Out Detect"]
        pub bodctrl: BODCTRL,
        #[doc = "0x154 - System tick counter calibration"]
        pub systckcal: SYSTCKCAL,
        _reserved10: [u8; 24usize],
        #[doc = "0x170 - IQR delay. Allows trade-off between interrupt latency and determinism."]
        pub irqlatency: IRQLATENCY,
        #[doc = "0x174 - NMI Source Control"]
        pub nmisrc: NMISRC,
        #[doc = "0x178 - GPIO Pin Interrupt Select register 0"]
        pub pintsel0: PINTSEL,
        #[doc = "0x17c - GPIO Pin Interrupt Select register 0"]
        pub pintsel1: PINTSEL,
        #[doc = "0x180 - GPIO Pin Interrupt Select register 0"]
        pub pintsel2: PINTSEL,
        #[doc = "0x184 - GPIO Pin Interrupt Select register 0"]
        pub pintsel3: PINTSEL,
        #[doc = "0x188 - GPIO Pin Interrupt Select register 0"]
        pub pintsel4: PINTSEL,
        #[doc = "0x18c - GPIO Pin Interrupt Select register 0"]
        pub pintsel5: PINTSEL,
        #[doc = "0x190 - GPIO Pin Interrupt Select register 0"]
        pub pintsel6: PINTSEL,
        #[doc = "0x194 - GPIO Pin Interrupt Select register 0"]
        pub pintsel7: PINTSEL,
        _reserved11: [u8; 108usize],
        #[doc = "0x204 - Start logic 0 pin wake-up enable register"]
        pub starterp0: STARTERP0,
        _reserved12: [u8; 12usize],
        #[doc = "0x214 - Start logic 1 interrupt wake-up enable register"]
        pub starterp1: STARTERP1,
        _reserved13: [u8; 24usize],
        #[doc = "0x230 - Power-down states in deep-sleep mode"]
        pub pdsleepcfg: PDSLEEPCFG,
        #[doc = "0x234 - Power-down states for wake-up from deep-sleep"]
        pub pdawakecfg: PDAWAKECFG,
        #[doc = "0x238 - Power configuration register"]
        pub pdruncfg: PDRUNCFG,
        _reserved14: [u8; 440usize],
        #[doc = "0x3f4 - Device ID"]
        pub device_id: DEVICE_ID,
    }
    #[doc = "System memory remap"]
    pub struct SYSMEMREMAP {
        register: VolatileCell<u32>,
    }
    #[doc = "System memory remap"]
    pub mod sysmemremap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSMEMREMAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MAPR {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE_IN,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE_INTER,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE_INT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MAPR::BOOT_LOADER_MODE_IN => 0,
                    MAPR::USER_RAM_MODE_INTER => 1,
                    MAPR::USER_FLASH_MODE_INT => 2,
                    MAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MAPR {
                match value {
                    0 => MAPR::BOOT_LOADER_MODE_IN,
                    1 => MAPR::USER_RAM_MODE_INTER,
                    2 => MAPR::USER_FLASH_MODE_INT,
                    i => MAPR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BOOT_LOADER_MODE_IN`"]
            #[inline(always)]
            pub fn is_boot_loader_mode_in(&self) -> bool {
                *self == MAPR::BOOT_LOADER_MODE_IN
            }
            #[doc = "Checks if the value of the field is `USER_RAM_MODE_INTER`"]
            #[inline(always)]
            pub fn is_user_ram_mode_inter(&self) -> bool {
                *self == MAPR::USER_RAM_MODE_INTER
            }
            #[doc = "Checks if the value of the field is `USER_FLASH_MODE_INT`"]
            #[inline(always)]
            pub fn is_user_flash_mode_int(&self) -> bool {
                *self == MAPR::USER_FLASH_MODE_INT
            }
        }
        #[doc = "Values that can be written to the field `MAP`"]
        pub enum MAPW {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE_IN,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE_INTER,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE_INT,
        }
        impl MAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MAPW::BOOT_LOADER_MODE_IN => 0,
                    MAPW::USER_RAM_MODE_INTER => 1,
                    MAPW::USER_FLASH_MODE_INT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MAPW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            #[inline(always)]
            pub fn boot_loader_mode_in(self) -> &'a mut W {
                self.variant(MAPW::BOOT_LOADER_MODE_IN)
            }
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            #[inline(always)]
            pub fn user_ram_mode_inter(self) -> &'a mut W {
                self.variant(MAPW::USER_RAM_MODE_INTER)
            }
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            #[inline(always)]
            pub fn user_flash_mode_int(self) -> &'a mut W {
                self.variant(MAPW::USER_FLASH_MODE_INT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn map(&self) -> MAPR {
                MAPR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 2 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System memory remap. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn map(&mut self) -> _MAPW {
                _MAPW { w: self }
            }
        }
    }
    #[doc = "Peripheral reset control"]
    pub struct PRESETCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral reset control"]
    pub mod presetctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRESETCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SPI0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI0_RST_NR {
            #[doc = "Assert the SPI0 reset."]
            ASSERT_THE_SPI0_RESE,
            #[doc = "Clear the SPI0 reset."]
            CLEAR_THE_SPI0_RESET,
        }
        impl SPI0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI0_RST_NR::ASSERT_THE_SPI0_RESE => false,
                    SPI0_RST_NR::CLEAR_THE_SPI0_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SPI0_RST_NR {
                match value {
                    false => SPI0_RST_NR::ASSERT_THE_SPI0_RESE,
                    true => SPI0_RST_NR::CLEAR_THE_SPI0_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SPI0_RESE`"]
            #[inline(always)]
            pub fn is_assert_the_spi0_rese(&self) -> bool {
                *self == SPI0_RST_NR::ASSERT_THE_SPI0_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SPI0_RESET`"]
            #[inline(always)]
            pub fn is_clear_the_spi0_reset(&self) -> bool {
                *self == SPI0_RST_NR::CLEAR_THE_SPI0_RESET
            }
        }
        #[doc = "Possible values of the field `SPI1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI1_RST_NR {
            #[doc = "Assert the SPI1 reset."]
            ASSERT_THE_SPI1_RESE,
            #[doc = "Clear the SPI1 reset."]
            CLEAR_THE_SPI1_RESET,
        }
        impl SPI1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI1_RST_NR::ASSERT_THE_SPI1_RESE => false,
                    SPI1_RST_NR::CLEAR_THE_SPI1_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SPI1_RST_NR {
                match value {
                    false => SPI1_RST_NR::ASSERT_THE_SPI1_RESE,
                    true => SPI1_RST_NR::CLEAR_THE_SPI1_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SPI1_RESE`"]
            #[inline(always)]
            pub fn is_assert_the_spi1_rese(&self) -> bool {
                *self == SPI1_RST_NR::ASSERT_THE_SPI1_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SPI1_RESET`"]
            #[inline(always)]
            pub fn is_clear_the_spi1_reset(&self) -> bool {
                *self == SPI1_RST_NR::CLEAR_THE_SPI1_RESET
            }
        }
        #[doc = "Possible values of the field `UARTFRG_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UARTFRG_RST_NR {
            #[doc = "Assert the UARTFRG reset."]
            ASSERT_THE_UARTFRG_R,
            #[doc = "Clear the UARTFRG reset."]
            CLEAR_THE_UARTFRG_RE,
        }
        impl UARTFRG_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R => false,
                    UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UARTFRG_RST_NR {
                match value {
                    false => UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R,
                    true => UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_UARTFRG_R`"]
            #[inline(always)]
            pub fn is_assert_the_uartfrg_r(&self) -> bool {
                *self == UARTFRG_RST_NR::ASSERT_THE_UARTFRG_R
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_UARTFRG_RE`"]
            #[inline(always)]
            pub fn is_clear_the_uartfrg_re(&self) -> bool {
                *self == UARTFRG_RST_NR::CLEAR_THE_UARTFRG_RE
            }
        }
        #[doc = "Possible values of the field `USART0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USART0_RST_NR {
            #[doc = "Assert the USART0 reset."]
            ASSERT_THE_USART0_RE,
            #[doc = "Clear the USART0 reset."]
            CLEAR_THE_USART0_RES,
        }
        impl USART0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    USART0_RST_NR::ASSERT_THE_USART0_RE => false,
                    USART0_RST_NR::CLEAR_THE_USART0_RES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> USART0_RST_NR {
                match value {
                    false => USART0_RST_NR::ASSERT_THE_USART0_RE,
                    true => USART0_RST_NR::CLEAR_THE_USART0_RES,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_USART0_RE`"]
            #[inline(always)]
            pub fn is_assert_the_usart0_re(&self) -> bool {
                *self == USART0_RST_NR::ASSERT_THE_USART0_RE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_USART0_RES`"]
            #[inline(always)]
            pub fn is_clear_the_usart0_res(&self) -> bool {
                *self == USART0_RST_NR::CLEAR_THE_USART0_RES
            }
        }
        #[doc = "Possible values of the field `UART1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART1_RST_NR {
            #[doc = "Assert the UART reset."]
            ASSERT_THE_UART_RESE,
            #[doc = "Clear the UART1 reset."]
            CLEAR_THE_UART1_RESE,
        }
        impl UART1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UART1_RST_NR::ASSERT_THE_UART_RESE => false,
                    UART1_RST_NR::CLEAR_THE_UART1_RESE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UART1_RST_NR {
                match value {
                    false => UART1_RST_NR::ASSERT_THE_UART_RESE,
                    true => UART1_RST_NR::CLEAR_THE_UART1_RESE,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_UART_RESE`"]
            #[inline(always)]
            pub fn is_assert_the_uart_rese(&self) -> bool {
                *self == UART1_RST_NR::ASSERT_THE_UART_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_UART1_RESE`"]
            #[inline(always)]
            pub fn is_clear_the_uart1_rese(&self) -> bool {
                *self == UART1_RST_NR::CLEAR_THE_UART1_RESE
            }
        }
        #[doc = "Possible values of the field `UART2_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART2_RST_NR {
            #[doc = "Assert the UART2 reset."]
            ASSERT_THE_UART2_RES,
            #[doc = "Clear the UART2 reset."]
            CLEAR_THE_UART2_RESE,
        }
        impl UART2_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UART2_RST_NR::ASSERT_THE_UART2_RES => false,
                    UART2_RST_NR::CLEAR_THE_UART2_RESE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UART2_RST_NR {
                match value {
                    false => UART2_RST_NR::ASSERT_THE_UART2_RES,
                    true => UART2_RST_NR::CLEAR_THE_UART2_RESE,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_UART2_RES`"]
            #[inline(always)]
            pub fn is_assert_the_uart2_res(&self) -> bool {
                *self == UART2_RST_NR::ASSERT_THE_UART2_RES
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_UART2_RESE`"]
            #[inline(always)]
            pub fn is_clear_the_uart2_rese(&self) -> bool {
                *self == UART2_RST_NR::CLEAR_THE_UART2_RESE
            }
        }
        #[doc = "Possible values of the field `I2C_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_RST_NR {
            #[doc = "Assert the I2C reset."]
            ASSERT_THE_I2C_RESET,
            #[doc = "Clear the I2C reset."]
            CLEAR_THE_I2C_RESET_,
        }
        impl I2C_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C_RST_NR::ASSERT_THE_I2C_RESET => false,
                    I2C_RST_NR::CLEAR_THE_I2C_RESET_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> I2C_RST_NR {
                match value {
                    false => I2C_RST_NR::ASSERT_THE_I2C_RESET,
                    true => I2C_RST_NR::CLEAR_THE_I2C_RESET_,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_I2C_RESET`"]
            #[inline(always)]
            pub fn is_assert_the_i2c_reset(&self) -> bool {
                *self == I2C_RST_NR::ASSERT_THE_I2C_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_I2C_RESET_`"]
            #[inline(always)]
            pub fn is_clear_the_i2c_reset_(&self) -> bool {
                *self == I2C_RST_NR::CLEAR_THE_I2C_RESET_
            }
        }
        #[doc = "Possible values of the field `MRT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MRT_RST_NR {
            #[doc = "Assert the MRT reset."]
            ASSERT_THE_MRT_RESET,
            #[doc = "Clear the MRT reset."]
            CLEAR_THE_MRT_RESET_,
        }
        impl MRT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MRT_RST_NR::ASSERT_THE_MRT_RESET => false,
                    MRT_RST_NR::CLEAR_THE_MRT_RESET_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MRT_RST_NR {
                match value {
                    false => MRT_RST_NR::ASSERT_THE_MRT_RESET,
                    true => MRT_RST_NR::CLEAR_THE_MRT_RESET_,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_MRT_RESET`"]
            #[inline(always)]
            pub fn is_assert_the_mrt_reset(&self) -> bool {
                *self == MRT_RST_NR::ASSERT_THE_MRT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_MRT_RESET_`"]
            #[inline(always)]
            pub fn is_clear_the_mrt_reset_(&self) -> bool {
                *self == MRT_RST_NR::CLEAR_THE_MRT_RESET_
            }
        }
        #[doc = "Possible values of the field `SCT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCT_RST_NR {
            #[doc = "Assert the SCT reset."]
            ASSERT_THE_SCT_RESET,
            #[doc = "Clear the SCT reset."]
            CLEAR_THE_SCT_RESET_,
        }
        impl SCT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCT_RST_NR::ASSERT_THE_SCT_RESET => false,
                    SCT_RST_NR::CLEAR_THE_SCT_RESET_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCT_RST_NR {
                match value {
                    false => SCT_RST_NR::ASSERT_THE_SCT_RESET,
                    true => SCT_RST_NR::CLEAR_THE_SCT_RESET_,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_SCT_RESET`"]
            #[inline(always)]
            pub fn is_assert_the_sct_reset(&self) -> bool {
                *self == SCT_RST_NR::ASSERT_THE_SCT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_SCT_RESET_`"]
            #[inline(always)]
            pub fn is_clear_the_sct_reset_(&self) -> bool {
                *self == SCT_RST_NR::CLEAR_THE_SCT_RESET_
            }
        }
        #[doc = "Possible values of the field `WKT_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKT_RST_NR {
            #[doc = "Assert the WKT reset."]
            ASSERT_THE_WKT_RESET,
            #[doc = "Clear the WKT reset."]
            CLEAR_THE_WKT_RESET_,
        }
        impl WKT_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WKT_RST_NR::ASSERT_THE_WKT_RESET => false,
                    WKT_RST_NR::CLEAR_THE_WKT_RESET_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WKT_RST_NR {
                match value {
                    false => WKT_RST_NR::ASSERT_THE_WKT_RESET,
                    true => WKT_RST_NR::CLEAR_THE_WKT_RESET_,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_WKT_RESET`"]
            #[inline(always)]
            pub fn is_assert_the_wkt_reset(&self) -> bool {
                *self == WKT_RST_NR::ASSERT_THE_WKT_RESET
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_WKT_RESET_`"]
            #[inline(always)]
            pub fn is_clear_the_wkt_reset_(&self) -> bool {
                *self == WKT_RST_NR::CLEAR_THE_WKT_RESET_
            }
        }
        #[doc = "Possible values of the field `GPIO_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GPIO_RST_NR {
            #[doc = "Assert the GPIO reset."]
            ASSERT_THE_GPIO_RESE,
            #[doc = "Clear the GPIO reset."]
            CLEAR_THE_GPIO_RESET,
        }
        impl GPIO_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GPIO_RST_NR::ASSERT_THE_GPIO_RESE => false,
                    GPIO_RST_NR::CLEAR_THE_GPIO_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GPIO_RST_NR {
                match value {
                    false => GPIO_RST_NR::ASSERT_THE_GPIO_RESE,
                    true => GPIO_RST_NR::CLEAR_THE_GPIO_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_GPIO_RESE`"]
            #[inline(always)]
            pub fn is_assert_the_gpio_rese(&self) -> bool {
                *self == GPIO_RST_NR::ASSERT_THE_GPIO_RESE
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_GPIO_RESET`"]
            #[inline(always)]
            pub fn is_clear_the_gpio_reset(&self) -> bool {
                *self == GPIO_RST_NR::CLEAR_THE_GPIO_RESET
            }
        }
        #[doc = "Possible values of the field `FLASH_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_RST_NR {
            #[doc = "Assert the flash controller reset."]
            ASSERT_THE_FLASH_CON,
            #[doc = "Clear the flash controller reset."]
            CLEAR_THE_FLASH_CONT,
        }
        impl FLASH_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_RST_NR::ASSERT_THE_FLASH_CON => false,
                    FLASH_RST_NR::CLEAR_THE_FLASH_CONT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FLASH_RST_NR {
                match value {
                    false => FLASH_RST_NR::ASSERT_THE_FLASH_CON,
                    true => FLASH_RST_NR::CLEAR_THE_FLASH_CONT,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_FLASH_CON`"]
            #[inline(always)]
            pub fn is_assert_the_flash_con(&self) -> bool {
                *self == FLASH_RST_NR::ASSERT_THE_FLASH_CON
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_FLASH_CONT`"]
            #[inline(always)]
            pub fn is_clear_the_flash_cont(&self) -> bool {
                *self == FLASH_RST_NR::CLEAR_THE_FLASH_CONT
            }
        }
        #[doc = "Possible values of the field `ACMP_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMP_RST_NR {
            #[doc = "Assert the analog comparator reset."]
            ASSERT_THE_ANALOG_CO,
            #[doc = "Clear the analog comparator controller reset."]
            CLEAR_THE_ANALOG_COM,
        }
        impl ACMP_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMP_RST_NR::ASSERT_THE_ANALOG_CO => false,
                    ACMP_RST_NR::CLEAR_THE_ANALOG_COM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMP_RST_NR {
                match value {
                    false => ACMP_RST_NR::ASSERT_THE_ANALOG_CO,
                    true => ACMP_RST_NR::CLEAR_THE_ANALOG_COM,
                }
            }
            #[doc = "Checks if the value of the field is `ASSERT_THE_ANALOG_CO`"]
            #[inline(always)]
            pub fn is_assert_the_analog_co(&self) -> bool {
                *self == ACMP_RST_NR::ASSERT_THE_ANALOG_CO
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_ANALOG_COM`"]
            #[inline(always)]
            pub fn is_clear_the_analog_com(&self) -> bool {
                *self == ACMP_RST_NR::CLEAR_THE_ANALOG_COM
            }
        }
        #[doc = "Values that can be written to the field `SPI0_RST_N`"]
        pub enum SPI0_RST_NW {
            #[doc = "Assert the SPI0 reset."]
            ASSERT_THE_SPI0_RESE,
            #[doc = "Clear the SPI0 reset."]
            CLEAR_THE_SPI0_RESET,
        }
        impl SPI0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI0_RST_NW::ASSERT_THE_SPI0_RESE => false,
                    SPI0_RST_NW::CLEAR_THE_SPI0_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SPI0 reset."]
            #[inline(always)]
            pub fn assert_the_spi0_rese(self) -> &'a mut W {
                self.variant(SPI0_RST_NW::ASSERT_THE_SPI0_RESE)
            }
            #[doc = "Clear the SPI0 reset."]
            #[inline(always)]
            pub fn clear_the_spi0_reset(self) -> &'a mut W {
                self.variant(SPI0_RST_NW::CLEAR_THE_SPI0_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1_RST_N`"]
        pub enum SPI1_RST_NW {
            #[doc = "Assert the SPI1 reset."]
            ASSERT_THE_SPI1_RESE,
            #[doc = "Clear the SPI1 reset."]
            CLEAR_THE_SPI1_RESET,
        }
        impl SPI1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI1_RST_NW::ASSERT_THE_SPI1_RESE => false,
                    SPI1_RST_NW::CLEAR_THE_SPI1_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SPI1 reset."]
            #[inline(always)]
            pub fn assert_the_spi1_rese(self) -> &'a mut W {
                self.variant(SPI1_RST_NW::ASSERT_THE_SPI1_RESE)
            }
            #[doc = "Clear the SPI1 reset."]
            #[inline(always)]
            pub fn clear_the_spi1_reset(self) -> &'a mut W {
                self.variant(SPI1_RST_NW::CLEAR_THE_SPI1_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UARTFRG_RST_N`"]
        pub enum UARTFRG_RST_NW {
            #[doc = "Assert the UARTFRG reset."]
            ASSERT_THE_UARTFRG_R,
            #[doc = "Clear the UARTFRG reset."]
            CLEAR_THE_UARTFRG_RE,
        }
        impl UARTFRG_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UARTFRG_RST_NW::ASSERT_THE_UARTFRG_R => false,
                    UARTFRG_RST_NW::CLEAR_THE_UARTFRG_RE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UARTFRG_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UARTFRG_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UARTFRG_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the UARTFRG reset."]
            #[inline(always)]
            pub fn assert_the_uartfrg_r(self) -> &'a mut W {
                self.variant(UARTFRG_RST_NW::ASSERT_THE_UARTFRG_R)
            }
            #[doc = "Clear the UARTFRG reset."]
            #[inline(always)]
            pub fn clear_the_uartfrg_re(self) -> &'a mut W {
                self.variant(UARTFRG_RST_NW::CLEAR_THE_UARTFRG_RE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USART0_RST_N`"]
        pub enum USART0_RST_NW {
            #[doc = "Assert the USART0 reset."]
            ASSERT_THE_USART0_RE,
            #[doc = "Clear the USART0 reset."]
            CLEAR_THE_USART0_RES,
        }
        impl USART0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    USART0_RST_NW::ASSERT_THE_USART0_RE => false,
                    USART0_RST_NW::CLEAR_THE_USART0_RES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USART0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USART0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: USART0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the USART0 reset."]
            #[inline(always)]
            pub fn assert_the_usart0_re(self) -> &'a mut W {
                self.variant(USART0_RST_NW::ASSERT_THE_USART0_RE)
            }
            #[doc = "Clear the USART0 reset."]
            #[inline(always)]
            pub fn clear_the_usart0_res(self) -> &'a mut W {
                self.variant(USART0_RST_NW::CLEAR_THE_USART0_RES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART1_RST_N`"]
        pub enum UART1_RST_NW {
            #[doc = "Assert the UART reset."]
            ASSERT_THE_UART_RESE,
            #[doc = "Clear the UART1 reset."]
            CLEAR_THE_UART1_RESE,
        }
        impl UART1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART1_RST_NW::ASSERT_THE_UART_RESE => false,
                    UART1_RST_NW::CLEAR_THE_UART1_RESE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the UART reset."]
            #[inline(always)]
            pub fn assert_the_uart_rese(self) -> &'a mut W {
                self.variant(UART1_RST_NW::ASSERT_THE_UART_RESE)
            }
            #[doc = "Clear the UART1 reset."]
            #[inline(always)]
            pub fn clear_the_uart1_rese(self) -> &'a mut W {
                self.variant(UART1_RST_NW::CLEAR_THE_UART1_RESE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART2_RST_N`"]
        pub enum UART2_RST_NW {
            #[doc = "Assert the UART2 reset."]
            ASSERT_THE_UART2_RES,
            #[doc = "Clear the UART2 reset."]
            CLEAR_THE_UART2_RESE,
        }
        impl UART2_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART2_RST_NW::ASSERT_THE_UART2_RES => false,
                    UART2_RST_NW::CLEAR_THE_UART2_RESE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART2_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the UART2 reset."]
            #[inline(always)]
            pub fn assert_the_uart2_res(self) -> &'a mut W {
                self.variant(UART2_RST_NW::ASSERT_THE_UART2_RES)
            }
            #[doc = "Clear the UART2 reset."]
            #[inline(always)]
            pub fn clear_the_uart2_rese(self) -> &'a mut W {
                self.variant(UART2_RST_NW::CLEAR_THE_UART2_RESE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C_RST_N`"]
        pub enum I2C_RST_NW {
            #[doc = "Assert the I2C reset."]
            ASSERT_THE_I2C_RESET,
            #[doc = "Clear the I2C reset."]
            CLEAR_THE_I2C_RESET_,
        }
        impl I2C_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C_RST_NW::ASSERT_THE_I2C_RESET => false,
                    I2C_RST_NW::CLEAR_THE_I2C_RESET_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2C_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the I2C reset."]
            #[inline(always)]
            pub fn assert_the_i2c_reset(self) -> &'a mut W {
                self.variant(I2C_RST_NW::ASSERT_THE_I2C_RESET)
            }
            #[doc = "Clear the I2C reset."]
            #[inline(always)]
            pub fn clear_the_i2c_reset_(self) -> &'a mut W {
                self.variant(I2C_RST_NW::CLEAR_THE_I2C_RESET_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MRT_RST_N`"]
        pub enum MRT_RST_NW {
            #[doc = "Assert the MRT reset."]
            ASSERT_THE_MRT_RESET,
            #[doc = "Clear the MRT reset."]
            CLEAR_THE_MRT_RESET_,
        }
        impl MRT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MRT_RST_NW::ASSERT_THE_MRT_RESET => false,
                    MRT_RST_NW::CLEAR_THE_MRT_RESET_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MRT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MRT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MRT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the MRT reset."]
            #[inline(always)]
            pub fn assert_the_mrt_reset(self) -> &'a mut W {
                self.variant(MRT_RST_NW::ASSERT_THE_MRT_RESET)
            }
            #[doc = "Clear the MRT reset."]
            #[inline(always)]
            pub fn clear_the_mrt_reset_(self) -> &'a mut W {
                self.variant(MRT_RST_NW::CLEAR_THE_MRT_RESET_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCT_RST_N`"]
        pub enum SCT_RST_NW {
            #[doc = "Assert the SCT reset."]
            ASSERT_THE_SCT_RESET,
            #[doc = "Clear the SCT reset."]
            CLEAR_THE_SCT_RESET_,
        }
        impl SCT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCT_RST_NW::ASSERT_THE_SCT_RESET => false,
                    SCT_RST_NW::CLEAR_THE_SCT_RESET_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the SCT reset."]
            #[inline(always)]
            pub fn assert_the_sct_reset(self) -> &'a mut W {
                self.variant(SCT_RST_NW::ASSERT_THE_SCT_RESET)
            }
            #[doc = "Clear the SCT reset."]
            #[inline(always)]
            pub fn clear_the_sct_reset_(self) -> &'a mut W {
                self.variant(SCT_RST_NW::CLEAR_THE_SCT_RESET_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT_RST_N`"]
        pub enum WKT_RST_NW {
            #[doc = "Assert the WKT reset."]
            ASSERT_THE_WKT_RESET,
            #[doc = "Clear the WKT reset."]
            CLEAR_THE_WKT_RESET_,
        }
        impl WKT_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKT_RST_NW::ASSERT_THE_WKT_RESET => false,
                    WKT_RST_NW::CLEAR_THE_WKT_RESET_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKT_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKT_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WKT_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the WKT reset."]
            #[inline(always)]
            pub fn assert_the_wkt_reset(self) -> &'a mut W {
                self.variant(WKT_RST_NW::ASSERT_THE_WKT_RESET)
            }
            #[doc = "Clear the WKT reset."]
            #[inline(always)]
            pub fn clear_the_wkt_reset_(self) -> &'a mut W {
                self.variant(WKT_RST_NW::CLEAR_THE_WKT_RESET_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GPIO_RST_N`"]
        pub enum GPIO_RST_NW {
            #[doc = "Assert the GPIO reset."]
            ASSERT_THE_GPIO_RESE,
            #[doc = "Clear the GPIO reset."]
            CLEAR_THE_GPIO_RESET,
        }
        impl GPIO_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GPIO_RST_NW::ASSERT_THE_GPIO_RESE => false,
                    GPIO_RST_NW::CLEAR_THE_GPIO_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIO_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIO_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GPIO_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the GPIO reset."]
            #[inline(always)]
            pub fn assert_the_gpio_rese(self) -> &'a mut W {
                self.variant(GPIO_RST_NW::ASSERT_THE_GPIO_RESE)
            }
            #[doc = "Clear the GPIO reset."]
            #[inline(always)]
            pub fn clear_the_gpio_reset(self) -> &'a mut W {
                self.variant(GPIO_RST_NW::CLEAR_THE_GPIO_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_RST_N`"]
        pub enum FLASH_RST_NW {
            #[doc = "Assert the flash controller reset."]
            ASSERT_THE_FLASH_CON,
            #[doc = "Clear the flash controller reset."]
            CLEAR_THE_FLASH_CONT,
        }
        impl FLASH_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_RST_NW::ASSERT_THE_FLASH_CON => false,
                    FLASH_RST_NW::CLEAR_THE_FLASH_CONT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASH_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the flash controller reset."]
            #[inline(always)]
            pub fn assert_the_flash_con(self) -> &'a mut W {
                self.variant(FLASH_RST_NW::ASSERT_THE_FLASH_CON)
            }
            #[doc = "Clear the flash controller reset."]
            #[inline(always)]
            pub fn clear_the_flash_cont(self) -> &'a mut W {
                self.variant(FLASH_RST_NW::CLEAR_THE_FLASH_CONT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP_RST_N`"]
        pub enum ACMP_RST_NW {
            #[doc = "Assert the analog comparator reset."]
            ASSERT_THE_ANALOG_CO,
            #[doc = "Clear the analog comparator controller reset."]
            CLEAR_THE_ANALOG_COM,
        }
        impl ACMP_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMP_RST_NW::ASSERT_THE_ANALOG_CO => false,
                    ACMP_RST_NW::CLEAR_THE_ANALOG_COM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMP_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMP_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMP_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Assert the analog comparator reset."]
            #[inline(always)]
            pub fn assert_the_analog_co(self) -> &'a mut W {
                self.variant(ACMP_RST_NW::ASSERT_THE_ANALOG_CO)
            }
            #[doc = "Clear the analog comparator controller reset."]
            #[inline(always)]
            pub fn clear_the_analog_com(self) -> &'a mut W {
                self.variant(ACMP_RST_NW::CLEAR_THE_ANALOG_COM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI0 reset control"]
            #[inline(always)]
            pub fn spi0_rst_n(&self) -> SPI0_RST_NR {
                SPI0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SPI1 reset control"]
            #[inline(always)]
            pub fn spi1_rst_n(&self) -> SPI1_RST_NR {
                SPI1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - UART fractional baud rate generator (UARTFRG) reset control"]
            #[inline(always)]
            pub fn uartfrg_rst_n(&self) -> UARTFRG_RST_NR {
                UARTFRG_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - USART0 reset control"]
            #[inline(always)]
            pub fn usart0_rst_n(&self) -> USART0_RST_NR {
                USART0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - U1ART1 reset control"]
            #[inline(always)]
            pub fn uart1_rst_n(&self) -> UART1_RST_NR {
                UART1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - UART2 reset control"]
            #[inline(always)]
            pub fn uart2_rst_n(&self) -> UART2_RST_NR {
                UART2_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - I2C reset control"]
            #[inline(always)]
            pub fn i2c_rst_n(&self) -> I2C_RST_NR {
                I2C_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Multi-rate timer (MRT) reset control"]
            #[inline(always)]
            pub fn mrt_rst_n(&self) -> MRT_RST_NR {
                MRT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - SCT reset control"]
            #[inline(always)]
            pub fn sct_rst_n(&self) -> SCT_RST_NR {
                SCT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Self wake-up timer (WKT) reset control"]
            #[inline(always)]
            pub fn wkt_rst_n(&self) -> WKT_RST_NR {
                WKT_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - GPIO and GPIO pin interrupt reset control"]
            #[inline(always)]
            pub fn gpio_rst_n(&self) -> GPIO_RST_NR {
                GPIO_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Flash controller reset control"]
            #[inline(always)]
            pub fn flash_rst_n(&self) -> FLASH_RST_NR {
                FLASH_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Analog comparator reset control"]
            #[inline(always)]
            pub fn acmp_rst_n(&self) -> ACMP_RST_NR {
                ACMP_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 8191 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI0 reset control"]
            #[inline(always)]
            pub fn spi0_rst_n(&mut self) -> _SPI0_RST_NW {
                _SPI0_RST_NW { w: self }
            }
            #[doc = "Bit 1 - SPI1 reset control"]
            #[inline(always)]
            pub fn spi1_rst_n(&mut self) -> _SPI1_RST_NW {
                _SPI1_RST_NW { w: self }
            }
            #[doc = "Bit 2 - UART fractional baud rate generator (UARTFRG) reset control"]
            #[inline(always)]
            pub fn uartfrg_rst_n(&mut self) -> _UARTFRG_RST_NW {
                _UARTFRG_RST_NW { w: self }
            }
            #[doc = "Bit 3 - USART0 reset control"]
            #[inline(always)]
            pub fn usart0_rst_n(&mut self) -> _USART0_RST_NW {
                _USART0_RST_NW { w: self }
            }
            #[doc = "Bit 4 - U1ART1 reset control"]
            #[inline(always)]
            pub fn uart1_rst_n(&mut self) -> _UART1_RST_NW {
                _UART1_RST_NW { w: self }
            }
            #[doc = "Bit 5 - UART2 reset control"]
            #[inline(always)]
            pub fn uart2_rst_n(&mut self) -> _UART2_RST_NW {
                _UART2_RST_NW { w: self }
            }
            #[doc = "Bit 6 - I2C reset control"]
            #[inline(always)]
            pub fn i2c_rst_n(&mut self) -> _I2C_RST_NW {
                _I2C_RST_NW { w: self }
            }
            #[doc = "Bit 7 - Multi-rate timer (MRT) reset control"]
            #[inline(always)]
            pub fn mrt_rst_n(&mut self) -> _MRT_RST_NW {
                _MRT_RST_NW { w: self }
            }
            #[doc = "Bit 8 - SCT reset control"]
            #[inline(always)]
            pub fn sct_rst_n(&mut self) -> _SCT_RST_NW {
                _SCT_RST_NW { w: self }
            }
            #[doc = "Bit 9 - Self wake-up timer (WKT) reset control"]
            #[inline(always)]
            pub fn wkt_rst_n(&mut self) -> _WKT_RST_NW {
                _WKT_RST_NW { w: self }
            }
            #[doc = "Bit 10 - GPIO and GPIO pin interrupt reset control"]
            #[inline(always)]
            pub fn gpio_rst_n(&mut self) -> _GPIO_RST_NW {
                _GPIO_RST_NW { w: self }
            }
            #[doc = "Bit 11 - Flash controller reset control"]
            #[inline(always)]
            pub fn flash_rst_n(&mut self) -> _FLASH_RST_NW {
                _FLASH_RST_NW { w: self }
            }
            #[doc = "Bit 12 - Analog comparator reset control"]
            #[inline(always)]
            pub fn acmp_rst_n(&mut self) -> _ACMP_RST_NW {
                _ACMP_RST_NW { w: self }
            }
        }
    }
    #[doc = "System PLL control"]
    pub struct SYSPLLCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "System PLL control"]
    pub mod syspllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSELR {
            bits: u8,
        }
        impl MSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::P_EQ_1 => 0,
                    PSELR::P_EQ_2 => 1,
                    PSELR::P_EQ_4 => 2,
                    PSELR::P_EQ_8 => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::P_EQ_1,
                    1 => PSELR::P_EQ_2,
                    2 => PSELR::P_EQ_4,
                    3 => PSELR::P_EQ_8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `P_EQ_1`"]
            #[inline(always)]
            pub fn is_p_eq_1(&self) -> bool {
                *self == PSELR::P_EQ_1
            }
            #[doc = "Checks if the value of the field is `P_EQ_2`"]
            #[inline(always)]
            pub fn is_p_eq_2(&self) -> bool {
                *self == PSELR::P_EQ_2
            }
            #[doc = "Checks if the value of the field is `P_EQ_4`"]
            #[inline(always)]
            pub fn is_p_eq_4(&self) -> bool {
                *self == PSELR::P_EQ_4
            }
            #[doc = "Checks if the value of the field is `P_EQ_8`"]
            #[inline(always)]
            pub fn is_p_eq_8(&self) -> bool {
                *self == PSELR::P_EQ_8
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::P_EQ_1 => 0,
                    PSELW::P_EQ_2 => 1,
                    PSELW::P_EQ_4 => 2,
                    PSELW::P_EQ_8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "P = 1"]
            #[inline(always)]
            pub fn p_eq_1(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_1)
            }
            #[doc = "P = 2"]
            #[inline(always)]
            pub fn p_eq_2(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_2)
            }
            #[doc = "P = 4"]
            #[inline(always)]
            pub fn p_eq_4(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_4)
            }
            #[doc = "P = 8"]
            #[inline(always)]
            pub fn p_eq_8(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32"]
            #[inline(always)]
            pub fn msel(&self) -> MSELR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MSELR { bits }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline(always)]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32"]
            #[inline(always)]
            pub fn msel(&mut self) -> _MSELW {
                _MSELW { w: self }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline(always)]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
        }
    }
    #[doc = "System PLL status"]
    pub struct SYSPLLSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "System PLL status"]
    pub mod syspllstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SYSPLLSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `LOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKR {
            #[doc = "PLL not locked"]
            PLL_NOT_LOCKED,
            #[doc = "PLL locked"]
            PLL_LOCKED,
        }
        impl LOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKR::PLL_NOT_LOCKED => false,
                    LOCKR::PLL_LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOCKR {
                match value {
                    false => LOCKR::PLL_NOT_LOCKED,
                    true => LOCKR::PLL_LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `PLL_NOT_LOCKED`"]
            #[inline(always)]
            pub fn is_pll_not_locked(&self) -> bool {
                *self == LOCKR::PLL_NOT_LOCKED
            }
            #[doc = "Checks if the value of the field is `PLL_LOCKED`"]
            #[inline(always)]
            pub fn is_pll_locked(&self) -> bool {
                *self == LOCKR::PLL_LOCKED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PLL lock status"]
            #[inline(always)]
            pub fn lock(&self) -> LOCKR {
                LOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "System oscillator control"]
    pub struct SYSOSCCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "System oscillator control"]
    pub mod sysoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BYPASS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYPASSR {
            #[doc = "Disabled. Oscillator is not bypassed."]
            DISABLED_OSCILLATOR,
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            ENABLED_PLL_INPUT_,
        }
        impl BYPASSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BYPASSR::DISABLED_OSCILLATOR => false,
                    BYPASSR::ENABLED_PLL_INPUT_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BYPASSR {
                match value {
                    false => BYPASSR::DISABLED_OSCILLATOR,
                    true => BYPASSR::ENABLED_PLL_INPUT_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_OSCILLATOR`"]
            #[inline(always)]
            pub fn is_disabled_oscillator(&self) -> bool {
                *self == BYPASSR::DISABLED_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `ENABLED_PLL_INPUT_`"]
            #[inline(always)]
            pub fn is_enabled_pll_input_(&self) -> bool {
                *self == BYPASSR::ENABLED_PLL_INPUT_
            }
        }
        #[doc = "Possible values of the field `FREQRANGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQRANGER {
            #[doc = "1 - 20 MHz frequency range."]
            _1_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_25_MHZ_FREQUENC,
        }
        impl FREQRANGER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FREQRANGER::_1_20_MHZ_FREQUENCY => false,
                    FREQRANGER::_15_25_MHZ_FREQUENC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FREQRANGER {
                match value {
                    false => FREQRANGER::_1_20_MHZ_FREQUENCY,
                    true => FREQRANGER::_15_25_MHZ_FREQUENC,
                }
            }
            #[doc = "Checks if the value of the field is `_1_20_MHZ_FREQUENCY`"]
            #[inline(always)]
            pub fn is_1_20_mhz_frequency(&self) -> bool {
                *self == FREQRANGER::_1_20_MHZ_FREQUENCY
            }
            #[doc = "Checks if the value of the field is `_15_25_MHZ_FREQUENC`"]
            #[inline(always)]
            pub fn is_15_25_mhz_frequenc(&self) -> bool {
                *self == FREQRANGER::_15_25_MHZ_FREQUENC
            }
        }
        #[doc = "Values that can be written to the field `BYPASS`"]
        pub enum BYPASSW {
            #[doc = "Disabled. Oscillator is not bypassed."]
            DISABLED_OSCILLATOR,
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            ENABLED_PLL_INPUT_,
        }
        impl BYPASSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BYPASSW::DISABLED_OSCILLATOR => false,
                    BYPASSW::ENABLED_PLL_INPUT_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BYPASSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Oscillator is not bypassed."]
            #[inline(always)]
            pub fn disabled_oscillator(self) -> &'a mut W {
                self.variant(BYPASSW::DISABLED_OSCILLATOR)
            }
            #[doc = "Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator."]
            #[inline(always)]
            pub fn enabled_pll_input_(self) -> &'a mut W {
                self.variant(BYPASSW::ENABLED_PLL_INPUT_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQRANGE`"]
        pub enum FREQRANGEW {
            #[doc = "1 - 20 MHz frequency range."]
            _1_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_25_MHZ_FREQUENC,
        }
        impl FREQRANGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FREQRANGEW::_1_20_MHZ_FREQUENCY => false,
                    FREQRANGEW::_15_25_MHZ_FREQUENC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQRANGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FREQRANGEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 - 20 MHz frequency range."]
            #[inline(always)]
            pub fn _1_20_mhz_frequency(self) -> &'a mut W {
                self.variant(FREQRANGEW::_1_20_MHZ_FREQUENCY)
            }
            #[doc = "15 - 25 MHz frequency range"]
            #[inline(always)]
            pub fn _15_25_mhz_frequenc(self) -> &'a mut W {
                self.variant(FREQRANGEW::_15_25_MHZ_FREQUENC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline(always)]
            pub fn bypass(&self) -> BYPASSR {
                BYPASSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Determines frequency range for Low-power oscillator."]
            #[inline(always)]
            pub fn freqrange(&self) -> FREQRANGER {
                FREQRANGER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline(always)]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 1 - Determines frequency range for Low-power oscillator."]
            #[inline(always)]
            pub fn freqrange(&mut self) -> _FREQRANGEW {
                _FREQRANGEW { w: self }
            }
        }
    }
    #[doc = "Watchdog oscillator control"]
    pub struct WDTOSCCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog oscillator control"]
    pub mod wdtoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVSELR {
            bits: u8,
        }
        impl DIVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `FREQSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQSELR {
            #[doc = "0.6 MHz"]
            _0_6_MHZ,
            #[doc = "1.05 MHz"]
            _1_05_MHZ,
            #[doc = "1.4 MHz"]
            _1_4_MHZ,
            #[doc = "1.75 MHz"]
            _1_75_MHZ,
            #[doc = "2.1 MHz"]
            _2_1_MHZ,
            #[doc = "2.4 MHz"]
            _2_4_MHZ,
            #[doc = "2.7 MHz"]
            _2_7_MHZ,
            #[doc = "3.0 MHz"]
            _3_0_MHZ,
            #[doc = "3.25 MHz"]
            _3_25_MHZ,
            #[doc = "3.5 MHz"]
            _3_5_MHZ,
            #[doc = "3.75 MHz"]
            _3_75_MHZ,
            #[doc = "4.0 MHz"]
            _4_0_MHZ,
            #[doc = "4.2 MHz"]
            _4_2_MHZ,
            #[doc = "4.4 MHz"]
            _4_4_MHZ,
            #[doc = "4.6 MHz"]
            _4_6_MHZ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FREQSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    FREQSELR::_0_6_MHZ => 1,
                    FREQSELR::_1_05_MHZ => 2,
                    FREQSELR::_1_4_MHZ => 3,
                    FREQSELR::_1_75_MHZ => 4,
                    FREQSELR::_2_1_MHZ => 5,
                    FREQSELR::_2_4_MHZ => 6,
                    FREQSELR::_2_7_MHZ => 7,
                    FREQSELR::_3_0_MHZ => 8,
                    FREQSELR::_3_25_MHZ => 9,
                    FREQSELR::_3_5_MHZ => 10,
                    FREQSELR::_3_75_MHZ => 11,
                    FREQSELR::_4_0_MHZ => 12,
                    FREQSELR::_4_2_MHZ => 13,
                    FREQSELR::_4_4_MHZ => 14,
                    FREQSELR::_4_6_MHZ => 15,
                    FREQSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> FREQSELR {
                match value {
                    1 => FREQSELR::_0_6_MHZ,
                    2 => FREQSELR::_1_05_MHZ,
                    3 => FREQSELR::_1_4_MHZ,
                    4 => FREQSELR::_1_75_MHZ,
                    5 => FREQSELR::_2_1_MHZ,
                    6 => FREQSELR::_2_4_MHZ,
                    7 => FREQSELR::_2_7_MHZ,
                    8 => FREQSELR::_3_0_MHZ,
                    9 => FREQSELR::_3_25_MHZ,
                    10 => FREQSELR::_3_5_MHZ,
                    11 => FREQSELR::_3_75_MHZ,
                    12 => FREQSELR::_4_0_MHZ,
                    13 => FREQSELR::_4_2_MHZ,
                    14 => FREQSELR::_4_4_MHZ,
                    15 => FREQSELR::_4_6_MHZ,
                    i => FREQSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0_6_MHZ`"]
            #[inline(always)]
            pub fn is_0_6_mhz(&self) -> bool {
                *self == FREQSELR::_0_6_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_05_MHZ`"]
            #[inline(always)]
            pub fn is_1_05_mhz(&self) -> bool {
                *self == FREQSELR::_1_05_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_4_MHZ`"]
            #[inline(always)]
            pub fn is_1_4_mhz(&self) -> bool {
                *self == FREQSELR::_1_4_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_75_MHZ`"]
            #[inline(always)]
            pub fn is_1_75_mhz(&self) -> bool {
                *self == FREQSELR::_1_75_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_1_MHZ`"]
            #[inline(always)]
            pub fn is_2_1_mhz(&self) -> bool {
                *self == FREQSELR::_2_1_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_4_MHZ`"]
            #[inline(always)]
            pub fn is_2_4_mhz(&self) -> bool {
                *self == FREQSELR::_2_4_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_7_MHZ`"]
            #[inline(always)]
            pub fn is_2_7_mhz(&self) -> bool {
                *self == FREQSELR::_2_7_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_0_MHZ`"]
            #[inline(always)]
            pub fn is_3_0_mhz(&self) -> bool {
                *self == FREQSELR::_3_0_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_25_MHZ`"]
            #[inline(always)]
            pub fn is_3_25_mhz(&self) -> bool {
                *self == FREQSELR::_3_25_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_5_MHZ`"]
            #[inline(always)]
            pub fn is_3_5_mhz(&self) -> bool {
                *self == FREQSELR::_3_5_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_75_MHZ`"]
            #[inline(always)]
            pub fn is_3_75_mhz(&self) -> bool {
                *self == FREQSELR::_3_75_MHZ
            }
            #[doc = "Checks if the value of the field is `_4_0_MHZ`"]
            #[inline(always)]
            pub fn is_4_0_mhz(&self) -> bool {
                *self == FREQSELR::_4_0_MHZ
            }
            #[doc = "Checks if the value of the field is `_4_2_MHZ`"]
            #[inline(always)]
            pub fn is_4_2_mhz(&self) -> bool {
                *self == FREQSELR::_4_2_MHZ
            }
            #[doc = "Checks if the value of the field is `_4_4_MHZ`"]
            #[inline(always)]
            pub fn is_4_4_mhz(&self) -> bool {
                *self == FREQSELR::_4_4_MHZ
            }
            #[doc = "Checks if the value of the field is `_4_6_MHZ`"]
            #[inline(always)]
            pub fn is_4_6_mhz(&self) -> bool {
                *self == FREQSELR::_4_6_MHZ
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQSEL`"]
        pub enum FREQSELW {
            #[doc = "0.6 MHz"]
            _0_6_MHZ,
            #[doc = "1.05 MHz"]
            _1_05_MHZ,
            #[doc = "1.4 MHz"]
            _1_4_MHZ,
            #[doc = "1.75 MHz"]
            _1_75_MHZ,
            #[doc = "2.1 MHz"]
            _2_1_MHZ,
            #[doc = "2.4 MHz"]
            _2_4_MHZ,
            #[doc = "2.7 MHz"]
            _2_7_MHZ,
            #[doc = "3.0 MHz"]
            _3_0_MHZ,
            #[doc = "3.25 MHz"]
            _3_25_MHZ,
            #[doc = "3.5 MHz"]
            _3_5_MHZ,
            #[doc = "3.75 MHz"]
            _3_75_MHZ,
            #[doc = "4.0 MHz"]
            _4_0_MHZ,
            #[doc = "4.2 MHz"]
            _4_2_MHZ,
            #[doc = "4.4 MHz"]
            _4_4_MHZ,
            #[doc = "4.6 MHz"]
            _4_6_MHZ,
        }
        impl FREQSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FREQSELW::_0_6_MHZ => 1,
                    FREQSELW::_1_05_MHZ => 2,
                    FREQSELW::_1_4_MHZ => 3,
                    FREQSELW::_1_75_MHZ => 4,
                    FREQSELW::_2_1_MHZ => 5,
                    FREQSELW::_2_4_MHZ => 6,
                    FREQSELW::_2_7_MHZ => 7,
                    FREQSELW::_3_0_MHZ => 8,
                    FREQSELW::_3_25_MHZ => 9,
                    FREQSELW::_3_5_MHZ => 10,
                    FREQSELW::_3_75_MHZ => 11,
                    FREQSELW::_4_0_MHZ => 12,
                    FREQSELW::_4_2_MHZ => 13,
                    FREQSELW::_4_4_MHZ => 14,
                    FREQSELW::_4_6_MHZ => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FREQSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "0.6 MHz"]
            #[inline(always)]
            pub fn _0_6_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_0_6_MHZ)
            }
            #[doc = "1.05 MHz"]
            #[inline(always)]
            pub fn _1_05_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_05_MHZ)
            }
            #[doc = "1.4 MHz"]
            #[inline(always)]
            pub fn _1_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_4_MHZ)
            }
            #[doc = "1.75 MHz"]
            #[inline(always)]
            pub fn _1_75_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_75_MHZ)
            }
            #[doc = "2.1 MHz"]
            #[inline(always)]
            pub fn _2_1_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_1_MHZ)
            }
            #[doc = "2.4 MHz"]
            #[inline(always)]
            pub fn _2_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_4_MHZ)
            }
            #[doc = "2.7 MHz"]
            #[inline(always)]
            pub fn _2_7_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_7_MHZ)
            }
            #[doc = "3.0 MHz"]
            #[inline(always)]
            pub fn _3_0_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_0_MHZ)
            }
            #[doc = "3.25 MHz"]
            #[inline(always)]
            pub fn _3_25_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_25_MHZ)
            }
            #[doc = "3.5 MHz"]
            #[inline(always)]
            pub fn _3_5_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_5_MHZ)
            }
            #[doc = "3.75 MHz"]
            #[inline(always)]
            pub fn _3_75_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_75_MHZ)
            }
            #[doc = "4.0 MHz"]
            #[inline(always)]
            pub fn _4_0_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_4_0_MHZ)
            }
            #[doc = "4.2 MHz"]
            #[inline(always)]
            pub fn _4_2_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_4_2_MHZ)
            }
            #[doc = "4.4 MHz"]
            #[inline(always)]
            pub fn _4_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_4_4_MHZ)
            }
            #[doc = "4.6 MHz"]
            #[inline(always)]
            pub fn _4_6_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_4_6_MHZ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline(always)]
            pub fn divsel(&self) -> DIVSELR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVSELR { bits }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline(always)]
            pub fn freqsel(&self) -> FREQSELR {
                FREQSELR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 160 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline(always)]
            pub fn divsel(&mut self) -> _DIVSELW {
                _DIVSELW { w: self }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline(always)]
            pub fn freqsel(&mut self) -> _FREQSELW {
                _FREQSELW { w: self }
            }
        }
    }
    #[doc = "System reset status register"]
    pub struct SYSRSTSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "System reset status register"]
    pub mod sysrststat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSRSTSTAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORR {
            #[doc = "No POR detected"]
            NO_POR_DETECTED,
            #[doc = "POR detected. Writing a one clears this reset."]
            POR_DETECTED_WRITIN,
        }
        impl PORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PORR::NO_POR_DETECTED => false,
                    PORR::POR_DETECTED_WRITIN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PORR {
                match value {
                    false => PORR::NO_POR_DETECTED,
                    true => PORR::POR_DETECTED_WRITIN,
                }
            }
            #[doc = "Checks if the value of the field is `NO_POR_DETECTED`"]
            #[inline(always)]
            pub fn is_no_por_detected(&self) -> bool {
                *self == PORR::NO_POR_DETECTED
            }
            #[doc = "Checks if the value of the field is `POR_DETECTED_WRITIN`"]
            #[inline(always)]
            pub fn is_por_detected_writin(&self) -> bool {
                *self == PORR::POR_DETECTED_WRITIN
            }
        }
        #[doc = "Possible values of the field `EXTRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTRSTR {
            #[doc = "No reset event detected."]
            NO_RESET_EVENT_DETEC,
            #[doc = "Reset detected. Writing a one clears this reset."]
            RESET_DETECTED_WRIT,
        }
        impl EXTRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EXTRSTR::NO_RESET_EVENT_DETEC => false,
                    EXTRSTR::RESET_DETECTED_WRIT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EXTRSTR {
                match value {
                    false => EXTRSTR::NO_RESET_EVENT_DETEC,
                    true => EXTRSTR::RESET_DETECTED_WRIT,
                }
            }
            #[doc = "Checks if the value of the field is `NO_RESET_EVENT_DETEC`"]
            #[inline(always)]
            pub fn is_no_reset_event_detec(&self) -> bool {
                *self == EXTRSTR::NO_RESET_EVENT_DETEC
            }
            #[doc = "Checks if the value of the field is `RESET_DETECTED_WRIT`"]
            #[inline(always)]
            pub fn is_reset_detected_writ(&self) -> bool {
                *self == EXTRSTR::RESET_DETECTED_WRIT
            }
        }
        #[doc = "Possible values of the field `WDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTR {
            #[doc = "No WDT reset detected"]
            NO_WDT_RESET_DETECTE,
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            WDT_RESET_DETECTED_,
        }
        impl WDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTR::NO_WDT_RESET_DETECTE => false,
                    WDTR::WDT_RESET_DETECTED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTR {
                match value {
                    false => WDTR::NO_WDT_RESET_DETECTE,
                    true => WDTR::WDT_RESET_DETECTED_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_WDT_RESET_DETECTE`"]
            #[inline(always)]
            pub fn is_no_wdt_reset_detecte(&self) -> bool {
                *self == WDTR::NO_WDT_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `WDT_RESET_DETECTED_`"]
            #[inline(always)]
            pub fn is_wdt_reset_detected_(&self) -> bool {
                *self == WDTR::WDT_RESET_DETECTED_
            }
        }
        #[doc = "Possible values of the field `BOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODR {
            #[doc = "No BOD reset detected"]
            NO_BOD_RESET_DETECTE,
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            BOD_RESET_DETECTED_,
        }
        impl BODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BODR::NO_BOD_RESET_DETECTE => false,
                    BODR::BOD_RESET_DETECTED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BODR {
                match value {
                    false => BODR::NO_BOD_RESET_DETECTE,
                    true => BODR::BOD_RESET_DETECTED_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_BOD_RESET_DETECTE`"]
            #[inline(always)]
            pub fn is_no_bod_reset_detecte(&self) -> bool {
                *self == BODR::NO_BOD_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `BOD_RESET_DETECTED_`"]
            #[inline(always)]
            pub fn is_bod_reset_detected_(&self) -> bool {
                *self == BODR::BOD_RESET_DETECTED_
            }
        }
        #[doc = "Possible values of the field `SYSRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSRSTR {
            #[doc = "No System reset detected"]
            NO_SYSTEM_RESET_DETE,
            #[doc = "System reset detected. Writing a one clears this reset."]
            SYSTEM_RESET_DETECTE,
        }
        impl SYSRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSRSTR::NO_SYSTEM_RESET_DETE => false,
                    SYSRSTR::SYSTEM_RESET_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSRSTR {
                match value {
                    false => SYSRSTR::NO_SYSTEM_RESET_DETE,
                    true => SYSRSTR::SYSTEM_RESET_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_SYSTEM_RESET_DETE`"]
            #[inline(always)]
            pub fn is_no_system_reset_dete(&self) -> bool {
                *self == SYSRSTR::NO_SYSTEM_RESET_DETE
            }
            #[doc = "Checks if the value of the field is `SYSTEM_RESET_DETECTE`"]
            #[inline(always)]
            pub fn is_system_reset_detecte(&self) -> bool {
                *self == SYSRSTR::SYSTEM_RESET_DETECTE
            }
        }
        #[doc = "Values that can be written to the field `POR`"]
        pub enum PORW {
            #[doc = "No POR detected"]
            NO_POR_DETECTED,
            #[doc = "POR detected. Writing a one clears this reset."]
            POR_DETECTED_WRITIN,
        }
        impl PORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PORW::NO_POR_DETECTED => false,
                    PORW::POR_DETECTED_WRITIN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No POR detected"]
            #[inline(always)]
            pub fn no_por_detected(self) -> &'a mut W {
                self.variant(PORW::NO_POR_DETECTED)
            }
            #[doc = "POR detected. Writing a one clears this reset."]
            #[inline(always)]
            pub fn por_detected_writin(self) -> &'a mut W {
                self.variant(PORW::POR_DETECTED_WRITIN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EXTRST`"]
        pub enum EXTRSTW {
            #[doc = "No reset event detected."]
            NO_RESET_EVENT_DETEC,
            #[doc = "Reset detected. Writing a one clears this reset."]
            RESET_DETECTED_WRIT,
        }
        impl EXTRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    EXTRSTW::NO_RESET_EVENT_DETEC => false,
                    EXTRSTW::RESET_DETECTED_WRIT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EXTRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No reset event detected."]
            #[inline(always)]
            pub fn no_reset_event_detec(self) -> &'a mut W {
                self.variant(EXTRSTW::NO_RESET_EVENT_DETEC)
            }
            #[doc = "Reset detected. Writing a one clears this reset."]
            #[inline(always)]
            pub fn reset_detected_writ(self) -> &'a mut W {
                self.variant(EXTRSTW::RESET_DETECTED_WRIT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDT`"]
        pub enum WDTW {
            #[doc = "No WDT reset detected"]
            NO_WDT_RESET_DETECTE,
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            WDT_RESET_DETECTED_,
        }
        impl WDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTW::NO_WDT_RESET_DETECTE => false,
                    WDTW::WDT_RESET_DETECTED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No WDT reset detected"]
            #[inline(always)]
            pub fn no_wdt_reset_detecte(self) -> &'a mut W {
                self.variant(WDTW::NO_WDT_RESET_DETECTE)
            }
            #[doc = "WDT reset detected. Writing a one clears this reset."]
            #[inline(always)]
            pub fn wdt_reset_detected_(self) -> &'a mut W {
                self.variant(WDTW::WDT_RESET_DETECTED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD`"]
        pub enum BODW {
            #[doc = "No BOD reset detected"]
            NO_BOD_RESET_DETECTE,
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            BOD_RESET_DETECTED_,
        }
        impl BODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODW::NO_BOD_RESET_DETECTE => false,
                    BODW::BOD_RESET_DETECTED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No BOD reset detected"]
            #[inline(always)]
            pub fn no_bod_reset_detecte(self) -> &'a mut W {
                self.variant(BODW::NO_BOD_RESET_DETECTE)
            }
            #[doc = "BOD reset detected. Writing a one clears this reset."]
            #[inline(always)]
            pub fn bod_reset_detected_(self) -> &'a mut W {
                self.variant(BODW::BOD_RESET_DETECTED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSRST`"]
        pub enum SYSRSTW {
            #[doc = "No System reset detected"]
            NO_SYSTEM_RESET_DETE,
            #[doc = "System reset detected. Writing a one clears this reset."]
            SYSTEM_RESET_DETECTE,
        }
        impl SYSRSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSRSTW::NO_SYSTEM_RESET_DETE => false,
                    SYSRSTW::SYSTEM_RESET_DETECTE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSRSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSRSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSRSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No System reset detected"]
            #[inline(always)]
            pub fn no_system_reset_dete(self) -> &'a mut W {
                self.variant(SYSRSTW::NO_SYSTEM_RESET_DETE)
            }
            #[doc = "System reset detected. Writing a one clears this reset."]
            #[inline(always)]
            pub fn system_reset_detecte(self) -> &'a mut W {
                self.variant(SYSRSTW::SYSTEM_RESET_DETECTE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - POR reset status"]
            #[inline(always)]
            pub fn por(&self) -> PORR {
                PORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Status of the external RESET pin. External reset status."]
            #[inline(always)]
            pub fn extrst(&self) -> EXTRSTR {
                EXTRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Status of the Watchdog reset"]
            #[inline(always)]
            pub fn wdt(&self) -> WDTR {
                WDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Status of the Brown-out detect reset"]
            #[inline(always)]
            pub fn bod(&self) -> BODR {
                BODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Status of the software system reset"]
            #[inline(always)]
            pub fn sysrst(&self) -> SYSRSTR {
                SYSRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - POR reset status"]
            #[inline(always)]
            pub fn por(&mut self) -> _PORW {
                _PORW { w: self }
            }
            #[doc = "Bit 1 - Status of the external RESET pin. External reset status."]
            #[inline(always)]
            pub fn extrst(&mut self) -> _EXTRSTW {
                _EXTRSTW { w: self }
            }
            #[doc = "Bit 2 - Status of the Watchdog reset"]
            #[inline(always)]
            pub fn wdt(&mut self) -> _WDTW {
                _WDTW { w: self }
            }
            #[doc = "Bit 3 - Status of the Brown-out detect reset"]
            #[inline(always)]
            pub fn bod(&mut self) -> _BODW {
                _BODW { w: self }
            }
            #[doc = "Bit 4 - Status of the software system reset"]
            #[inline(always)]
            pub fn sysrst(&mut self) -> _SYSRSTW {
                _SYSRSTW { w: self }
            }
        }
    }
    #[doc = "System PLL clock source select"]
    pub struct SYSPLLCLKSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "System PLL clock source select"]
    pub mod syspllclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC"]
            IRC,
            #[doc = "Crystal Oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR_,
            #[doc = "Reserved."]
            RESERVED_,
            #[doc = "CLKIN. External clock input."]
            CLKIN_EXTERNAL_CLOC,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC => 0,
                    SELR::CRYSTAL_OSCILLATOR_ => 1,
                    SELR::RESERVED_ => 2,
                    SELR::CLKIN_EXTERNAL_CLOC => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC,
                    1 => SELR::CRYSTAL_OSCILLATOR_,
                    2 => SELR::RESERVED_,
                    3 => SELR::CLKIN_EXTERNAL_CLOC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC`"]
            #[inline(always)]
            pub fn is_irc(&self) -> bool {
                *self == SELR::IRC
            }
            #[doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR_`"]
            #[inline(always)]
            pub fn is_crystal_oscillator_(&self) -> bool {
                *self == SELR::CRYSTAL_OSCILLATOR_
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == SELR::RESERVED_
            }
            #[doc = "Checks if the value of the field is `CLKIN_EXTERNAL_CLOC`"]
            #[inline(always)]
            pub fn is_clkin_external_cloc(&self) -> bool {
                *self == SELR::CLKIN_EXTERNAL_CLOC
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC"]
            IRC,
            #[doc = "Crystal Oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR_,
            #[doc = "Reserved."]
            RESERVED_,
            #[doc = "CLKIN. External clock input."]
            CLKIN_EXTERNAL_CLOC,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC => 0,
                    SELW::CRYSTAL_OSCILLATOR_ => 1,
                    SELW::RESERVED_ => 2,
                    SELW::CLKIN_EXTERNAL_CLOC => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC"]
            #[inline(always)]
            pub fn irc(self) -> &'a mut W {
                self.variant(SELW::IRC)
            }
            #[doc = "Crystal Oscillator (SYSOSC)"]
            #[inline(always)]
            pub fn crystal_oscillator_(self) -> &'a mut W {
                self.variant(SELW::CRYSTAL_OSCILLATOR_)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(SELW::RESERVED_)
            }
            #[doc = "CLKIN. External clock input."]
            #[inline(always)]
            pub fn clkin_external_cloc(self) -> &'a mut W {
                self.variant(SELW::CLKIN_EXTERNAL_CLOC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline(always)]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline(always)]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "System PLL clock source update enable"]
    pub struct SYSPLLCLKUEN {
        register: VolatileCell<u32>,
    }
    #[doc = "System PLL clock source update enable"]
    pub mod syspllclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline(always)]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline(always)]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline(always)]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline(always)]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "Main clock source select"]
    pub struct MAINCLKSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Main clock source select"]
    pub mod mainclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC Oscillator"]
            IRC_OSCILLATOR,
            #[doc = "PLL input"]
            PLL_INPUT,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "PLL output"]
            PLL_OUTPUT,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::PLL_INPUT => 1,
                    SELR::WATCHDOG_OSCILLATOR => 2,
                    SELR::PLL_OUTPUT => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::PLL_INPUT,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    3 => SELR::PLL_OUTPUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline(always)]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `PLL_INPUT`"]
            #[inline(always)]
            pub fn is_pll_input(&self) -> bool {
                *self == SELR::PLL_INPUT
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline(always)]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `PLL_OUTPUT`"]
            #[inline(always)]
            pub fn is_pll_output(&self) -> bool {
                *self == SELR::PLL_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC Oscillator"]
            IRC_OSCILLATOR,
            #[doc = "PLL input"]
            PLL_INPUT,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "PLL output"]
            PLL_OUTPUT,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::PLL_INPUT => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                    SELW::PLL_OUTPUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC Oscillator"]
            #[inline(always)]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "PLL input"]
            #[inline(always)]
            pub fn pll_input(self) -> &'a mut W {
                self.variant(SELW::PLL_INPUT)
            }
            #[doc = "Watchdog oscillator"]
            #[inline(always)]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = "PLL output"]
            #[inline(always)]
            pub fn pll_output(self) -> &'a mut W {
                self.variant(SELW::PLL_OUTPUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline(always)]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline(always)]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "Main clock source update enable"]
    pub struct MAINCLKUEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Main clock source update enable"]
    pub mod mainclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline(always)]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline(always)]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline(always)]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline(always)]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "System clock divider"]
    pub struct SYSAHBCLKDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "System clock divider"]
    pub mod sysahbclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "System clock control"]
    pub struct SYSAHBCLKCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "System clock control"]
    pub mod sysahbclkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSR {
            #[doc = "Enable"]
            ENABLE,
        }
        impl SYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSR {
                match value {
                    true => SYSR::ENABLE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ROM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ROMR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ROMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ROMR::DISABLE => false,
                    ROMR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ROMR {
                match value {
                    false => ROMR::DISABLE,
                    true => ROMR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ROMR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ROMR::ENABLE
            }
        }
        #[doc = "Possible values of the field `RAM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl RAMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMR::DISABLE => false,
                    RAMR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RAMR {
                match value {
                    false => RAMR::DISABLE,
                    true => RAMR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == RAMR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == RAMR::ENABLE
            }
        }
        #[doc = "Possible values of the field `FLASHREG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHREGR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHREGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHREGR::DISABLE => false,
                    FLASHREGR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FLASHREGR {
                match value {
                    false => FLASHREGR::DISABLE,
                    true => FLASHREGR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == FLASHREGR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == FLASHREGR::ENABLE
            }
        }
        #[doc = "Possible values of the field `FLASH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHR::DISABLE => false,
                    FLASHR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FLASHR {
                match value {
                    false => FLASHR::DISABLE,
                    true => FLASHR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == FLASHR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == FLASHR::ENABLE
            }
        }
        #[doc = "Possible values of the field `I2C`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2CR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    I2CR::DISABLE => false,
                    I2CR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> I2CR {
                match value {
                    false => I2CR::DISABLE,
                    true => I2CR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == I2CR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == I2CR::ENABLE
            }
        }
        #[doc = "Possible values of the field `GPIO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GPIOR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl GPIOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    GPIOR::DISABLE => false,
                    GPIOR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> GPIOR {
                match value {
                    false => GPIOR::DISABLE,
                    true => GPIOR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == GPIOR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == GPIOR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SWM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWMR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SWMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SWMR::DISABLE => false,
                    SWMR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SWMR {
                match value {
                    false => SWMR::DISABLE,
                    true => SWMR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SWMR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SWMR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SCT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SCTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCTR::DISABLE => false,
                    SCTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCTR {
                match value {
                    false => SCTR::DISABLE,
                    true => SCTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SCTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SCTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `WKT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WKTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WKTR::DISABLE => false,
                    WKTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WKTR {
                match value {
                    false => WKTR::DISABLE,
                    true => WKTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == WKTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == WKTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `MRT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MRTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MRTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MRTR::DISABLE => false,
                    MRTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MRTR {
                match value {
                    false => MRTR::DISABLE,
                    true => MRTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == MRTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == MRTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `SPI0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI0R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI0R::DISABLE => false,
                    SPI0R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SPI0R {
                match value {
                    false => SPI0R::DISABLE,
                    true => SPI0R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SPI0R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SPI0R::ENABLE
            }
        }
        #[doc = "Possible values of the field `SPI1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPI1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SPI1R::DISABLE => false,
                    SPI1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SPI1R {
                match value {
                    false => SPI1R::DISABLE,
                    true => SPI1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == SPI1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == SPI1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `CRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl CRCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CRCR::DISABLE => false,
                    CRCR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CRCR {
                match value {
                    false => CRCR::DISABLE,
                    true => CRCR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == CRCR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == CRCR::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART0R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UART0R::DISABLE => false,
                    UART0R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UART0R {
                match value {
                    false => UART0R::DISABLE,
                    true => UART0R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == UART0R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == UART0R::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UART1R::DISABLE => false,
                    UART1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UART1R {
                match value {
                    false => UART1R::DISABLE,
                    true => UART1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == UART1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == UART1R::ENABLE
            }
        }
        #[doc = "Possible values of the field `UART2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UART2R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UART2R::DISABLE => false,
                    UART2R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UART2R {
                match value {
                    false => UART2R::DISABLE,
                    true => UART2R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == UART2R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == UART2R::ENABLE
            }
        }
        #[doc = "Possible values of the field `WWDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WWDTR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WWDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WWDTR::DISABLE => false,
                    WWDTR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WWDTR {
                match value {
                    false => WWDTR::DISABLE,
                    true => WWDTR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == WWDTR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == WWDTR::ENABLE
            }
        }
        #[doc = "Possible values of the field `IOCON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl IOCONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    IOCONR::DISABLE => false,
                    IOCONR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> IOCONR {
                match value {
                    false => IOCONR::DISABLE,
                    true => IOCONR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == IOCONR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == IOCONR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::DISABLE => false,
                    ACMPR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::DISABLE,
                    true => ACMPR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline(always)]
            pub fn is_disable(&self) -> bool {
                *self == ACMPR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                *self == ACMPR::ENABLE
            }
        }
        #[doc = "Values that can be written to the field `SYS`"]
        pub enum SYSW {
            #[doc = "Enable"]
            ENABLE,
        }
        impl SYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ROM`"]
        pub enum ROMW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ROMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ROMW::DISABLE => false,
                    ROMW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ROMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ROMW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ROMW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RAM`"]
        pub enum RAMW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl RAMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RAMW::DISABLE => false,
                    RAMW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RAMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(RAMW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(RAMW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASHREG`"]
        pub enum FLASHREGW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHREGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHREGW::DISABLE => false,
                    FLASHREGW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHREGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHREGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASHREGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(FLASHREGW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(FLASHREGW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH`"]
        pub enum FLASHW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl FLASHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHW::DISABLE => false,
                    FLASHW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(FLASHW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(FLASHW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C`"]
        pub enum I2CW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl I2CW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2CW::DISABLE => false,
                    I2CW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: I2CW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(I2CW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(I2CW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GPIO`"]
        pub enum GPIOW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl GPIOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    GPIOW::DISABLE => false,
                    GPIOW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: GPIOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(GPIOW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(GPIOW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SWM`"]
        pub enum SWMW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SWMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SWMW::DISABLE => false,
                    SWMW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SWMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SWMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SWMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SWMW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SWMW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCT`"]
        pub enum SCTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SCTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCTW::DISABLE => false,
                    SCTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SCTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SCTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT`"]
        pub enum WKTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WKTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKTW::DISABLE => false,
                    WKTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WKTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(WKTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(WKTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MRT`"]
        pub enum MRTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl MRTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MRTW::DISABLE => false,
                    MRTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MRTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MRTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MRTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(MRTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MRTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI0`"]
        pub enum SPI0W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI0W::DISABLE => false,
                    SPI0W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SPI0W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SPI0W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPI1`"]
        pub enum SPI1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SPI1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPI1W::DISABLE => false,
                    SPI1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPI1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPI1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPI1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(SPI1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(SPI1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CRC`"]
        pub enum CRCW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl CRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CRCW::DISABLE => false,
                    CRCW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CRCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(CRCW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(CRCW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART0`"]
        pub enum UART0W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART0W::DISABLE => false,
                    UART0W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART0W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART0W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART1`"]
        pub enum UART1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART1W::DISABLE => false,
                    UART1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART2`"]
        pub enum UART2W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl UART2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UART2W::DISABLE => false,
                    UART2W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UART2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _UART2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UART2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(UART2W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(UART2W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WWDT`"]
        pub enum WWDTW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl WWDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WWDTW::DISABLE => false,
                    WWDTW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WWDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(WWDTW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(WWDTW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCON`"]
        pub enum IOCONW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl IOCONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    IOCONW::DISABLE => false,
                    IOCONW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(IOCONW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(IOCONW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::DISABLE => false,
                    ACMPW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline(always)]
            pub fn disable(self) -> &'a mut W {
                self.variant(ACMPW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(ACMPW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0+ core clocks, SYSCON, and the PMU. This bit is read only and always reads as 1."]
            #[inline(always)]
            pub fn sys(&self) -> SYSR {
                SYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline(always)]
            pub fn rom(&self) -> ROMR {
                ROMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enables clock for SRAM."]
            #[inline(always)]
            pub fn ram(&self) -> RAMR {
                RAMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline(always)]
            pub fn flashreg(&self) -> FLASHREGR {
                FLASHREGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enables clock for flash."]
            #[inline(always)]
            pub fn flash(&self) -> FLASHR {
                FLASHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enables clock for I2C."]
            #[inline(always)]
            pub fn i2c(&self) -> I2CR {
                I2CR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enables clock for GPIO port registers and GPIO pin interrupt registers."]
            #[inline(always)]
            pub fn gpio(&self) -> GPIOR {
                GPIOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enables clock for switch matrix."]
            #[inline(always)]
            pub fn swm(&self) -> SWMR {
                SWMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enables clock for state configurable timer."]
            #[inline(always)]
            pub fn sct(&self) -> SCTR {
                SCTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enables clock for self wake-up timer."]
            #[inline(always)]
            pub fn wkt(&self) -> WKTR {
                WKTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enables clock for multi-rate timer."]
            #[inline(always)]
            pub fn mrt(&self) -> MRTR {
                MRTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Enables clock for SPI0."]
            #[inline(always)]
            pub fn spi0(&self) -> SPI0R {
                SPI0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Enables clock for SPI1."]
            #[inline(always)]
            pub fn spi1(&self) -> SPI1R {
                SPI1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Enables clock for CRC."]
            #[inline(always)]
            pub fn crc(&self) -> CRCR {
                CRCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enables clock for UART0."]
            #[inline(always)]
            pub fn uart0(&self) -> UART0R {
                UART0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Enables clock for UART1."]
            #[inline(always)]
            pub fn uart1(&self) -> UART1R {
                UART1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Enables clock for UART2."]
            #[inline(always)]
            pub fn uart2(&self) -> UART2R {
                UART2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enables clock for WWDT."]
            #[inline(always)]
            pub fn wwdt(&self) -> WWDTR {
                WWDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enables clock for IOCON block."]
            #[inline(always)]
            pub fn iocon(&self) -> IOCONR {
                IOCONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enables clock to analog comparator."]
            #[inline(always)]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 31 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enables the clock for the AHB, the APB bridge, the Cortex-M0+ core clocks, SYSCON, and the PMU. This bit is read only and always reads as 1."]
            #[inline(always)]
            pub fn sys(&mut self) -> _SYSW {
                _SYSW { w: self }
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline(always)]
            pub fn rom(&mut self) -> _ROMW {
                _ROMW { w: self }
            }
            #[doc = "Bit 2 - Enables clock for SRAM."]
            #[inline(always)]
            pub fn ram(&mut self) -> _RAMW {
                _RAMW { w: self }
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline(always)]
            pub fn flashreg(&mut self) -> _FLASHREGW {
                _FLASHREGW { w: self }
            }
            #[doc = "Bit 4 - Enables clock for flash."]
            #[inline(always)]
            pub fn flash(&mut self) -> _FLASHW {
                _FLASHW { w: self }
            }
            #[doc = "Bit 5 - Enables clock for I2C."]
            #[inline(always)]
            pub fn i2c(&mut self) -> _I2CW {
                _I2CW { w: self }
            }
            #[doc = "Bit 6 - Enables clock for GPIO port registers and GPIO pin interrupt registers."]
            #[inline(always)]
            pub fn gpio(&mut self) -> _GPIOW {
                _GPIOW { w: self }
            }
            #[doc = "Bit 7 - Enables clock for switch matrix."]
            #[inline(always)]
            pub fn swm(&mut self) -> _SWMW {
                _SWMW { w: self }
            }
            #[doc = "Bit 8 - Enables clock for state configurable timer."]
            #[inline(always)]
            pub fn sct(&mut self) -> _SCTW {
                _SCTW { w: self }
            }
            #[doc = "Bit 9 - Enables clock for self wake-up timer."]
            #[inline(always)]
            pub fn wkt(&mut self) -> _WKTW {
                _WKTW { w: self }
            }
            #[doc = "Bit 10 - Enables clock for multi-rate timer."]
            #[inline(always)]
            pub fn mrt(&mut self) -> _MRTW {
                _MRTW { w: self }
            }
            #[doc = "Bit 11 - Enables clock for SPI0."]
            #[inline(always)]
            pub fn spi0(&mut self) -> _SPI0W {
                _SPI0W { w: self }
            }
            #[doc = "Bit 12 - Enables clock for SPI1."]
            #[inline(always)]
            pub fn spi1(&mut self) -> _SPI1W {
                _SPI1W { w: self }
            }
            #[doc = "Bit 13 - Enables clock for CRC."]
            #[inline(always)]
            pub fn crc(&mut self) -> _CRCW {
                _CRCW { w: self }
            }
            #[doc = "Bit 14 - Enables clock for UART0."]
            #[inline(always)]
            pub fn uart0(&mut self) -> _UART0W {
                _UART0W { w: self }
            }
            #[doc = "Bit 15 - Enables clock for UART1."]
            #[inline(always)]
            pub fn uart1(&mut self) -> _UART1W {
                _UART1W { w: self }
            }
            #[doc = "Bit 16 - Enables clock for UART2."]
            #[inline(always)]
            pub fn uart2(&mut self) -> _UART2W {
                _UART2W { w: self }
            }
            #[doc = "Bit 17 - Enables clock for WWDT."]
            #[inline(always)]
            pub fn wwdt(&mut self) -> _WWDTW {
                _WWDTW { w: self }
            }
            #[doc = "Bit 18 - Enables clock for IOCON block."]
            #[inline(always)]
            pub fn iocon(&mut self) -> _IOCONW {
                _IOCONW { w: self }
            }
            #[doc = "Bit 19 - Enables clock to analog comparator."]
            #[inline(always)]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
        }
    }
    #[doc = "UART clock divider"]
    pub struct UARTCLKDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "UART clock divider"]
    pub mod uartclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - UART clock divider values. 0: Clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - UART clock divider values. 0: Clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source select"]
    pub struct CLKOUTSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source select"]
    pub mod clkoutsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Crystal oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR_,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::CRYSTAL_OSCILLATOR_ => 1,
                    SELR::WATCHDOG_OSCILLATOR => 2,
                    SELR::MAIN_CLOCK => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::CRYSTAL_OSCILLATOR_,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    3 => SELR::MAIN_CLOCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline(always)]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `CRYSTAL_OSCILLATOR_`"]
            #[inline(always)]
            pub fn is_crystal_oscillator_(&self) -> bool {
                *self == SELR::CRYSTAL_OSCILLATOR_
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline(always)]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `MAIN_CLOCK`"]
            #[inline(always)]
            pub fn is_main_clock(&self) -> bool {
                *self == SELR::MAIN_CLOCK
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Crystal oscillator (SYSOSC)"]
            CRYSTAL_OSCILLATOR_,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::CRYSTAL_OSCILLATOR_ => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                    SELW::MAIN_CLOCK => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC oscillator"]
            #[inline(always)]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "Crystal oscillator (SYSOSC)"]
            #[inline(always)]
            pub fn crystal_oscillator_(self) -> &'a mut W {
                self.variant(SELW::CRYSTAL_OSCILLATOR_)
            }
            #[doc = "Watchdog oscillator"]
            #[inline(always)]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = "Main clock"]
            #[inline(always)]
            pub fn main_clock(self) -> &'a mut W {
                self.variant(SELW::MAIN_CLOCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline(always)]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline(always)]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source update enable"]
    pub struct CLKOUTUEN {
        register: VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source update enable"]
    pub mod clkoutuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline(always)]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline(always)]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline(always)]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline(always)]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline(always)]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline(always)]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock divider"]
    pub struct CLKOUTDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock divider"]
    pub mod clkoutdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - CLKOUT clock divider values 0: Disable CLKOUT clock divider. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "UART fractional generator divider value"]
    pub struct UARTFRGDIV {
        register: VolatileCell<u32>,
    }
    #[doc = "UART fractional generator divider value"]
    pub mod uartfrgdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTFRGDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "UART fractional generator multiplier value"]
    pub struct UARTFRGMULT {
        register: VolatileCell<u32>,
    }
    #[doc = "UART fractional generator multiplier value"]
    pub mod uartfrgmult {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTFRGMULT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MULTR {
            bits: u8,
        }
        impl MULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MULTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MULTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Numerator of the fractional divider. MULT is equal to the programmed value."]
            #[inline(always)]
            pub fn mult(&self) -> MULTR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MULTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Numerator of the fractional divider. MULT is equal to the programmed value."]
            #[inline(always)]
            pub fn mult(&mut self) -> _MULTW {
                _MULTW { w: self }
            }
        }
    }
    #[doc = "External trace buffer command register"]
    pub struct EXTTRACECMD {
        register: VolatileCell<u32>,
    }
    #[doc = "External trace buffer command register"]
    pub mod exttracecmd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTTRACECMD {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: bool,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Trace start command"]
            #[inline(always)]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 1 - Trace stop command"]
            #[inline(always)]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Trace start command"]
            #[inline(always)]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 1 - Trace stop command"]
            #[inline(always)]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
        }
    }
    #[doc = "POR captured PIO status 0"]
    pub struct PIOPORCAP0 {
        register: VolatileCell<u32>,
    }
    #[doc = "POR captured PIO status 0"]
    pub mod pioporcap0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PIOPORCAP0 {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PIOSTATR {
            bits: u32,
        }
        impl PIOSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - State of PIO0_17 through PIO0_0 at power-on reset"]
            #[inline(always)]
            pub fn piostat(&self) -> PIOSTATR {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PIOSTATR { bits }
            }
        }
    }
    #[doc = "Peripheral clock 6 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV6 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 6 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 5 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV5 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 5 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 4 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 4 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 3 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 3 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 2 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 2 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 1 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 1 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Peripheral clock 0 to the IOCON block for programmable glitch filter"]
    pub struct IOCONCLKDIV0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral clock 0 to the IOCON block for programmable glitch filter"]
    pub mod ioconclkdiv0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IOCONCLKDIV0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline(always)]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "Brown-Out Detect"]
    pub struct BODCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "Brown-Out Detect"]
    pub mod bodctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BODCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BODRSTLEV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTLEVR {
            #[doc = "Level 0: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_0_THE_RESET_A,
            #[doc = "Level 1: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_1_THE_RESET_A,
            #[doc = "Level 2: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_2_THE_RESET_A,
            #[doc = "Level 3: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is."]
            LEVEL_3_THE_RESET_A,
        }
        impl BODRSTLEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODRSTLEVR::LEVEL_0_THE_RESET_A => 0,
                    BODRSTLEVR::LEVEL_1_THE_RESET_A => 1,
                    BODRSTLEVR::LEVEL_2_THE_RESET_A => 2,
                    BODRSTLEVR::LEVEL_3_THE_RESET_A => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> BODRSTLEVR {
                match value {
                    0 => BODRSTLEVR::LEVEL_0_THE_RESET_A,
                    1 => BODRSTLEVR::LEVEL_1_THE_RESET_A,
                    2 => BODRSTLEVR::LEVEL_2_THE_RESET_A,
                    3 => BODRSTLEVR::LEVEL_3_THE_RESET_A,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LEVEL_0_THE_RESET_A`"]
            #[inline(always)]
            pub fn is_level_0_the_reset_a(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_0_THE_RESET_A
            }
            #[doc = "Checks if the value of the field is `LEVEL_1_THE_RESET_A`"]
            #[inline(always)]
            pub fn is_level_1_the_reset_a(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_1_THE_RESET_A
            }
            #[doc = "Checks if the value of the field is `LEVEL_2_THE_RESET_A`"]
            #[inline(always)]
            pub fn is_level_2_the_reset_a(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_2_THE_RESET_A
            }
            #[doc = "Checks if the value of the field is `LEVEL_3_THE_RESET_A`"]
            #[inline(always)]
            pub fn is_level_3_the_reset_a(&self) -> bool {
                *self == BODRSTLEVR::LEVEL_3_THE_RESET_A
            }
        }
        #[doc = "Possible values of the field `BODINTVAL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODINTVALR {
            #[doc = "Level 0: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is"]
            LEVEL_0_THE_INTERRU,
            #[doc = "Level 1:The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_1THE_INTERRUP,
            #[doc = "Level 2: The interrupt assertion threshold voltage is  ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_2_THE_INTERRU,
            #[doc = "Level 3: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_3_THE_INTERRU,
        }
        impl BODINTVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODINTVALR::LEVEL_0_THE_INTERRU => 0,
                    BODINTVALR::LEVEL_1THE_INTERRUP => 1,
                    BODINTVALR::LEVEL_2_THE_INTERRU => 2,
                    BODINTVALR::LEVEL_3_THE_INTERRU => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> BODINTVALR {
                match value {
                    0 => BODINTVALR::LEVEL_0_THE_INTERRU,
                    1 => BODINTVALR::LEVEL_1THE_INTERRUP,
                    2 => BODINTVALR::LEVEL_2_THE_INTERRU,
                    3 => BODINTVALR::LEVEL_3_THE_INTERRU,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LEVEL_0_THE_INTERRU`"]
            #[inline(always)]
            pub fn is_level_0_the_interru(&self) -> bool {
                *self == BODINTVALR::LEVEL_0_THE_INTERRU
            }
            #[doc = "Checks if the value of the field is `LEVEL_1THE_INTERRUP`"]
            #[inline(always)]
            pub fn is_level_1the_interrup(&self) -> bool {
                *self == BODINTVALR::LEVEL_1THE_INTERRUP
            }
            #[doc = "Checks if the value of the field is `LEVEL_2_THE_INTERRU`"]
            #[inline(always)]
            pub fn is_level_2_the_interru(&self) -> bool {
                *self == BODINTVALR::LEVEL_2_THE_INTERRU
            }
            #[doc = "Checks if the value of the field is `LEVEL_3_THE_INTERRU`"]
            #[inline(always)]
            pub fn is_level_3_the_interru(&self) -> bool {
                *self == BODINTVALR::LEVEL_3_THE_INTERRU
            }
        }
        #[doc = "Possible values of the field `BODRSTENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTENAR {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BODRSTENAR::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAR::ENABLE_RESET_FUNCTIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BODRSTENAR {
                match value {
                    false => BODRSTENAR::DISABLE_RESET_FUNCTI,
                    true => BODRSTENAR::ENABLE_RESET_FUNCTIO,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_RESET_FUNCTI`"]
            #[inline(always)]
            pub fn is_disable_reset_functi(&self) -> bool {
                *self == BODRSTENAR::DISABLE_RESET_FUNCTI
            }
            #[doc = "Checks if the value of the field is `ENABLE_RESET_FUNCTIO`"]
            #[inline(always)]
            pub fn is_enable_reset_functio(&self) -> bool {
                *self == BODRSTENAR::ENABLE_RESET_FUNCTIO
            }
        }
        #[doc = "Values that can be written to the field `BODRSTLEV`"]
        pub enum BODRSTLEVW {
            #[doc = "Level 0: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_0_THE_RESET_A,
            #[doc = "Level 1: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_1_THE_RESET_A,
            #[doc = "Level 2: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            LEVEL_2_THE_RESET_A,
            #[doc = "Level 3: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is."]
            LEVEL_3_THE_RESET_A,
        }
        impl BODRSTLEVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODRSTLEVW::LEVEL_0_THE_RESET_A => 0,
                    BODRSTLEVW::LEVEL_1_THE_RESET_A => 1,
                    BODRSTLEVW::LEVEL_2_THE_RESET_A => 2,
                    BODRSTLEVW::LEVEL_3_THE_RESET_A => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTLEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTLEVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BODRSTLEVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Level 0: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_0_the_reset_a(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_0_THE_RESET_A)
            }
            #[doc = "Level 1: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_1_the_reset_a(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_1_THE_RESET_A)
            }
            #[doc = "Level 2: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_2_the_reset_a(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_2_THE_RESET_A)
            }
            #[doc = "Level 3: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is."]
            #[inline(always)]
            pub fn level_3_the_reset_a(self) -> &'a mut W {
                self.variant(BODRSTLEVW::LEVEL_3_THE_RESET_A)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODINTVAL`"]
        pub enum BODINTVALW {
            #[doc = "Level 0: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is"]
            LEVEL_0_THE_INTERRU,
            #[doc = "Level 1:The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_1THE_INTERRUP,
            #[doc = "Level 2: The interrupt assertion threshold voltage is  ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_2_THE_INTERRU,
            #[doc = "Level 3: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            LEVEL_3_THE_INTERRU,
        }
        impl BODINTVALW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODINTVALW::LEVEL_0_THE_INTERRU => 0,
                    BODINTVALW::LEVEL_1THE_INTERRUP => 1,
                    BODINTVALW::LEVEL_2_THE_INTERRU => 2,
                    BODINTVALW::LEVEL_3_THE_INTERRU => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODINTVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODINTVALW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BODINTVALW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Level 0: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is"]
            #[inline(always)]
            pub fn level_0_the_interru(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_0_THE_INTERRU)
            }
            #[doc = "Level 1:The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_1the_interrup(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_1THE_INTERRUP)
            }
            #[doc = "Level 2: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_2_the_interru(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_2_THE_INTERRU)
            }
            #[doc = "Level 3: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is ."]
            #[inline(always)]
            pub fn level_3_the_interru(self) -> &'a mut W {
                self.variant(BODINTVALW::LEVEL_3_THE_INTERRU)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODRSTENA`"]
        pub enum BODRSTENAW {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODRSTENAW::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAW::ENABLE_RESET_FUNCTIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BODRSTENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable reset function."]
            #[inline(always)]
            pub fn disable_reset_functi(self) -> &'a mut W {
                self.variant(BODRSTENAW::DISABLE_RESET_FUNCTI)
            }
            #[doc = "Enable reset function."]
            #[inline(always)]
            pub fn enable_reset_functio(self) -> &'a mut W {
                self.variant(BODRSTENAW::ENABLE_RESET_FUNCTIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - BOD reset level"]
            #[inline(always)]
            pub fn bodrstlev(&self) -> BODRSTLEVR {
                BODRSTLEVR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - BOD interrupt level"]
            #[inline(always)]
            pub fn bodintval(&self) -> BODINTVALR {
                BODINTVALR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline(always)]
            pub fn bodrstena(&self) -> BODRSTENAR {
                BODRSTENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - BOD reset level"]
            #[inline(always)]
            pub fn bodrstlev(&mut self) -> _BODRSTLEVW {
                _BODRSTLEVW { w: self }
            }
            #[doc = "Bits 2:3 - BOD interrupt level"]
            #[inline(always)]
            pub fn bodintval(&mut self) -> _BODINTVALW {
                _BODINTVALW { w: self }
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline(always)]
            pub fn bodrstena(&mut self) -> _BODRSTENAW {
                _BODRSTENAW { w: self }
            }
        }
    }
    #[doc = "System tick counter calibration"]
    pub struct SYSTCKCAL {
        register: VolatileCell<u32>,
    }
    #[doc = "System tick counter calibration"]
    pub mod systckcal {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSTCKCAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALR {
            bits: u32,
        }
        impl CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 67108863;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline(always)]
            pub fn cal(&self) -> CALR {
                let bits = {
                    const MASK: u32 = 67108863;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline(always)]
            pub fn cal(&mut self) -> _CALW {
                _CALW { w: self }
            }
        }
    }
    #[doc = "IQR delay. Allows trade-off between interrupt latency and determinism."]
    pub struct IRQLATENCY {
        register: VolatileCell<u32>,
    }
    #[doc = "IQR delay. Allows trade-off between interrupt latency and determinism."]
    pub mod irqlatency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRQLATENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LATENCYR {
            bits: u8,
        }
        impl LATENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LATENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LATENCYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - 8-bit latency value"]
            #[inline(always)]
            pub fn latency(&self) -> LATENCYR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LATENCYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 16 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - 8-bit latency value"]
            #[inline(always)]
            pub fn latency(&mut self) -> _LATENCYW {
                _LATENCYW { w: self }
            }
        }
    }
    #[doc = "NMI Source Control"]
    pub struct NMISRC {
        register: VolatileCell<u32>,
    }
    #[doc = "NMI Source Control"]
    pub mod nmisrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NMISRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IRQNOR {
            bits: u8,
        }
        impl IRQNOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct NMIENR {
            bits: bool,
        }
        impl NMIENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRQNOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRQNOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMIENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMIENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 58 for the list of interrupt sources and their IRQ numbers."]
            #[inline(always)]
            pub fn irqno(&self) -> IRQNOR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IRQNOR { bits }
            }
            #[doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0."]
            #[inline(always)]
            pub fn nmien(&self) -> NMIENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NMIENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 58 for the list of interrupt sources and their IRQ numbers."]
            #[inline(always)]
            pub fn irqno(&mut self) -> _IRQNOW {
                _IRQNOW { w: self }
            }
            #[doc = "Bit 31 - Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0."]
            #[inline(always)]
            pub fn nmien(&mut self) -> _NMIENW {
                _NMIENW { w: self }
            }
        }
    }
    #[doc = "GPIO Pin Interrupt Select register 0"]
    pub struct PINTSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO Pin Interrupt Select register 0"]
    pub mod pintsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PINTSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct INTPINR {
            bits: u8,
        }
        impl INTPINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _INTPINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INTPINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17)."]
            #[inline(always)]
            pub fn intpin(&self) -> INTPINR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INTPINR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17)."]
            #[inline(always)]
            pub fn intpin(&mut self) -> _INTPINW {
                _INTPINW { w: self }
            }
        }
    }
    #[doc = "Start logic 0 pin wake-up enable register"]
    pub struct STARTERP0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Start logic 0 pin wake-up enable register"]
    pub mod starterp0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PINT0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT0R::DISABLED => false,
                    PINT0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT0R {
                match value {
                    false => PINT0R::DISABLED,
                    true => PINT0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT1R::DISABLED => false,
                    PINT1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT1R {
                match value {
                    false => PINT1R::DISABLED,
                    true => PINT1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT2R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT2R::DISABLED => false,
                    PINT2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT2R {
                match value {
                    false => PINT2R::DISABLED,
                    true => PINT2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT3R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT3R::DISABLED => false,
                    PINT3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT3R {
                match value {
                    false => PINT3R::DISABLED,
                    true => PINT3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT4R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT4R::DISABLED => false,
                    PINT4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT4R {
                match value {
                    false => PINT4R::DISABLED,
                    true => PINT4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT5R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT5R::DISABLED => false,
                    PINT5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT5R {
                match value {
                    false => PINT5R::DISABLED,
                    true => PINT5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT6R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT6R::DISABLED => false,
                    PINT6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT6R {
                match value {
                    false => PINT6R::DISABLED,
                    true => PINT6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PINT7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINT7R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    PINT7R::DISABLED => false,
                    PINT7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> PINT7R {
                match value {
                    false => PINT7R::DISABLED,
                    true => PINT7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == PINT7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == PINT7R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `PINT0`"]
        pub enum PINT0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT0W::DISABLED => false,
                    PINT0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT1`"]
        pub enum PINT1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT1W::DISABLED => false,
                    PINT1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT2`"]
        pub enum PINT2W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT2W::DISABLED => false,
                    PINT2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT2W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT3`"]
        pub enum PINT3W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT3W::DISABLED => false,
                    PINT3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT3W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT4`"]
        pub enum PINT4W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT4W::DISABLED => false,
                    PINT4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT4W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT5`"]
        pub enum PINT5W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT5W::DISABLED => false,
                    PINT5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT5W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT6`"]
        pub enum PINT6W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT6W::DISABLED => false,
                    PINT6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT6W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PINT7`"]
        pub enum PINT7W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl PINT7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    PINT7W::DISABLED => false,
                    PINT7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PINT7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PINT7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PINT7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PINT7W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PINT7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - GPIO pin interrupt 0 wake-up"]
            #[inline(always)]
            pub fn pint0(&self) -> PINT0R {
                PINT0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - GPIO pin interrupt 1 wake-up"]
            #[inline(always)]
            pub fn pint1(&self) -> PINT1R {
                PINT1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - GPIO pin interrupt 2 wake-up"]
            #[inline(always)]
            pub fn pint2(&self) -> PINT2R {
                PINT2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - GPIO pin interrupt 3 wake-up"]
            #[inline(always)]
            pub fn pint3(&self) -> PINT3R {
                PINT3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - GPIO pin interrupt 4 wake-up"]
            #[inline(always)]
            pub fn pint4(&self) -> PINT4R {
                PINT4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - GPIO pin interrupt 5 wake-up"]
            #[inline(always)]
            pub fn pint5(&self) -> PINT5R {
                PINT5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - GPIO pin interrupt 6 wake-up"]
            #[inline(always)]
            pub fn pint6(&self) -> PINT6R {
                PINT6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - GPIO pin interrupt 7 wake-up"]
            #[inline(always)]
            pub fn pint7(&self) -> PINT7R {
                PINT7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - GPIO pin interrupt 0 wake-up"]
            #[inline(always)]
            pub fn pint0(&mut self) -> _PINT0W {
                _PINT0W { w: self }
            }
            #[doc = "Bit 1 - GPIO pin interrupt 1 wake-up"]
            #[inline(always)]
            pub fn pint1(&mut self) -> _PINT1W {
                _PINT1W { w: self }
            }
            #[doc = "Bit 2 - GPIO pin interrupt 2 wake-up"]
            #[inline(always)]
            pub fn pint2(&mut self) -> _PINT2W {
                _PINT2W { w: self }
            }
            #[doc = "Bit 3 - GPIO pin interrupt 3 wake-up"]
            #[inline(always)]
            pub fn pint3(&mut self) -> _PINT3W {
                _PINT3W { w: self }
            }
            #[doc = "Bit 4 - GPIO pin interrupt 4 wake-up"]
            #[inline(always)]
            pub fn pint4(&mut self) -> _PINT4W {
                _PINT4W { w: self }
            }
            #[doc = "Bit 5 - GPIO pin interrupt 5 wake-up"]
            #[inline(always)]
            pub fn pint5(&mut self) -> _PINT5W {
                _PINT5W { w: self }
            }
            #[doc = "Bit 6 - GPIO pin interrupt 6 wake-up"]
            #[inline(always)]
            pub fn pint6(&mut self) -> _PINT6W {
                _PINT6W { w: self }
            }
            #[doc = "Bit 7 - GPIO pin interrupt 7 wake-up"]
            #[inline(always)]
            pub fn pint7(&mut self) -> _PINT7W {
                _PINT7W { w: self }
            }
        }
    }
    #[doc = "Start logic 1 interrupt wake-up enable register"]
    pub struct STARTERP1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Start logic 1 interrupt wake-up enable register"]
    pub mod starterp1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WWDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WWDTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WWDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WWDTR::DISABLED => false,
                    WWDTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WWDTR {
                match value {
                    false => WWDTR::DISABLED,
                    true => WWDTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WWDTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WWDTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl BODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BODR::DISABLED => false,
                    BODR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BODR {
                match value {
                    false => BODR::DISABLED,
                    true => BODR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == BODR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == BODR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WKT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WKTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WKTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WKTR::DISABLED => false,
                    WKTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WKTR {
                match value {
                    false => WKTR::DISABLED,
                    true => WKTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                *self == WKTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                *self == WKTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `WWDT`"]
        pub enum WWDTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WWDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WWDTW::DISABLED => false,
                    WWDTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WWDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WWDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WWDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WWDTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WWDTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD`"]
        pub enum BODW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl BODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODW::DISABLED => false,
                    BODW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BODW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BODW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WKT`"]
        pub enum WKTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WKTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WKTW::DISABLED => false,
                    WKTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WKTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WKTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WKTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WKTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WKTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 12 - WWDT interrupt wake-up"]
            #[inline(always)]
            pub fn wwdt(&self) -> WWDTR {
                WWDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - BOD interrupt wake-up"]
            #[inline(always)]
            pub fn bod(&self) -> BODR {
                BODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Self wake-up timer interrupt wake-up"]
            #[inline(always)]
            pub fn wkt(&self) -> WKTR {
                WKTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 12 - WWDT interrupt wake-up"]
            #[inline(always)]
            pub fn wwdt(&mut self) -> _WWDTW {
                _WWDTW { w: self }
            }
            #[doc = "Bit 13 - BOD interrupt wake-up"]
            #[inline(always)]
            pub fn bod(&mut self) -> _BODW {
                _BODW { w: self }
            }
            #[doc = "Bit 15 - Self wake-up timer interrupt wake-up"]
            #[inline(always)]
            pub fn wkt(&mut self) -> _WKTW {
                _WKTW { w: self }
            }
        }
    }
    #[doc = "Power-down states in deep-sleep mode"]
    pub struct PDSLEEPCFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Power-down states in deep-sleep mode"]
    pub mod pdsleepcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDSLEEPCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode"]
            #[inline(always)]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 65535 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - BOD power-down control for Deep-sleep and Power-down mode"]
            #[inline(always)]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down control for Deep-sleep and Power-down mode. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
        }
    }
    #[doc = "Power-down states for wake-up from deep-sleep"]
    pub struct PDAWAKECFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Power-down states for wake-up from deep-sleep"]
    pub mod pdawakecfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDAWAKECFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::POWERED => false,
                    ACMPR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::POWERED,
                    true => ACMPR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == ACMPR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == ACMPR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::POWERED => false,
                    ACMPW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(ACMPW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ACMPW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline(always)]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline(always)]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline(always)]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline(always)]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Crystal oscillator wake-up configuration"]
            #[inline(always)]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline(always)]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Analog comparator wake-up configuration"]
            #[inline(always)]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 60912 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline(always)]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline(always)]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline(always)]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline(always)]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 5 - Crystal oscillator wake-up configuration"]
            #[inline(always)]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline(always)]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 15 - Analog comparator wake-up configuration"]
            #[inline(always)]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
        }
    }
    #[doc = "Power configuration register"]
    pub struct PDRUNCFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Power configuration register"]
    pub mod pdruncfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDRUNCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ACMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACMPR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ACMPR::POWERED => false,
                    ACMPR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ACMPR {
                match value {
                    false => ACMPR::POWERED,
                    true => ACMPR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline(always)]
            pub fn is_powered(&self) -> bool {
                *self == ACMPR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline(always)]
            pub fn is_powered_down(&self) -> bool {
                *self == ACMPR::POWERED_DOWN
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACMP`"]
        pub enum ACMPW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ACMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACMPW::POWERED => false,
                    ACMPW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ACMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline(always)]
            pub fn powered(self) -> &'a mut W {
                self.variant(ACMPW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline(always)]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ACMPW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output power"]
            #[inline(always)]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power down"]
            #[inline(always)]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash power down"]
            #[inline(always)]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD power down"]
            #[inline(always)]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Crystal oscillator power down"]
            #[inline(always)]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator power down. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL power down"]
            #[inline(always)]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Analog comparator power down"]
            #[inline(always)]
            pub fn acmp(&self) -> ACMPR {
                ACMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 60912 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output power"]
            #[inline(always)]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power down"]
            #[inline(always)]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash power down"]
            #[inline(always)]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD power down"]
            #[inline(always)]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 5 - Crystal oscillator power down"]
            #[inline(always)]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power down. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running."]
            #[inline(always)]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL power down"]
            #[inline(always)]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 15 - Analog comparator power down"]
            #[inline(always)]
            pub fn acmp(&mut self) -> _ACMPW {
                _ACMPW { w: self }
            }
        }
    }
    #[doc = "Device ID"]
    pub struct DEVICE_ID {
        register: VolatileCell<u32>,
    }
    #[doc = "Device ID"]
    pub mod device_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVICE_ID {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVICEIDR {
            bits: u32,
        }
        impl DEVICEIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - TBD"]
            #[inline(always)]
            pub fn deviceid(&self) -> DEVICEIDR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DEVICEIDR { bits }
            }
        }
    }
}
#[doc = "System configuration (SYSCON)"]
pub struct SYSCON {
    register_block: syscon::RegisterBlock,
}
impl Deref for SYSCON {
    type Target = syscon::RegisterBlock;
    fn deref(&self) -> &syscon::RegisterBlock {
        &self.register_block
    }
}
#[doc = "I2C-bus interface"]
pub const I2C: Peripheral<I2C> = unsafe { Peripheral::new(1074069504) };
#[doc = "I2C-bus interface"]
pub mod i2c {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Configuration for shared functions."]
        pub cfg: CFG,
        #[doc = "0x04 - Status register for Master, Slave, and Monitor functions."]
        pub stat: STAT,
        #[doc = "0x08 - Interrupt Enable Set and read register."]
        pub intenset: INTENSET,
        #[doc = "0x0c - Interrupt Enable Clear register."]
        pub intenclr: INTENCLR,
        #[doc = "0x10 - Time-out value register."]
        pub timeout: TIMEOUT,
        #[doc = "0x14 - Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
        pub div: DIV,
        #[doc = "0x18 - Interrupt Status register for Master, Slave, and Monitor functions."]
        pub intstat: INTSTAT,
        _reserved0: [u8; 4usize],
        #[doc = "0x20 - Master control register."]
        pub mstctl: MSTCTL,
        #[doc = "0x24 - Master timing configuration."]
        pub msttime: MSTTIME,
        #[doc = "0x28 - Combined Master receiver and transmitter data register."]
        pub mstdat: MSTDAT,
        _reserved1: [u8; 20usize],
        #[doc = "0x40 - Slave control register."]
        pub slvctl: SLVCTL,
        #[doc = "0x44 - Combined Slave receiver and transmitter data register."]
        pub slvdat: SLVDAT,
        #[doc = "0x48 - Slave address 0."]
        pub slvadr0: SLVADR,
        #[doc = "0x4c - Slave address 0."]
        pub slvadr1: SLVADR,
        #[doc = "0x50 - Slave address 0."]
        pub slvadr2: SLVADR,
        #[doc = "0x54 - Slave address 0."]
        pub slvadr3: SLVADR,
        #[doc = "0x58 - Slave Qualification for address 0."]
        pub slvqual0: SLVQUAL0,
        _reserved2: [u8; 36usize],
        #[doc = "0x80 - Monitor receiver data register."]
        pub monrxdat: MONRXDAT,
    }
    #[doc = "Configuration for shared functions."]
    pub struct CFG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration for shared functions."]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTENR {
            #[doc = "Disabled. The I2C Master function is disabled."]
            DISABLED_THE_I2C_MA,
            #[doc = "Enabled. The I2C Master function is enabled."]
            ENABLED_THE_I2C_MAS,
        }
        impl MSTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTENR::DISABLED_THE_I2C_MA => false,
                    MSTENR::ENABLED_THE_I2C_MAS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTENR {
                match value {
                    false => MSTENR::DISABLED_THE_I2C_MA,
                    true => MSTENR::ENABLED_THE_I2C_MAS,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_I2C_MA`"]
            #[inline(always)]
            pub fn is_disabled_the_i2c_ma(&self) -> bool {
                *self == MSTENR::DISABLED_THE_I2C_MA
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_I2C_MAS`"]
            #[inline(always)]
            pub fn is_enabled_the_i2c_mas(&self) -> bool {
                *self == MSTENR::ENABLED_THE_I2C_MAS
            }
        }
        #[doc = "Possible values of the field `SLVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVENR {
            #[doc = "Disabled. The I2C slave function is disabled."]
            DISABLED_THE_I2C_SL,
            #[doc = "Enabled. The I2C slave function is enabled."]
            ENABLED_THE_I2C_SLA,
        }
        impl SLVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVENR::DISABLED_THE_I2C_SL => false,
                    SLVENR::ENABLED_THE_I2C_SLA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVENR {
                match value {
                    false => SLVENR::DISABLED_THE_I2C_SL,
                    true => SLVENR::ENABLED_THE_I2C_SLA,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_I2C_SL`"]
            #[inline(always)]
            pub fn is_disabled_the_i2c_sl(&self) -> bool {
                *self == SLVENR::DISABLED_THE_I2C_SL
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_I2C_SLA`"]
            #[inline(always)]
            pub fn is_enabled_the_i2c_sla(&self) -> bool {
                *self == SLVENR::ENABLED_THE_I2C_SLA
            }
        }
        #[doc = "Possible values of the field `MONEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONENR {
            #[doc = "Disabled. The I2C monitor function is disabled."]
            DISABLED_THE_I2C_MO,
            #[doc = "Enabled. The I2C monitor function is enabled."]
            ENABLED_THE_I2C_MON,
        }
        impl MONENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONENR::DISABLED_THE_I2C_MO => false,
                    MONENR::ENABLED_THE_I2C_MON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONENR {
                match value {
                    false => MONENR::DISABLED_THE_I2C_MO,
                    true => MONENR::ENABLED_THE_I2C_MON,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_I2C_MO`"]
            #[inline(always)]
            pub fn is_disabled_the_i2c_mo(&self) -> bool {
                *self == MONENR::DISABLED_THE_I2C_MO
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_I2C_MON`"]
            #[inline(always)]
            pub fn is_enabled_the_i2c_mon(&self) -> bool {
                *self == MONENR::ENABLED_THE_I2C_MON
            }
        }
        #[doc = "Possible values of the field `TIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUTENR {
            #[doc = "Disabled. Time-out function is disabled."]
            DISABLED_TIME_OUT_F,
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one timeout will be used in a system."]
            ENABLED_TIME_OUT_FU,
        }
        impl TIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TIMEOUTENR::DISABLED_TIME_OUT_F => false,
                    TIMEOUTENR::ENABLED_TIME_OUT_FU => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TIMEOUTENR {
                match value {
                    false => TIMEOUTENR::DISABLED_TIME_OUT_F,
                    true => TIMEOUTENR::ENABLED_TIME_OUT_FU,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_TIME_OUT_F`"]
            #[inline(always)]
            pub fn is_disabled_time_out_f(&self) -> bool {
                *self == TIMEOUTENR::DISABLED_TIME_OUT_F
            }
            #[doc = "Checks if the value of the field is `ENABLED_TIME_OUT_FU`"]
            #[inline(always)]
            pub fn is_enabled_time_out_fu(&self) -> bool {
                *self == TIMEOUTENR::ENABLED_TIME_OUT_FU
            }
        }
        #[doc = "Possible values of the field `MONCLKSTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONCLKSTRR {
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            DISABLED_THE_MONITO,
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software can read all incoming data supplied by the monitor function."]
            ENABLED_THE_MONITOR,
        }
        impl MONCLKSTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONCLKSTRR::DISABLED_THE_MONITO => false,
                    MONCLKSTRR::ENABLED_THE_MONITOR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONCLKSTRR {
                match value {
                    false => MONCLKSTRR::DISABLED_THE_MONITO,
                    true => MONCLKSTRR::ENABLED_THE_MONITOR,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_MONITO`"]
            #[inline(always)]
            pub fn is_disabled_the_monito(&self) -> bool {
                *self == MONCLKSTRR::DISABLED_THE_MONITO
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_MONITOR`"]
            #[inline(always)]
            pub fn is_enabled_the_monitor(&self) -> bool {
                *self == MONCLKSTRR::ENABLED_THE_MONITOR
            }
        }
        #[doc = "Values that can be written to the field `MSTEN`"]
        pub enum MSTENW {
            #[doc = "Disabled. The I2C Master function is disabled."]
            DISABLED_THE_I2C_MA,
            #[doc = "Enabled. The I2C Master function is enabled."]
            ENABLED_THE_I2C_MAS,
        }
        impl MSTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTENW::DISABLED_THE_I2C_MA => false,
                    MSTENW::ENABLED_THE_I2C_MAS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C Master function is disabled."]
            #[inline(always)]
            pub fn disabled_the_i2c_ma(self) -> &'a mut W {
                self.variant(MSTENW::DISABLED_THE_I2C_MA)
            }
            #[doc = "Enabled. The I2C Master function is enabled."]
            #[inline(always)]
            pub fn enabled_the_i2c_mas(self) -> &'a mut W {
                self.variant(MSTENW::ENABLED_THE_I2C_MAS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVEN`"]
        pub enum SLVENW {
            #[doc = "Disabled. The I2C slave function is disabled."]
            DISABLED_THE_I2C_SL,
            #[doc = "Enabled. The I2C slave function is enabled."]
            ENABLED_THE_I2C_SLA,
        }
        impl SLVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVENW::DISABLED_THE_I2C_SL => false,
                    SLVENW::ENABLED_THE_I2C_SLA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C slave function is disabled."]
            #[inline(always)]
            pub fn disabled_the_i2c_sl(self) -> &'a mut W {
                self.variant(SLVENW::DISABLED_THE_I2C_SL)
            }
            #[doc = "Enabled. The I2C slave function is enabled."]
            #[inline(always)]
            pub fn enabled_the_i2c_sla(self) -> &'a mut W {
                self.variant(SLVENW::ENABLED_THE_I2C_SLA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONEN`"]
        pub enum MONENW {
            #[doc = "Disabled. The I2C monitor function is disabled."]
            DISABLED_THE_I2C_MO,
            #[doc = "Enabled. The I2C monitor function is enabled."]
            ENABLED_THE_I2C_MON,
        }
        impl MONENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONENW::DISABLED_THE_I2C_MO => false,
                    MONENW::ENABLED_THE_I2C_MON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The I2C monitor function is disabled."]
            #[inline(always)]
            pub fn disabled_the_i2c_mo(self) -> &'a mut W {
                self.variant(MONENW::DISABLED_THE_I2C_MO)
            }
            #[doc = "Enabled. The I2C monitor function is enabled."]
            #[inline(always)]
            pub fn enabled_the_i2c_mon(self) -> &'a mut W {
                self.variant(MONENW::ENABLED_THE_I2C_MON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TIMEOUTEN`"]
        pub enum TIMEOUTENW {
            #[doc = "Disabled. Time-out function is disabled."]
            DISABLED_TIME_OUT_F,
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one timeout will be used in a system."]
            ENABLED_TIME_OUT_FU,
        }
        impl TIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIMEOUTENW::DISABLED_TIME_OUT_F => false,
                    TIMEOUTENW::ENABLED_TIME_OUT_FU => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. Time-out function is disabled."]
            #[inline(always)]
            pub fn disabled_time_out_f(self) -> &'a mut W {
                self.variant(TIMEOUTENW::DISABLED_TIME_OUT_F)
            }
            #[doc = "Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one timeout will be used in a system."]
            #[inline(always)]
            pub fn enabled_time_out_fu(self) -> &'a mut W {
                self.variant(TIMEOUTENW::ENABLED_TIME_OUT_FU)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONCLKSTR`"]
        pub enum MONCLKSTRW {
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            DISABLED_THE_MONITO,
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software can read all incoming data supplied by the monitor function."]
            ENABLED_THE_MONITOR,
        }
        impl MONCLKSTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONCLKSTRW::DISABLED_THE_MONITO => false,
                    MONCLKSTRW::ENABLED_THE_MONITOR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONCLKSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONCLKSTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONCLKSTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The monitor function will not perform clock stretching. Software may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical."]
            #[inline(always)]
            pub fn disabled_the_monito(self) -> &'a mut W {
                self.variant(MONCLKSTRW::DISABLED_THE_MONITO)
            }
            #[doc = "Enabled. The monitor function will perform clock stretching in order to ensure that software can read all incoming data supplied by the monitor function."]
            #[inline(always)]
            pub fn enabled_the_monitor(self) -> &'a mut W {
                self.variant(MONCLKSTRW::ENABLED_THE_MONITOR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset."]
            #[inline(always)]
            pub fn msten(&self) -> MSTENR {
                MSTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset."]
            #[inline(always)]
            pub fn slven(&self) -> SLVENR {
                SLVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset."]
            #[inline(always)]
            pub fn monen(&self) -> MONENR {
                MONENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - I2C bus Time-out Enable. When disabled, timeout flags will be automatically cleared."]
            #[inline(always)]
            pub fn timeouten(&self) -> TIMEOUTENR {
                TIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Monitor function Clock Stretching."]
            #[inline(always)]
            pub fn monclkstr(&self) -> MONCLKSTRR {
                MONCLKSTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset."]
            #[inline(always)]
            pub fn msten(&mut self) -> _MSTENW {
                _MSTENW { w: self }
            }
            #[doc = "Bit 1 - Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset."]
            #[inline(always)]
            pub fn slven(&mut self) -> _SLVENW {
                _SLVENW { w: self }
            }
            #[doc = "Bit 2 - Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset."]
            #[inline(always)]
            pub fn monen(&mut self) -> _MONENW {
                _MONENW { w: self }
            }
            #[doc = "Bit 3 - I2C bus Time-out Enable. When disabled, timeout flags will be automatically cleared."]
            #[inline(always)]
            pub fn timeouten(&mut self) -> _TIMEOUTENW {
                _TIMEOUTENW { w: self }
            }
            #[doc = "Bit 4 - Monitor function Clock Stretching."]
            #[inline(always)]
            pub fn monclkstr(&mut self) -> _MONCLKSTRW {
                _MONCLKSTRW { w: self }
            }
        }
    }
    #[doc = "Status register for Master, Slave, and Monitor functions."]
    pub struct STAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Status register for Master, Slave, and Monitor functions."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTPENDING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTPENDINGR {
            #[doc = "No service needed. The Master function does not currently need service."]
            NO_SERVICE_NEEDED_T,
            #[doc = "Service needed. The Master function needs service. Information on what is needed can be found in the adjacent MSTSTATE field."]
            SERVICE_NEEDED_THE_,
        }
        impl MSTPENDINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTPENDINGR::NO_SERVICE_NEEDED_T => false,
                    MSTPENDINGR::SERVICE_NEEDED_THE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTPENDINGR {
                match value {
                    false => MSTPENDINGR::NO_SERVICE_NEEDED_T,
                    true => MSTPENDINGR::SERVICE_NEEDED_THE_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_SERVICE_NEEDED_T`"]
            #[inline(always)]
            pub fn is_no_service_needed_t(&self) -> bool {
                *self == MSTPENDINGR::NO_SERVICE_NEEDED_T
            }
            #[doc = "Checks if the value of the field is `SERVICE_NEEDED_THE_`"]
            #[inline(always)]
            pub fn is_service_needed_the_(&self) -> bool {
                *self == MSTPENDINGR::SERVICE_NEEDED_THE_
            }
        }
        #[doc = "Possible values of the field `MSTSTATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTATER {
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            IDLE_THE_MASTER_FUN,
            #[doc = "Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            RECEIVE_READY_RECEI,
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            TRANSMIT_READY_DATA,
            #[doc = "Address. Slave Nacked address."]
            ADDRESS_SLAVE_NACKE,
            #[doc = "Data. Slave Nacked transmitted data."]
            DATA_SLAVE_NACKED_T,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MSTSTATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSTATER::IDLE_THE_MASTER_FUN => 0,
                    MSTSTATER::RECEIVE_READY_RECEI => 1,
                    MSTSTATER::TRANSMIT_READY_DATA => 2,
                    MSTSTATER::ADDRESS_SLAVE_NACKE => 3,
                    MSTSTATER::DATA_SLAVE_NACKED_T => 4,
                    MSTSTATER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MSTSTATER {
                match value {
                    0 => MSTSTATER::IDLE_THE_MASTER_FUN,
                    1 => MSTSTATER::RECEIVE_READY_RECEI,
                    2 => MSTSTATER::TRANSMIT_READY_DATA,
                    3 => MSTSTATER::ADDRESS_SLAVE_NACKE,
                    4 => MSTSTATER::DATA_SLAVE_NACKED_T,
                    i => MSTSTATER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `IDLE_THE_MASTER_FUN`"]
            #[inline(always)]
            pub fn is_idle_the_master_fun(&self) -> bool {
                *self == MSTSTATER::IDLE_THE_MASTER_FUN
            }
            #[doc = "Checks if the value of the field is `RECEIVE_READY_RECEI`"]
            #[inline(always)]
            pub fn is_receive_ready_recei(&self) -> bool {
                *self == MSTSTATER::RECEIVE_READY_RECEI
            }
            #[doc = "Checks if the value of the field is `TRANSMIT_READY_DATA`"]
            #[inline(always)]
            pub fn is_transmit_ready_data(&self) -> bool {
                *self == MSTSTATER::TRANSMIT_READY_DATA
            }
            #[doc = "Checks if the value of the field is `ADDRESS_SLAVE_NACKE`"]
            #[inline(always)]
            pub fn is_address_slave_nacke(&self) -> bool {
                *self == MSTSTATER::ADDRESS_SLAVE_NACKE
            }
            #[doc = "Checks if the value of the field is `DATA_SLAVE_NACKED_T`"]
            #[inline(always)]
            pub fn is_data_slave_nacked_t(&self) -> bool {
                *self == MSTSTATER::DATA_SLAVE_NACKED_T
            }
        }
        #[doc = "Possible values of the field `MSTARBLOSS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTARBLOSSR {
            #[doc = "No loss. No Arbitration Loss has occurred."]
            NO_LOSS_NO_ARBITRAT,
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            ARBITRATION_LOSS_TH,
        }
        impl MSTARBLOSSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTARBLOSSR::NO_LOSS_NO_ARBITRAT => false,
                    MSTARBLOSSR::ARBITRATION_LOSS_TH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTARBLOSSR {
                match value {
                    false => MSTARBLOSSR::NO_LOSS_NO_ARBITRAT,
                    true => MSTARBLOSSR::ARBITRATION_LOSS_TH,
                }
            }
            #[doc = "Checks if the value of the field is `NO_LOSS_NO_ARBITRAT`"]
            #[inline(always)]
            pub fn is_no_loss_no_arbitrat(&self) -> bool {
                *self == MSTARBLOSSR::NO_LOSS_NO_ARBITRAT
            }
            #[doc = "Checks if the value of the field is `ARBITRATION_LOSS_TH`"]
            #[inline(always)]
            pub fn is_arbitration_loss_th(&self) -> bool {
                *self == MSTARBLOSSR::ARBITRATION_LOSS_TH
            }
        }
        #[doc = "Possible values of the field `MSTSTSTPERR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTSTPERRR {
            #[doc = "No Start/Stop Error has occurred."]
            NO_STARTSTOP_ERROR_,
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            STARTSTOP_ERROR_HAS,
        }
        impl MSTSTSTPERRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTSTPERRR::NO_STARTSTOP_ERROR_ => false,
                    MSTSTSTPERRR::STARTSTOP_ERROR_HAS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTSTSTPERRR {
                match value {
                    false => MSTSTSTPERRR::NO_STARTSTOP_ERROR_,
                    true => MSTSTSTPERRR::STARTSTOP_ERROR_HAS,
                }
            }
            #[doc = "Checks if the value of the field is `NO_STARTSTOP_ERROR_`"]
            #[inline(always)]
            pub fn is_no_startstop_error_(&self) -> bool {
                *self == MSTSTSTPERRR::NO_STARTSTOP_ERROR_
            }
            #[doc = "Checks if the value of the field is `STARTSTOP_ERROR_HAS`"]
            #[inline(always)]
            pub fn is_startstop_error_has(&self) -> bool {
                *self == MSTSTSTPERRR::STARTSTOP_ERROR_HAS
            }
        }
        #[doc = "Possible values of the field `SLVPENDING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVPENDINGR {
            #[doc = "No service needed. The Slave function does not currently need service."]
            NO_SERVICE_NEEDED_T,
            #[doc = "Service needed. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            SERVICE_NEEDED_THE_,
        }
        impl SLVPENDINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVPENDINGR::NO_SERVICE_NEEDED_T => false,
                    SLVPENDINGR::SERVICE_NEEDED_THE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVPENDINGR {
                match value {
                    false => SLVPENDINGR::NO_SERVICE_NEEDED_T,
                    true => SLVPENDINGR::SERVICE_NEEDED_THE_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_SERVICE_NEEDED_T`"]
            #[inline(always)]
            pub fn is_no_service_needed_t(&self) -> bool {
                *self == SLVPENDINGR::NO_SERVICE_NEEDED_T
            }
            #[doc = "Checks if the value of the field is `SERVICE_NEEDED_THE_`"]
            #[inline(always)]
            pub fn is_service_needed_the_(&self) -> bool {
                *self == SLVPENDINGR::SERVICE_NEEDED_THE_
            }
        }
        #[doc = "Possible values of the field `SLVSTATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVSTATER {
            #[doc = "Received. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            RECEIVED_ADDRESS_PL,
            #[doc = "Data available. Received data is available (Slave Receiver mode)."]
            DATA_AVAILABLE_RECE,
            #[doc = "Data ready for transmit. Data can be transmitted (Slave Transmitter mode)."]
            DATA_READY_FOR_TRANS,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl SLVSTATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLVSTATER::RECEIVED_ADDRESS_PL => 0,
                    SLVSTATER::DATA_AVAILABLE_RECE => 1,
                    SLVSTATER::DATA_READY_FOR_TRANS => 2,
                    SLVSTATER::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SLVSTATER {
                match value {
                    0 => SLVSTATER::RECEIVED_ADDRESS_PL,
                    1 => SLVSTATER::DATA_AVAILABLE_RECE,
                    2 => SLVSTATER::DATA_READY_FOR_TRANS,
                    3 => SLVSTATER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `RECEIVED_ADDRESS_PL`"]
            #[inline(always)]
            pub fn is_received_address_pl(&self) -> bool {
                *self == SLVSTATER::RECEIVED_ADDRESS_PL
            }
            #[doc = "Checks if the value of the field is `DATA_AVAILABLE_RECE`"]
            #[inline(always)]
            pub fn is_data_available_rece(&self) -> bool {
                *self == SLVSTATER::DATA_AVAILABLE_RECE
            }
            #[doc = "Checks if the value of the field is `DATA_READY_FOR_TRANS`"]
            #[inline(always)]
            pub fn is_data_ready_for_trans(&self) -> bool {
                *self == SLVSTATER::DATA_READY_FOR_TRANS
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == SLVSTATER::RESERVED_
            }
        }
        #[doc = "Possible values of the field `SLVNOTSTR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNOTSTRR {
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            STRETCHING_THE_SLAV,
            #[doc = "Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            NOT_STRETCHING_THE_,
        }
        impl SLVNOTSTRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNOTSTRR::STRETCHING_THE_SLAV => false,
                    SLVNOTSTRR::NOT_STRETCHING_THE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVNOTSTRR {
                match value {
                    false => SLVNOTSTRR::STRETCHING_THE_SLAV,
                    true => SLVNOTSTRR::NOT_STRETCHING_THE_,
                }
            }
            #[doc = "Checks if the value of the field is `STRETCHING_THE_SLAV`"]
            #[inline(always)]
            pub fn is_stretching_the_slav(&self) -> bool {
                *self == SLVNOTSTRR::STRETCHING_THE_SLAV
            }
            #[doc = "Checks if the value of the field is `NOT_STRETCHING_THE_`"]
            #[inline(always)]
            pub fn is_not_stretching_the_(&self) -> bool {
                *self == SLVNOTSTRR::NOT_STRETCHING_THE_
            }
        }
        #[doc = "Possible values of the field `SLVIDX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVIDXR {
            #[doc = "Slave address 0 was matched."]
            SLAVE_ADDRESS_0_WAS_,
            #[doc = "Slave address 1 was matched."]
            SLAVE_ADDRESS_1_WAS_,
            #[doc = "Slave address 2 was matched."]
            SLAVE_ADDRESS_2_WAS_,
            #[doc = "Slave address 3 was matched."]
            SLAVE_ADDRESS_3_WAS_,
        }
        impl SLVIDXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SLVIDXR::SLAVE_ADDRESS_0_WAS_ => 0,
                    SLVIDXR::SLAVE_ADDRESS_1_WAS_ => 1,
                    SLVIDXR::SLAVE_ADDRESS_2_WAS_ => 2,
                    SLVIDXR::SLAVE_ADDRESS_3_WAS_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SLVIDXR {
                match value {
                    0 => SLVIDXR::SLAVE_ADDRESS_0_WAS_,
                    1 => SLVIDXR::SLAVE_ADDRESS_1_WAS_,
                    2 => SLVIDXR::SLAVE_ADDRESS_2_WAS_,
                    3 => SLVIDXR::SLAVE_ADDRESS_3_WAS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_0_WAS_`"]
            #[inline(always)]
            pub fn is_slave_address_0_was_(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_0_WAS_
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_1_WAS_`"]
            #[inline(always)]
            pub fn is_slave_address_1_was_(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_1_WAS_
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_2_WAS_`"]
            #[inline(always)]
            pub fn is_slave_address_2_was_(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_2_WAS_
            }
            #[doc = "Checks if the value of the field is `SLAVE_ADDRESS_3_WAS_`"]
            #[inline(always)]
            pub fn is_slave_address_3_was_(&self) -> bool {
                *self == SLVIDXR::SLAVE_ADDRESS_3_WAS_
            }
        }
        #[doc = "Possible values of the field `SLVSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVSELR {
            #[doc = "Not selected. The Slave function is not currently selected."]
            NOT_SELECTED_THE_SL,
            #[doc = "Selected. The Slave function is currently selected."]
            SELECTED_THE_SLAVE_,
        }
        impl SLVSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVSELR::NOT_SELECTED_THE_SL => false,
                    SLVSELR::SELECTED_THE_SLAVE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVSELR {
                match value {
                    false => SLVSELR::NOT_SELECTED_THE_SL,
                    true => SLVSELR::SELECTED_THE_SLAVE_,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_SELECTED_THE_SL`"]
            #[inline(always)]
            pub fn is_not_selected_the_sl(&self) -> bool {
                *self == SLVSELR::NOT_SELECTED_THE_SL
            }
            #[doc = "Checks if the value of the field is `SELECTED_THE_SLAVE_`"]
            #[inline(always)]
            pub fn is_selected_the_slave_(&self) -> bool {
                *self == SLVSELR::SELECTED_THE_SLAVE_
            }
        }
        #[doc = "Possible values of the field `SLVDESEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVDESELR {
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            NOT_DESELECTED_THE_,
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            DESELECTED_THE_SLAV,
        }
        impl SLVDESELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVDESELR::NOT_DESELECTED_THE_ => false,
                    SLVDESELR::DESELECTED_THE_SLAV => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVDESELR {
                match value {
                    false => SLVDESELR::NOT_DESELECTED_THE_,
                    true => SLVDESELR::DESELECTED_THE_SLAV,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_DESELECTED_THE_`"]
            #[inline(always)]
            pub fn is_not_deselected_the_(&self) -> bool {
                *self == SLVDESELR::NOT_DESELECTED_THE_
            }
            #[doc = "Checks if the value of the field is `DESELECTED_THE_SLAV`"]
            #[inline(always)]
            pub fn is_deselected_the_slav(&self) -> bool {
                *self == SLVDESELR::DESELECTED_THE_SLAV
            }
        }
        #[doc = "Possible values of the field `MONRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRDYR {
            #[doc = "No data. The Monitor function does not currently have data available."]
            NO_DATA_THE_MONITOR,
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            DATA_WAITING_THE_MO,
        }
        impl MONRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRDYR::NO_DATA_THE_MONITOR => false,
                    MONRDYR::DATA_WAITING_THE_MO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONRDYR {
                match value {
                    false => MONRDYR::NO_DATA_THE_MONITOR,
                    true => MONRDYR::DATA_WAITING_THE_MO,
                }
            }
            #[doc = "Checks if the value of the field is `NO_DATA_THE_MONITOR`"]
            #[inline(always)]
            pub fn is_no_data_the_monitor(&self) -> bool {
                *self == MONRDYR::NO_DATA_THE_MONITOR
            }
            #[doc = "Checks if the value of the field is `DATA_WAITING_THE_MO`"]
            #[inline(always)]
            pub fn is_data_waiting_the_mo(&self) -> bool {
                *self == MONRDYR::DATA_WAITING_THE_MO
            }
        }
        #[doc = "Possible values of the field `MONOV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONOVR {
            #[doc = "No overrun. Monitor data has not overrun."]
            NO_OVERRUN_MONITOR_,
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            OVERRUN_A_MONITOR_D,
        }
        impl MONOVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONOVR::NO_OVERRUN_MONITOR_ => false,
                    MONOVR::OVERRUN_A_MONITOR_D => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONOVR {
                match value {
                    false => MONOVR::NO_OVERRUN_MONITOR_,
                    true => MONOVR::OVERRUN_A_MONITOR_D,
                }
            }
            #[doc = "Checks if the value of the field is `NO_OVERRUN_MONITOR_`"]
            #[inline(always)]
            pub fn is_no_overrun_monitor_(&self) -> bool {
                *self == MONOVR::NO_OVERRUN_MONITOR_
            }
            #[doc = "Checks if the value of the field is `OVERRUN_A_MONITOR_D`"]
            #[inline(always)]
            pub fn is_overrun_a_monitor_d(&self) -> bool {
                *self == MONOVR::OVERRUN_A_MONITOR_D
            }
        }
        #[doc = "Possible values of the field `MONACTIVE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONACTIVER {
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            INACTIVE_THE_MONITO,
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            ACTIVE_THE_MONITOR_,
        }
        impl MONACTIVER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONACTIVER::INACTIVE_THE_MONITO => false,
                    MONACTIVER::ACTIVE_THE_MONITOR_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONACTIVER {
                match value {
                    false => MONACTIVER::INACTIVE_THE_MONITO,
                    true => MONACTIVER::ACTIVE_THE_MONITOR_,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_THE_MONITO`"]
            #[inline(always)]
            pub fn is_inactive_the_monito(&self) -> bool {
                *self == MONACTIVER::INACTIVE_THE_MONITO
            }
            #[doc = "Checks if the value of the field is `ACTIVE_THE_MONITOR_`"]
            #[inline(always)]
            pub fn is_active_the_monitor_(&self) -> bool {
                *self == MONACTIVER::ACTIVE_THE_MONITOR_
            }
        }
        #[doc = "Possible values of the field `MONIDLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONIDLER {
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            NOT_IDLE_THE_I2C_BU,
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            IDLE_THE_I2C_BUS_HA,
        }
        impl MONIDLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONIDLER::NOT_IDLE_THE_I2C_BU => false,
                    MONIDLER::IDLE_THE_I2C_BUS_HA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONIDLER {
                match value {
                    false => MONIDLER::NOT_IDLE_THE_I2C_BU,
                    true => MONIDLER::IDLE_THE_I2C_BUS_HA,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_IDLE_THE_I2C_BU`"]
            #[inline(always)]
            pub fn is_not_idle_the_i2c_bu(&self) -> bool {
                *self == MONIDLER::NOT_IDLE_THE_I2C_BU
            }
            #[doc = "Checks if the value of the field is `IDLE_THE_I2C_BUS_HA`"]
            #[inline(always)]
            pub fn is_idle_the_i2c_bus_ha(&self) -> bool {
                *self == MONIDLER::IDLE_THE_I2C_BUS_HA
            }
        }
        #[doc = "Possible values of the field `EVENTTIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVENTTIMEOUTR {
            #[doc = "No time-out. I2C bus events have not caused a timeout."]
            NO_TIME_OUT_I2C_BUS,
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C Timeout register."]
            EVENT_TIME_OUT_THE_,
        }
        impl EVENTTIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EVENTTIMEOUTR::NO_TIME_OUT_I2C_BUS => false,
                    EVENTTIMEOUTR::EVENT_TIME_OUT_THE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EVENTTIMEOUTR {
                match value {
                    false => EVENTTIMEOUTR::NO_TIME_OUT_I2C_BUS,
                    true => EVENTTIMEOUTR::EVENT_TIME_OUT_THE_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT_I2C_BUS`"]
            #[inline(always)]
            pub fn is_no_time_out_i2c_bus(&self) -> bool {
                *self == EVENTTIMEOUTR::NO_TIME_OUT_I2C_BUS
            }
            #[doc = "Checks if the value of the field is `EVENT_TIME_OUT_THE_`"]
            #[inline(always)]
            pub fn is_event_time_out_the_(&self) -> bool {
                *self == EVENTTIMEOUTR::EVENT_TIME_OUT_THE_
            }
        }
        #[doc = "Possible values of the field `SCLTIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCLTIMEOUTR {
            #[doc = "No time-out. SCL low time has not caused a timeout."]
            NO_TIME_OUT_SCL_LOW,
            #[doc = "Time-out. SCL low time has caused a timeout."]
            TIME_OUT_SCL_LOW_TI,
        }
        impl SCLTIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCLTIMEOUTR::NO_TIME_OUT_SCL_LOW => false,
                    SCLTIMEOUTR::TIME_OUT_SCL_LOW_TI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCLTIMEOUTR {
                match value {
                    false => SCLTIMEOUTR::NO_TIME_OUT_SCL_LOW,
                    true => SCLTIMEOUTR::TIME_OUT_SCL_LOW_TI,
                }
            }
            #[doc = "Checks if the value of the field is `NO_TIME_OUT_SCL_LOW`"]
            #[inline(always)]
            pub fn is_no_time_out_scl_low(&self) -> bool {
                *self == SCLTIMEOUTR::NO_TIME_OUT_SCL_LOW
            }
            #[doc = "Checks if the value of the field is `TIME_OUT_SCL_LOW_TI`"]
            #[inline(always)]
            pub fn is_time_out_scl_low_ti(&self) -> bool {
                *self == SCLTIMEOUTR::TIME_OUT_SCL_LOW_TI
            }
        }
        #[doc = "Values that can be written to the field `MSTPENDING`"]
        pub enum MSTPENDINGW {
            #[doc = "No service needed. The Master function does not currently need service."]
            NO_SERVICE_NEEDED_T,
            #[doc = "Service needed. The Master function needs service. Information on what is needed can be found in the adjacent MSTSTATE field."]
            SERVICE_NEEDED_THE_,
        }
        impl MSTPENDINGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTPENDINGW::NO_SERVICE_NEEDED_T => false,
                    MSTPENDINGW::SERVICE_NEEDED_THE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTPENDINGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No service needed. The Master function does not currently need service."]
            #[inline(always)]
            pub fn no_service_needed_t(self) -> &'a mut W {
                self.variant(MSTPENDINGW::NO_SERVICE_NEEDED_T)
            }
            #[doc = "Service needed. The Master function needs service. Information on what is needed can be found in the adjacent MSTSTATE field."]
            #[inline(always)]
            pub fn service_needed_the_(self) -> &'a mut W {
                self.variant(MSTPENDINGW::SERVICE_NEEDED_THE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTATE`"]
        pub enum MSTSTATEW {
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            IDLE_THE_MASTER_FUN,
            #[doc = "Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            RECEIVE_READY_RECEI,
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            TRANSMIT_READY_DATA,
            #[doc = "Address. Slave Nacked address."]
            ADDRESS_SLAVE_NACKE,
            #[doc = "Data. Slave Nacked transmitted data."]
            DATA_SLAVE_NACKED_T,
        }
        impl MSTSTATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSTATEW::IDLE_THE_MASTER_FUN => 0,
                    MSTSTATEW::RECEIVE_READY_RECEI => 1,
                    MSTSTATEW::TRANSMIT_READY_DATA => 2,
                    MSTSTATEW::ADDRESS_SLAVE_NACKE => 3,
                    MSTSTATEW::DATA_SLAVE_NACKED_T => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSTATEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Idle. The Master function is available to be used for a new transaction."]
            #[inline(always)]
            pub fn idle_the_master_fun(self) -> &'a mut W {
                self.variant(MSTSTATEW::IDLE_THE_MASTER_FUN)
            }
            #[doc = "Receive ready. Received data available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave."]
            #[inline(always)]
            pub fn receive_ready_recei(self) -> &'a mut W {
                self.variant(MSTSTATEW::RECEIVE_READY_RECEI)
            }
            #[doc = "Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave."]
            #[inline(always)]
            pub fn transmit_ready_data(self) -> &'a mut W {
                self.variant(MSTSTATEW::TRANSMIT_READY_DATA)
            }
            #[doc = "Address. Slave Nacked address."]
            #[inline(always)]
            pub fn address_slave_nacke(self) -> &'a mut W {
                self.variant(MSTSTATEW::ADDRESS_SLAVE_NACKE)
            }
            #[doc = "Data. Slave Nacked transmitted data."]
            #[inline(always)]
            pub fn data_slave_nacked_t(self) -> &'a mut W {
                self.variant(MSTSTATEW::DATA_SLAVE_NACKED_T)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTARBLOSS`"]
        pub enum MSTARBLOSSW {
            #[doc = "No loss. No Arbitration Loss has occurred."]
            NO_LOSS_NO_ARBITRAT,
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            ARBITRATION_LOSS_TH,
        }
        impl MSTARBLOSSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTARBLOSSW::NO_LOSS_NO_ARBITRAT => false,
                    MSTARBLOSSW::ARBITRATION_LOSS_TH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTARBLOSSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No loss. No Arbitration Loss has occurred."]
            #[inline(always)]
            pub fn no_loss_no_arbitrat(self) -> &'a mut W {
                self.variant(MSTARBLOSSW::NO_LOSS_NO_ARBITRAT)
            }
            #[doc = "Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle."]
            #[inline(always)]
            pub fn arbitration_loss_th(self) -> &'a mut W {
                self.variant(MSTARBLOSSW::ARBITRATION_LOSS_TH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTSTPERR`"]
        pub enum MSTSTSTPERRW {
            #[doc = "No Start/Stop Error has occurred."]
            NO_STARTSTOP_ERROR_,
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            STARTSTOP_ERROR_HAS,
        }
        impl MSTSTSTPERRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTSTPERRW::NO_STARTSTOP_ERROR_ => false,
                    MSTSTSTPERRW::STARTSTOP_ERROR_HAS => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSTSTPERRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No Start/Stop Error has occurred."]
            #[inline(always)]
            pub fn no_startstop_error_(self) -> &'a mut W {
                self.variant(MSTSTSTPERRW::NO_STARTSTOP_ERROR_)
            }
            #[doc = "Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled."]
            #[inline(always)]
            pub fn startstop_error_has(self) -> &'a mut W {
                self.variant(MSTSTSTPERRW::STARTSTOP_ERROR_HAS)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVPENDING`"]
        pub enum SLVPENDINGW {
            #[doc = "No service needed. The Slave function does not currently need service."]
            NO_SERVICE_NEEDED_T,
            #[doc = "Service needed. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            SERVICE_NEEDED_THE_,
        }
        impl SLVPENDINGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVPENDINGW::NO_SERVICE_NEEDED_T => false,
                    SLVPENDINGW::SERVICE_NEEDED_THE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVPENDINGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No service needed. The Slave function does not currently need service."]
            #[inline(always)]
            pub fn no_service_needed_t(self) -> &'a mut W {
                self.variant(SLVPENDINGW::NO_SERVICE_NEEDED_T)
            }
            #[doc = "Service needed. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field."]
            #[inline(always)]
            pub fn service_needed_the_(self) -> &'a mut W {
                self.variant(SLVPENDINGW::SERVICE_NEEDED_THE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVSTATE`"]
        pub enum SLVSTATEW {
            #[doc = "Received. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            RECEIVED_ADDRESS_PL,
            #[doc = "Data available. Received data is available (Slave Receiver mode)."]
            DATA_AVAILABLE_RECE,
            #[doc = "Data ready for transmit. Data can be transmitted (Slave Transmitter mode)."]
            DATA_READY_FOR_TRANS,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl SLVSTATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLVSTATEW::RECEIVED_ADDRESS_PL => 0,
                    SLVSTATEW::DATA_AVAILABLE_RECE => 1,
                    SLVSTATEW::DATA_READY_FOR_TRANS => 2,
                    SLVSTATEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVSTATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVSTATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVSTATEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Received. Address plus R/W received. At least one of the four slave addresses has been matched by hardware."]
            #[inline(always)]
            pub fn received_address_pl(self) -> &'a mut W {
                self.variant(SLVSTATEW::RECEIVED_ADDRESS_PL)
            }
            #[doc = "Data available. Received data is available (Slave Receiver mode)."]
            #[inline(always)]
            pub fn data_available_rece(self) -> &'a mut W {
                self.variant(SLVSTATEW::DATA_AVAILABLE_RECE)
            }
            #[doc = "Data ready for transmit. Data can be transmitted (Slave Transmitter mode)."]
            #[inline(always)]
            pub fn data_ready_for_trans(self) -> &'a mut W {
                self.variant(SLVSTATEW::DATA_READY_FOR_TRANS)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(SLVSTATEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVNOTSTR`"]
        pub enum SLVNOTSTRW {
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            STRETCHING_THE_SLAV,
            #[doc = "Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            NOT_STRETCHING_THE_,
        }
        impl SLVNOTSTRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNOTSTRW::STRETCHING_THE_SLAV => false,
                    SLVNOTSTRW::NOT_STRETCHING_THE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVNOTSTRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time."]
            #[inline(always)]
            pub fn stretching_the_slav(self) -> &'a mut W {
                self.variant(SLVNOTSTRW::STRETCHING_THE_SLAV)
            }
            #[doc = "Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time."]
            #[inline(always)]
            pub fn not_stretching_the_(self) -> &'a mut W {
                self.variant(SLVNOTSTRW::NOT_STRETCHING_THE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVIDX`"]
        pub enum SLVIDXW {
            #[doc = "Slave address 0 was matched."]
            SLAVE_ADDRESS_0_WAS_,
            #[doc = "Slave address 1 was matched."]
            SLAVE_ADDRESS_1_WAS_,
            #[doc = "Slave address 2 was matched."]
            SLAVE_ADDRESS_2_WAS_,
            #[doc = "Slave address 3 was matched."]
            SLAVE_ADDRESS_3_WAS_,
        }
        impl SLVIDXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SLVIDXW::SLAVE_ADDRESS_0_WAS_ => 0,
                    SLVIDXW::SLAVE_ADDRESS_1_WAS_ => 1,
                    SLVIDXW::SLAVE_ADDRESS_2_WAS_ => 2,
                    SLVIDXW::SLAVE_ADDRESS_3_WAS_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVIDXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVIDXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVIDXW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Slave address 0 was matched."]
            #[inline(always)]
            pub fn slave_address_0_was_(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_0_WAS_)
            }
            #[doc = "Slave address 1 was matched."]
            #[inline(always)]
            pub fn slave_address_1_was_(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_1_WAS_)
            }
            #[doc = "Slave address 2 was matched."]
            #[inline(always)]
            pub fn slave_address_2_was_(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_2_WAS_)
            }
            #[doc = "Slave address 3 was matched."]
            #[inline(always)]
            pub fn slave_address_3_was_(self) -> &'a mut W {
                self.variant(SLVIDXW::SLAVE_ADDRESS_3_WAS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVSEL`"]
        pub enum SLVSELW {
            #[doc = "Not selected. The Slave function is not currently selected."]
            NOT_SELECTED_THE_SL,
            #[doc = "Selected. The Slave function is currently selected."]
            SELECTED_THE_SLAVE_,
        }
        impl SLVSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVSELW::NOT_SELECTED_THE_SL => false,
                    SLVSELW::SELECTED_THE_SLAVE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not selected. The Slave function is not currently selected."]
            #[inline(always)]
            pub fn not_selected_the_sl(self) -> &'a mut W {
                self.variant(SLVSELW::NOT_SELECTED_THE_SL)
            }
            #[doc = "Selected. The Slave function is currently selected."]
            #[inline(always)]
            pub fn selected_the_slave_(self) -> &'a mut W {
                self.variant(SLVSELW::SELECTED_THE_SLAVE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVDESEL`"]
        pub enum SLVDESELW {
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            NOT_DESELECTED_THE_,
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            DESELECTED_THE_SLAV,
        }
        impl SLVDESELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVDESELW::NOT_DESELECTED_THE_ => false,
                    SLVDESELW::DESELECTED_THE_SLAV => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVDESELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag."]
            #[inline(always)]
            pub fn not_deselected_the_(self) -> &'a mut W {
                self.variant(SLVDESELW::NOT_DESELECTED_THE_)
            }
            #[doc = "Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs."]
            #[inline(always)]
            pub fn deselected_the_slav(self) -> &'a mut W {
                self.variant(SLVDESELW::DESELECTED_THE_SLAV)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONRDY`"]
        pub enum MONRDYW {
            #[doc = "No data. The Monitor function does not currently have data available."]
            NO_DATA_THE_MONITOR,
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            DATA_WAITING_THE_MO,
        }
        impl MONRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONRDYW::NO_DATA_THE_MONITOR => false,
                    MONRDYW::DATA_WAITING_THE_MO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No data. The Monitor function does not currently have data available."]
            #[inline(always)]
            pub fn no_data_the_monitor(self) -> &'a mut W {
                self.variant(MONRDYW::NO_DATA_THE_MONITOR)
            }
            #[doc = "Data waiting. The Monitor function has data waiting to be read."]
            #[inline(always)]
            pub fn data_waiting_the_mo(self) -> &'a mut W {
                self.variant(MONRDYW::DATA_WAITING_THE_MO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONOV`"]
        pub enum MONOVW {
            #[doc = "No overrun. Monitor data has not overrun."]
            NO_OVERRUN_MONITOR_,
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            OVERRUN_A_MONITOR_D,
        }
        impl MONOVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONOVW::NO_OVERRUN_MONITOR_ => false,
                    MONOVW::OVERRUN_A_MONITOR_D => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONOVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No overrun. Monitor data has not overrun."]
            #[inline(always)]
            pub fn no_overrun_monitor_(self) -> &'a mut W {
                self.variant(MONOVW::NO_OVERRUN_MONITOR_)
            }
            #[doc = "Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag."]
            #[inline(always)]
            pub fn overrun_a_monitor_d(self) -> &'a mut W {
                self.variant(MONOVW::OVERRUN_A_MONITOR_D)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONACTIVE`"]
        pub enum MONACTIVEW {
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            INACTIVE_THE_MONITO,
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            ACTIVE_THE_MONITOR_,
        }
        impl MONACTIVEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONACTIVEW::INACTIVE_THE_MONITO => false,
                    MONACTIVEW::ACTIVE_THE_MONITOR_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONACTIVEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONACTIVEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONACTIVEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Inactive. The Monitor function considers the I2C bus to be inactive."]
            #[inline(always)]
            pub fn inactive_the_monito(self) -> &'a mut W {
                self.variant(MONACTIVEW::INACTIVE_THE_MONITO)
            }
            #[doc = "Active. The Monitor function considers the I2C bus to be active."]
            #[inline(always)]
            pub fn active_the_monitor_(self) -> &'a mut W {
                self.variant(MONACTIVEW::ACTIVE_THE_MONITOR_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONIDLE`"]
        pub enum MONIDLEW {
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            NOT_IDLE_THE_I2C_BU,
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            IDLE_THE_I2C_BUS_HA,
        }
        impl MONIDLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONIDLEW::NOT_IDLE_THE_I2C_BU => false,
                    MONIDLEW::IDLE_THE_I2C_BUS_HA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONIDLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not idle. The I2C bus is not idle, or this flag has been cleared by software."]
            #[inline(always)]
            pub fn not_idle_the_i2c_bu(self) -> &'a mut W {
                self.variant(MONIDLEW::NOT_IDLE_THE_I2C_BU)
            }
            #[doc = "Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software."]
            #[inline(always)]
            pub fn idle_the_i2c_bus_ha(self) -> &'a mut W {
                self.variant(MONIDLEW::IDLE_THE_I2C_BUS_HA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EVENTTIMEOUT`"]
        pub enum EVENTTIMEOUTW {
            #[doc = "No time-out. I2C bus events have not caused a timeout."]
            NO_TIME_OUT_I2C_BUS,
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C Timeout register."]
            EVENT_TIME_OUT_THE_,
        }
        impl EVENTTIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    EVENTTIMEOUTW::NO_TIME_OUT_I2C_BUS => false,
                    EVENTTIMEOUTW::EVENT_TIME_OUT_THE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EVENTTIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. I2C bus events have not caused a timeout."]
            #[inline(always)]
            pub fn no_time_out_i2c_bus(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTW::NO_TIME_OUT_I2C_BUS)
            }
            #[doc = "Event time-out. The time between I2C bus events has been longer than the time specified by the I2C Timeout register."]
            #[inline(always)]
            pub fn event_time_out_the_(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTW::EVENT_TIME_OUT_THE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCLTIMEOUT`"]
        pub enum SCLTIMEOUTW {
            #[doc = "No time-out. SCL low time has not caused a timeout."]
            NO_TIME_OUT_SCL_LOW,
            #[doc = "Time-out. SCL low time has caused a timeout."]
            TIME_OUT_SCL_LOW_TI,
        }
        impl SCLTIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCLTIMEOUTW::NO_TIME_OUT_SCL_LOW => false,
                    SCLTIMEOUTW::TIME_OUT_SCL_LOW_TI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCLTIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No time-out. SCL low time has not caused a timeout."]
            #[inline(always)]
            pub fn no_time_out_scl_low(self) -> &'a mut W {
                self.variant(SCLTIMEOUTW::NO_TIME_OUT_SCL_LOW)
            }
            #[doc = "Time-out. SCL low time has caused a timeout."]
            #[inline(always)]
            pub fn time_out_scl_low_ti(self) -> &'a mut W {
                self.variant(SCLTIMEOUTW::TIME_OUT_SCL_LOW_TI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending. Indicates whether the Master function needs software service. This flag will cause an interrupt when set if enabled via the INTENSET register. The MSTPENDING flag is automatically cleared when a 1 is written to the MSTCONTINUE bit in the MSTCTL register."]
            #[inline(always)]
            pub fn mstpending(&self) -> MSTPENDINGR {
                MSTPENDINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:3 - Master State code. Each value of this field indicates a specific required service for the Master function. All other values are reserved."]
            #[inline(always)]
            pub fn mststate(&self) -> MSTSTATER {
                MSTSTATER::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline(always)]
            pub fn mstarbloss(&self) -> MSTARBLOSSR {
                MSTARBLOSSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MstContinue."]
            #[inline(always)]
            pub fn mstststperr(&self) -> MSTSTSTPERRR {
                MSTSTSTPERRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Slave Pending. Indicates whether the Slave function needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register."]
            #[inline(always)]
            pub fn slvpending(&self) -> SLVPENDINGR {
                SLVPENDINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 9:10 - Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved."]
            #[inline(always)]
            pub fn slvstate(&self) -> SLVSTATER {
                SLVSTATER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 11 - Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time."]
            #[inline(always)]
            pub fn slvnotstr(&self) -> SLVNOTSTRR {
                SLVNOTSTRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 12:13 - Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here."]
            #[inline(always)]
            pub fn slvidx(&self) -> SLVIDXR {
                SLVIDXR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to Nack a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data."]
            #[inline(always)]
            pub fn slvsel(&self) -> SLVSELR {
                SLVSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn slvdesel(&self) -> SLVDESELR {
                SLVDESELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Monitor Ready. This flag is cleared when the MONRXDAT register is read."]
            #[inline(always)]
            pub fn monrdy(&self) -> MONRDYR {
                MONRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline(always)]
            pub fn monov(&self) -> MONOVR {
                MONOVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop."]
            #[inline(always)]
            pub fn monactive(&self) -> MONACTIVER {
                MONACTIVER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn monidle(&self) -> MONIDLER {
                MONIDLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The case of SCL remaining low longer than TIMEOUT is not reported by this flag, it is reported in by the SCL Time-out flag. The flag is cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn eventtimeout(&self) -> EVENTTIMEOUTR {
                EVENTTIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn scltimeout(&self) -> SCLTIMEOUTR {
                SCLTIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 2049 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending. Indicates whether the Master function needs software service. This flag will cause an interrupt when set if enabled via the INTENSET register. The MSTPENDING flag is automatically cleared when a 1 is written to the MSTCONTINUE bit in the MSTCTL register."]
            #[inline(always)]
            pub fn mstpending(&mut self) -> _MSTPENDINGW {
                _MSTPENDINGW { w: self }
            }
            #[doc = "Bits 1:3 - Master State code. Each value of this field indicates a specific required service for the Master function. All other values are reserved."]
            #[inline(always)]
            pub fn mststate(&mut self) -> _MSTSTATEW {
                _MSTSTATEW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE."]
            #[inline(always)]
            pub fn mstarbloss(&mut self) -> _MSTARBLOSSW {
                _MSTARBLOSSW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MstContinue."]
            #[inline(always)]
            pub fn mstststperr(&mut self) -> _MSTSTSTPERRW {
                _MSTSTSTPERRW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending. Indicates whether the Slave function needs software service. This flag will cause an interrupt when set if enabled via INTENSET. The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register."]
            #[inline(always)]
            pub fn slvpending(&mut self) -> _SLVPENDINGW {
                _SLVPENDINGW { w: self }
            }
            #[doc = "Bits 9:10 - Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved."]
            #[inline(always)]
            pub fn slvstate(&mut self) -> _SLVSTATEW {
                _SLVSTATEW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time."]
            #[inline(always)]
            pub fn slvnotstr(&mut self) -> _SLVNOTSTRW {
                _SLVNOTSTRW { w: self }
            }
            #[doc = "Bits 12:13 - Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here."]
            #[inline(always)]
            pub fn slvidx(&mut self) -> _SLVIDXW {
                _SLVIDXW { w: self }
            }
            #[doc = "Bit 14 - Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to Nack a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data."]
            #[inline(always)]
            pub fn slvsel(&mut self) -> _SLVSELW {
                _SLVSELW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn slvdesel(&mut self) -> _SLVDESELW {
                _SLVDESELW { w: self }
            }
            #[doc = "Bit 16 - Monitor Ready. This flag is cleared when the MONRXDAT register is read."]
            #[inline(always)]
            pub fn monrdy(&mut self) -> _MONRDYW {
                _MONRDYW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline(always)]
            pub fn monov(&mut self) -> _MONOVW {
                _MONOVW { w: self }
            }
            #[doc = "Bit 18 - Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop."]
            #[inline(always)]
            pub fn monactive(&mut self) -> _MONACTIVEW {
                _MONACTIVEW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn monidle(&mut self) -> _MONIDLEW {
                _MONIDLEW { w: self }
            }
            #[doc = "Bit 24 - Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The case of SCL remaining low longer than TIMEOUT is not reported by this flag, it is reported in by the SCL Time-out flag. The flag is cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn eventtimeout(&mut self) -> _EVENTTIMEOUTW {
                _EVENTTIMEOUTW { w: self }
            }
            #[doc = "Bit 25 - SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit."]
            #[inline(always)]
            pub fn scltimeout(&mut self) -> _SCLTIMEOUTW {
                _SCLTIMEOUTW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Set and read register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Set and read register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTPENDINGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTPENDINGENR {
            #[doc = "The MstPending interrupt is disabled."]
            THE_MSTPENDING_INTER0,
            #[doc = "The MstPending interrupt is enabled."]
            THE_MSTPENDING_INTER1,
        }
        impl MSTPENDINGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTPENDINGENR::THE_MSTPENDING_INTER0 => false,
                    MSTPENDINGENR::THE_MSTPENDING_INTER1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTPENDINGENR {
                match value {
                    false => MSTPENDINGENR::THE_MSTPENDING_INTER0,
                    true => MSTPENDINGENR::THE_MSTPENDING_INTER1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MSTPENDING_INTER0`"]
            #[inline(always)]
            pub fn is_the_mstpending_inter0(&self) -> bool {
                *self == MSTPENDINGENR::THE_MSTPENDING_INTER0
            }
            #[doc = "Checks if the value of the field is `THE_MSTPENDING_INTER1`"]
            #[inline(always)]
            pub fn is_the_mstpending_inter1(&self) -> bool {
                *self == MSTPENDINGENR::THE_MSTPENDING_INTER1
            }
        }
        #[doc = "Possible values of the field `MSTARBLOSSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTARBLOSSENR {
            #[doc = "The MstArbLoss interrupt is disabled."]
            THE_MSTARBLOSS_INTER0,
            #[doc = "The MstArbLoss interrupt is enabled."]
            THE_MSTARBLOSS_INTER1,
        }
        impl MSTARBLOSSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTARBLOSSENR::THE_MSTARBLOSS_INTER0 => false,
                    MSTARBLOSSENR::THE_MSTARBLOSS_INTER1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTARBLOSSENR {
                match value {
                    false => MSTARBLOSSENR::THE_MSTARBLOSS_INTER0,
                    true => MSTARBLOSSENR::THE_MSTARBLOSS_INTER1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MSTARBLOSS_INTER0`"]
            #[inline(always)]
            pub fn is_the_mstarbloss_inter0(&self) -> bool {
                *self == MSTARBLOSSENR::THE_MSTARBLOSS_INTER0
            }
            #[doc = "Checks if the value of the field is `THE_MSTARBLOSS_INTER1`"]
            #[inline(always)]
            pub fn is_the_mstarbloss_inter1(&self) -> bool {
                *self == MSTARBLOSSENR::THE_MSTARBLOSS_INTER1
            }
        }
        #[doc = "Possible values of the field `MSTSTSTPERREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTSTPERRENR {
            #[doc = "The MstStStpErr interrupt is disabled."]
            THE_MSTSTSTPERR_INTE0,
            #[doc = "The MstStStpErr interrupt is enabled."]
            THE_MSTSTSTPERR_INTE1,
        }
        impl MSTSTSTPERRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE0 => false,
                    MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTSTSTPERRENR {
                match value {
                    false => MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE0,
                    true => MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MSTSTSTPERR_INTE0`"]
            #[inline(always)]
            pub fn is_the_mstststperr_inte0(&self) -> bool {
                *self == MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE0
            }
            #[doc = "Checks if the value of the field is `THE_MSTSTSTPERR_INTE1`"]
            #[inline(always)]
            pub fn is_the_mstststperr_inte1(&self) -> bool {
                *self == MSTSTSTPERRENR::THE_MSTSTSTPERR_INTE1
            }
        }
        #[doc = "Possible values of the field `SLVPENDINGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVPENDINGENR {
            #[doc = "The SlvPending interrupt is disabled."]
            THE_SLVPENDING_INTER0,
            #[doc = "The SlvPending interrupt is enabled."]
            THE_SLVPENDING_INTER1,
        }
        impl SLVPENDINGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVPENDINGENR::THE_SLVPENDING_INTER0 => false,
                    SLVPENDINGENR::THE_SLVPENDING_INTER1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVPENDINGENR {
                match value {
                    false => SLVPENDINGENR::THE_SLVPENDING_INTER0,
                    true => SLVPENDINGENR::THE_SLVPENDING_INTER1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SLVPENDING_INTER0`"]
            #[inline(always)]
            pub fn is_the_slvpending_inter0(&self) -> bool {
                *self == SLVPENDINGENR::THE_SLVPENDING_INTER0
            }
            #[doc = "Checks if the value of the field is `THE_SLVPENDING_INTER1`"]
            #[inline(always)]
            pub fn is_the_slvpending_inter1(&self) -> bool {
                *self == SLVPENDINGENR::THE_SLVPENDING_INTER1
            }
        }
        #[doc = "Possible values of the field `SLVNOTSTREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNOTSTRENR {
            #[doc = "The SlvNotStr interrupt is disabled."]
            THE_SLVNOTSTR_INTERR0,
            #[doc = "The SlvNotStr interrupt is enabled."]
            THE_SLVNOTSTR_INTERR1,
        }
        impl SLVNOTSTRENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNOTSTRENR::THE_SLVNOTSTR_INTERR0 => false,
                    SLVNOTSTRENR::THE_SLVNOTSTR_INTERR1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVNOTSTRENR {
                match value {
                    false => SLVNOTSTRENR::THE_SLVNOTSTR_INTERR0,
                    true => SLVNOTSTRENR::THE_SLVNOTSTR_INTERR1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SLVNOTSTR_INTERR0`"]
            #[inline(always)]
            pub fn is_the_slvnotstr_interr0(&self) -> bool {
                *self == SLVNOTSTRENR::THE_SLVNOTSTR_INTERR0
            }
            #[doc = "Checks if the value of the field is `THE_SLVNOTSTR_INTERR1`"]
            #[inline(always)]
            pub fn is_the_slvnotstr_interr1(&self) -> bool {
                *self == SLVNOTSTRENR::THE_SLVNOTSTR_INTERR1
            }
        }
        #[doc = "Possible values of the field `SLVDESELEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVDESELENR {
            #[doc = "The SlvDeSel interrupt is disabled."]
            THE_SLVDESEL_INTERRU0,
            #[doc = "The SlvDeSel interrupt is enabled."]
            THE_SLVDESEL_INTERRU1,
        }
        impl SLVDESELENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVDESELENR::THE_SLVDESEL_INTERRU0 => false,
                    SLVDESELENR::THE_SLVDESEL_INTERRU1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVDESELENR {
                match value {
                    false => SLVDESELENR::THE_SLVDESEL_INTERRU0,
                    true => SLVDESELENR::THE_SLVDESEL_INTERRU1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SLVDESEL_INTERRU0`"]
            #[inline(always)]
            pub fn is_the_slvdesel_interru0(&self) -> bool {
                *self == SLVDESELENR::THE_SLVDESEL_INTERRU0
            }
            #[doc = "Checks if the value of the field is `THE_SLVDESEL_INTERRU1`"]
            #[inline(always)]
            pub fn is_the_slvdesel_interru1(&self) -> bool {
                *self == SLVDESELENR::THE_SLVDESEL_INTERRU1
            }
        }
        #[doc = "Possible values of the field `MONRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRDYENR {
            #[doc = "The MonRdy interrupt is disabled."]
            THE_MONRDY_INTERRUPT0,
            #[doc = "The MonRdy interrupt is enabled."]
            THE_MONRDY_INTERRUPT1,
        }
        impl MONRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRDYENR::THE_MONRDY_INTERRUPT0 => false,
                    MONRDYENR::THE_MONRDY_INTERRUPT1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONRDYENR {
                match value {
                    false => MONRDYENR::THE_MONRDY_INTERRUPT0,
                    true => MONRDYENR::THE_MONRDY_INTERRUPT1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MONRDY_INTERRUPT0`"]
            #[inline(always)]
            pub fn is_the_monrdy_interrupt0(&self) -> bool {
                *self == MONRDYENR::THE_MONRDY_INTERRUPT0
            }
            #[doc = "Checks if the value of the field is `THE_MONRDY_INTERRUPT1`"]
            #[inline(always)]
            pub fn is_the_monrdy_interrupt1(&self) -> bool {
                *self == MONRDYENR::THE_MONRDY_INTERRUPT1
            }
        }
        #[doc = "Possible values of the field `MONOVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONOVENR {
            #[doc = "The MonOv interrupt is disabled."]
            THE_MONOV_INTERRUPT_0,
            #[doc = "The MonOv interrupt is enabled."]
            THE_MONOV_INTERRUPT_1,
        }
        impl MONOVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONOVENR::THE_MONOV_INTERRUPT_0 => false,
                    MONOVENR::THE_MONOV_INTERRUPT_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONOVENR {
                match value {
                    false => MONOVENR::THE_MONOV_INTERRUPT_0,
                    true => MONOVENR::THE_MONOV_INTERRUPT_1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MONOV_INTERRUPT_0`"]
            #[inline(always)]
            pub fn is_the_monov_interrupt_0(&self) -> bool {
                *self == MONOVENR::THE_MONOV_INTERRUPT_0
            }
            #[doc = "Checks if the value of the field is `THE_MONOV_INTERRUPT_1`"]
            #[inline(always)]
            pub fn is_the_monov_interrupt_1(&self) -> bool {
                *self == MONOVENR::THE_MONOV_INTERRUPT_1
            }
        }
        #[doc = "Possible values of the field `MONIDLEEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONIDLEENR {
            #[doc = "The MonIdle interrupt is disabled."]
            THE_MONIDLE_INTERRUP0,
            #[doc = "The MonIdle interrupt is enabled."]
            THE_MONIDLE_INTERRUP1,
        }
        impl MONIDLEENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONIDLEENR::THE_MONIDLE_INTERRUP0 => false,
                    MONIDLEENR::THE_MONIDLE_INTERRUP1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONIDLEENR {
                match value {
                    false => MONIDLEENR::THE_MONIDLE_INTERRUP0,
                    true => MONIDLEENR::THE_MONIDLE_INTERRUP1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_MONIDLE_INTERRUP0`"]
            #[inline(always)]
            pub fn is_the_monidle_interrup0(&self) -> bool {
                *self == MONIDLEENR::THE_MONIDLE_INTERRUP0
            }
            #[doc = "Checks if the value of the field is `THE_MONIDLE_INTERRUP1`"]
            #[inline(always)]
            pub fn is_the_monidle_interrup1(&self) -> bool {
                *self == MONIDLEENR::THE_MONIDLE_INTERRUP1
            }
        }
        #[doc = "Possible values of the field `EVENTTIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EVENTTIMEOUTENR {
            #[doc = "The Event Timeout interrupt is disabled."]
            THE_EVENT_TIMEOUT_IN0,
            #[doc = "The Event Timeout interrupt is enabled."]
            THE_EVENT_TIMEOUT_IN1,
        }
        impl EVENTTIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN0 => false,
                    EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EVENTTIMEOUTENR {
                match value {
                    false => EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN0,
                    true => EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_EVENT_TIMEOUT_IN0`"]
            #[inline(always)]
            pub fn is_the_event_timeout_in0(&self) -> bool {
                *self == EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN0
            }
            #[doc = "Checks if the value of the field is `THE_EVENT_TIMEOUT_IN1`"]
            #[inline(always)]
            pub fn is_the_event_timeout_in1(&self) -> bool {
                *self == EVENTTIMEOUTENR::THE_EVENT_TIMEOUT_IN1
            }
        }
        #[doc = "Possible values of the field `SCLTIMEOUTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCLTIMEOUTENR {
            #[doc = "The SCL Timeout interrupt is disabled."]
            THE_SCL_TIMEOUT_INTE0,
            #[doc = "The SCL Timeout interrupt is enabled."]
            THE_SCL_TIMEOUT_INTE1,
        }
        impl SCLTIMEOUTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE0 => false,
                    SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SCLTIMEOUTENR {
                match value {
                    false => SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE0,
                    true => SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SCL_TIMEOUT_INTE0`"]
            #[inline(always)]
            pub fn is_the_scl_timeout_inte0(&self) -> bool {
                *self == SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE0
            }
            #[doc = "Checks if the value of the field is `THE_SCL_TIMEOUT_INTE1`"]
            #[inline(always)]
            pub fn is_the_scl_timeout_inte1(&self) -> bool {
                *self == SCLTIMEOUTENR::THE_SCL_TIMEOUT_INTE1
            }
        }
        #[doc = "Values that can be written to the field `MSTPENDINGEN`"]
        pub enum MSTPENDINGENW {
            #[doc = "The MstPending interrupt is disabled."]
            THE_MSTPENDING_INTER0,
            #[doc = "The MstPending interrupt is enabled."]
            THE_MSTPENDING_INTER1,
        }
        impl MSTPENDINGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTPENDINGENW::THE_MSTPENDING_INTER0 => false,
                    MSTPENDINGENW::THE_MSTPENDING_INTER1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTPENDINGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstPending interrupt is disabled."]
            #[inline(always)]
            pub fn the_mstpending_inter0(self) -> &'a mut W {
                self.variant(MSTPENDINGENW::THE_MSTPENDING_INTER0)
            }
            #[doc = "The MstPending interrupt is enabled."]
            #[inline(always)]
            pub fn the_mstpending_inter1(self) -> &'a mut W {
                self.variant(MSTPENDINGENW::THE_MSTPENDING_INTER1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTARBLOSSEN`"]
        pub enum MSTARBLOSSENW {
            #[doc = "The MstArbLoss interrupt is disabled."]
            THE_MSTARBLOSS_INTER0,
            #[doc = "The MstArbLoss interrupt is enabled."]
            THE_MSTARBLOSS_INTER1,
        }
        impl MSTARBLOSSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTARBLOSSENW::THE_MSTARBLOSS_INTER0 => false,
                    MSTARBLOSSENW::THE_MSTARBLOSS_INTER1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTARBLOSSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstArbLoss interrupt is disabled."]
            #[inline(always)]
            pub fn the_mstarbloss_inter0(self) -> &'a mut W {
                self.variant(MSTARBLOSSENW::THE_MSTARBLOSS_INTER0)
            }
            #[doc = "The MstArbLoss interrupt is enabled."]
            #[inline(always)]
            pub fn the_mstarbloss_inter1(self) -> &'a mut W {
                self.variant(MSTARBLOSSENW::THE_MSTARBLOSS_INTER1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTSTPERREN`"]
        pub enum MSTSTSTPERRENW {
            #[doc = "The MstStStpErr interrupt is disabled."]
            THE_MSTSTSTPERR_INTE0,
            #[doc = "The MstStStpErr interrupt is enabled."]
            THE_MSTSTSTPERR_INTE1,
        }
        impl MSTSTSTPERRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTSTPERRENW::THE_MSTSTSTPERR_INTE0 => false,
                    MSTSTSTPERRENW::THE_MSTSTSTPERR_INTE1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSTSTPERRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MstStStpErr interrupt is disabled."]
            #[inline(always)]
            pub fn the_mstststperr_inte0(self) -> &'a mut W {
                self.variant(MSTSTSTPERRENW::THE_MSTSTSTPERR_INTE0)
            }
            #[doc = "The MstStStpErr interrupt is enabled."]
            #[inline(always)]
            pub fn the_mstststperr_inte1(self) -> &'a mut W {
                self.variant(MSTSTSTPERRENW::THE_MSTSTSTPERR_INTE1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVPENDINGEN`"]
        pub enum SLVPENDINGENW {
            #[doc = "The SlvPending interrupt is disabled."]
            THE_SLVPENDING_INTER0,
            #[doc = "The SlvPending interrupt is enabled."]
            THE_SLVPENDING_INTER1,
        }
        impl SLVPENDINGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVPENDINGENW::THE_SLVPENDING_INTER0 => false,
                    SLVPENDINGENW::THE_SLVPENDING_INTER1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVPENDINGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvPending interrupt is disabled."]
            #[inline(always)]
            pub fn the_slvpending_inter0(self) -> &'a mut W {
                self.variant(SLVPENDINGENW::THE_SLVPENDING_INTER0)
            }
            #[doc = "The SlvPending interrupt is enabled."]
            #[inline(always)]
            pub fn the_slvpending_inter1(self) -> &'a mut W {
                self.variant(SLVPENDINGENW::THE_SLVPENDING_INTER1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVNOTSTREN`"]
        pub enum SLVNOTSTRENW {
            #[doc = "The SlvNotStr interrupt is disabled."]
            THE_SLVNOTSTR_INTERR0,
            #[doc = "The SlvNotStr interrupt is enabled."]
            THE_SLVNOTSTR_INTERR1,
        }
        impl SLVNOTSTRENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNOTSTRENW::THE_SLVNOTSTR_INTERR0 => false,
                    SLVNOTSTRENW::THE_SLVNOTSTR_INTERR1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVNOTSTRENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvNotStr interrupt is disabled."]
            #[inline(always)]
            pub fn the_slvnotstr_interr0(self) -> &'a mut W {
                self.variant(SLVNOTSTRENW::THE_SLVNOTSTR_INTERR0)
            }
            #[doc = "The SlvNotStr interrupt is enabled."]
            #[inline(always)]
            pub fn the_slvnotstr_interr1(self) -> &'a mut W {
                self.variant(SLVNOTSTRENW::THE_SLVNOTSTR_INTERR1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLVDESELEN`"]
        pub enum SLVDESELENW {
            #[doc = "The SlvDeSel interrupt is disabled."]
            THE_SLVDESEL_INTERRU0,
            #[doc = "The SlvDeSel interrupt is enabled."]
            THE_SLVDESEL_INTERRU1,
        }
        impl SLVDESELENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVDESELENW::THE_SLVDESEL_INTERRU0 => false,
                    SLVDESELENW::THE_SLVDESEL_INTERRU1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVDESELENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SlvDeSel interrupt is disabled."]
            #[inline(always)]
            pub fn the_slvdesel_interru0(self) -> &'a mut W {
                self.variant(SLVDESELENW::THE_SLVDESEL_INTERRU0)
            }
            #[doc = "The SlvDeSel interrupt is enabled."]
            #[inline(always)]
            pub fn the_slvdesel_interru1(self) -> &'a mut W {
                self.variant(SLVDESELENW::THE_SLVDESEL_INTERRU1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONRDYEN`"]
        pub enum MONRDYENW {
            #[doc = "The MonRdy interrupt is disabled."]
            THE_MONRDY_INTERRUPT0,
            #[doc = "The MonRdy interrupt is enabled."]
            THE_MONRDY_INTERRUPT1,
        }
        impl MONRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONRDYENW::THE_MONRDY_INTERRUPT0 => false,
                    MONRDYENW::THE_MONRDY_INTERRUPT1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonRdy interrupt is disabled."]
            #[inline(always)]
            pub fn the_monrdy_interrupt0(self) -> &'a mut W {
                self.variant(MONRDYENW::THE_MONRDY_INTERRUPT0)
            }
            #[doc = "The MonRdy interrupt is enabled."]
            #[inline(always)]
            pub fn the_monrdy_interrupt1(self) -> &'a mut W {
                self.variant(MONRDYENW::THE_MONRDY_INTERRUPT1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONOVEN`"]
        pub enum MONOVENW {
            #[doc = "The MonOv interrupt is disabled."]
            THE_MONOV_INTERRUPT_0,
            #[doc = "The MonOv interrupt is enabled."]
            THE_MONOV_INTERRUPT_1,
        }
        impl MONOVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONOVENW::THE_MONOV_INTERRUPT_0 => false,
                    MONOVENW::THE_MONOV_INTERRUPT_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONOVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonOv interrupt is disabled."]
            #[inline(always)]
            pub fn the_monov_interrupt_0(self) -> &'a mut W {
                self.variant(MONOVENW::THE_MONOV_INTERRUPT_0)
            }
            #[doc = "The MonOv interrupt is enabled."]
            #[inline(always)]
            pub fn the_monov_interrupt_1(self) -> &'a mut W {
                self.variant(MONOVENW::THE_MONOV_INTERRUPT_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MONIDLEEN`"]
        pub enum MONIDLEENW {
            #[doc = "The MonIdle interrupt is disabled."]
            THE_MONIDLE_INTERRUP0,
            #[doc = "The MonIdle interrupt is enabled."]
            THE_MONIDLE_INTERRUP1,
        }
        impl MONIDLEENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MONIDLEENW::THE_MONIDLE_INTERRUP0 => false,
                    MONIDLEENW::THE_MONIDLE_INTERRUP1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLEENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MONIDLEENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The MonIdle interrupt is disabled."]
            #[inline(always)]
            pub fn the_monidle_interrup0(self) -> &'a mut W {
                self.variant(MONIDLEENW::THE_MONIDLE_INTERRUP0)
            }
            #[doc = "The MonIdle interrupt is enabled."]
            #[inline(always)]
            pub fn the_monidle_interrup1(self) -> &'a mut W {
                self.variant(MONIDLEENW::THE_MONIDLE_INTERRUP1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EVENTTIMEOUTEN`"]
        pub enum EVENTTIMEOUTENW {
            #[doc = "The Event Timeout interrupt is disabled."]
            THE_EVENT_TIMEOUT_IN0,
            #[doc = "The Event Timeout interrupt is enabled."]
            THE_EVENT_TIMEOUT_IN1,
        }
        impl EVENTTIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    EVENTTIMEOUTENW::THE_EVENT_TIMEOUT_IN0 => false,
                    EVENTTIMEOUTENW::THE_EVENT_TIMEOUT_IN1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EVENTTIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The Event Timeout interrupt is disabled."]
            #[inline(always)]
            pub fn the_event_timeout_in0(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTENW::THE_EVENT_TIMEOUT_IN0)
            }
            #[doc = "The Event Timeout interrupt is enabled."]
            #[inline(always)]
            pub fn the_event_timeout_in1(self) -> &'a mut W {
                self.variant(EVENTTIMEOUTENW::THE_EVENT_TIMEOUT_IN1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SCLTIMEOUTEN`"]
        pub enum SCLTIMEOUTENW {
            #[doc = "The SCL Timeout interrupt is disabled."]
            THE_SCL_TIMEOUT_INTE0,
            #[doc = "The SCL Timeout interrupt is enabled."]
            THE_SCL_TIMEOUT_INTE1,
        }
        impl SCLTIMEOUTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SCLTIMEOUTENW::THE_SCL_TIMEOUT_INTE0 => false,
                    SCLTIMEOUTENW::THE_SCL_TIMEOUT_INTE1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SCLTIMEOUTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SCL Timeout interrupt is disabled."]
            #[inline(always)]
            pub fn the_scl_timeout_inte0(self) -> &'a mut W {
                self.variant(SCLTIMEOUTENW::THE_SCL_TIMEOUT_INTE0)
            }
            #[doc = "The SCL Timeout interrupt is enabled."]
            #[inline(always)]
            pub fn the_scl_timeout_inte1(self) -> &'a mut W {
                self.variant(SCLTIMEOUTENW::THE_SCL_TIMEOUT_INTE1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending interrupt Enable."]
            #[inline(always)]
            pub fn mstpendingen(&self) -> MSTPENDINGENR {
                MSTPENDINGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt Enable."]
            #[inline(always)]
            pub fn mstarblossen(&self) -> MSTARBLOSSENR {
                MSTARBLOSSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt Enable."]
            #[inline(always)]
            pub fn mstststperren(&self) -> MSTSTSTPERRENR {
                MSTSTSTPERRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Slave Pending interrupt Enable."]
            #[inline(always)]
            pub fn slvpendingen(&self) -> SLVPENDINGENR {
                SLVPENDINGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt Enable."]
            #[inline(always)]
            pub fn slvnotstren(&self) -> SLVNOTSTRENR {
                SLVNOTSTRENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Slave Deselect interrupt Enable."]
            #[inline(always)]
            pub fn slvdeselen(&self) -> SLVDESELENR {
                SLVDESELENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt Enable."]
            #[inline(always)]
            pub fn monrdyen(&self) -> MONRDYENR {
                MONRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt Enable."]
            #[inline(always)]
            pub fn monoven(&self) -> MONOVENR {
                MONOVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Monitor Idle interrupt Enable."]
            #[inline(always)]
            pub fn monidleen(&self) -> MONIDLEENR {
                MONIDLEENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Event Timeout interrupt Enable."]
            #[inline(always)]
            pub fn eventtimeouten(&self) -> EVENTTIMEOUTENR {
                EVENTTIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - SCL Timeout interrupt Enable."]
            #[inline(always)]
            pub fn scltimeouten(&self) -> SCLTIMEOUTENR {
                SCLTIMEOUTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending interrupt Enable."]
            #[inline(always)]
            pub fn mstpendingen(&mut self) -> _MSTPENDINGENW {
                _MSTPENDINGENW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt Enable."]
            #[inline(always)]
            pub fn mstarblossen(&mut self) -> _MSTARBLOSSENW {
                _MSTARBLOSSENW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt Enable."]
            #[inline(always)]
            pub fn mstststperren(&mut self) -> _MSTSTSTPERRENW {
                _MSTSTSTPERRENW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending interrupt Enable."]
            #[inline(always)]
            pub fn slvpendingen(&mut self) -> _SLVPENDINGENW {
                _SLVPENDINGENW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt Enable."]
            #[inline(always)]
            pub fn slvnotstren(&mut self) -> _SLVNOTSTRENW {
                _SLVNOTSTRENW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselect interrupt Enable."]
            #[inline(always)]
            pub fn slvdeselen(&mut self) -> _SLVDESELENW {
                _SLVDESELENW { w: self }
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt Enable."]
            #[inline(always)]
            pub fn monrdyen(&mut self) -> _MONRDYENW {
                _MONRDYENW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt Enable."]
            #[inline(always)]
            pub fn monoven(&mut self) -> _MONOVENW {
                _MONOVENW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle interrupt Enable."]
            #[inline(always)]
            pub fn monidleen(&mut self) -> _MONIDLEENW {
                _MONIDLEENW { w: self }
            }
            #[doc = "Bit 24 - Event Timeout interrupt Enable."]
            #[inline(always)]
            pub fn eventtimeouten(&mut self) -> _EVENTTIMEOUTENW {
                _EVENTTIMEOUTENW { w: self }
            }
            #[doc = "Bit 25 - SCL Timeout interrupt Enable."]
            #[inline(always)]
            pub fn scltimeouten(&mut self) -> _SCLTIMEOUTENW {
                _SCLTIMEOUTENW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear register."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTPENDINGCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTPENDINGCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTARBLOSSCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTARBLOSSCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTSTPERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTSTPERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVPENDINGCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVPENDINGCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNOTSTRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNOTSTRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVDESELCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVDESELCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONOVCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONOVCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MONIDLECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MONIDLECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EVENTTIMEOUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EVENTTIMEOUTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLTIMEOUTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLTIMEOUTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented."]
            #[inline(always)]
            pub fn mstpendingclr(&mut self) -> _MSTPENDINGCLRW {
                _MSTPENDINGCLRW { w: self }
            }
            #[doc = "Bit 4 - Master Arbitration Loss interrupt clear."]
            #[inline(always)]
            pub fn mstarblossclr(&mut self) -> _MSTARBLOSSCLRW {
                _MSTARBLOSSCLRW { w: self }
            }
            #[doc = "Bit 6 - Master Start/Stop Error interrupt clear."]
            #[inline(always)]
            pub fn mstststperrclr(&mut self) -> _MSTSTSTPERRCLRW {
                _MSTSTSTPERRCLRW { w: self }
            }
            #[doc = "Bit 8 - Slave Pending interrupt clear."]
            #[inline(always)]
            pub fn slvpendingclr(&mut self) -> _SLVPENDINGCLRW {
                _SLVPENDINGCLRW { w: self }
            }
            #[doc = "Bit 11 - Slave Not Stretching interrupt clear."]
            #[inline(always)]
            pub fn slvnotstrclr(&mut self) -> _SLVNOTSTRCLRW {
                _SLVNOTSTRCLRW { w: self }
            }
            #[doc = "Bit 15 - Slave Deselect interrupt clear."]
            #[inline(always)]
            pub fn slvdeselclr(&mut self) -> _SLVDESELCLRW {
                _SLVDESELCLRW { w: self }
            }
            #[doc = "Bit 16 - Monitor data Ready interrupt clear."]
            #[inline(always)]
            pub fn monrdyclr(&mut self) -> _MONRDYCLRW {
                _MONRDYCLRW { w: self }
            }
            #[doc = "Bit 17 - Monitor Overrun interrupt clear."]
            #[inline(always)]
            pub fn monovclr(&mut self) -> _MONOVCLRW {
                _MONOVCLRW { w: self }
            }
            #[doc = "Bit 19 - Monitor Idle interrupt clear."]
            #[inline(always)]
            pub fn monidleclr(&mut self) -> _MONIDLECLRW {
                _MONIDLECLRW { w: self }
            }
            #[doc = "Bit 24 - Event Timeout interrupt clear."]
            #[inline(always)]
            pub fn eventtimeoutclr(&mut self) -> _EVENTTIMEOUTCLRW {
                _EVENTTIMEOUTCLRW { w: self }
            }
            #[doc = "Bit 25 - SCL Timeout interrupt clear."]
            #[inline(always)]
            pub fn scltimeoutclr(&mut self) -> _SCLTIMEOUTCLRW {
                _SCLTIMEOUTCLRW { w: self }
            }
        }
    }
    #[doc = "Time-out value register."]
    pub struct TIMEOUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Time-out value register."]
    pub mod timeout {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIMEOUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOMINR {
            bits: u8,
        }
        impl TOMINR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TOR {
            bits: u16,
        }
        impl TOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOMINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOMINW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TOW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 4095;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Timeout time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum timeout of 16 I2C function clocks and also a timeout resolution of 16 I2C function clocks."]
            #[inline(always)]
            pub fn tomin(&self) -> TOMINR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TOMINR { bits }
            }
            #[doc = "Bits 4:15 - Timeout time value. Specifies the timeout interval value in increments of 16 I2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A timeout will occur after 65,536 counts of the I2C function clock."]
            #[inline(always)]
            pub fn to(&self) -> TOR {
                let bits = {
                    const MASK: u16 = 4095;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TOR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 65535 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Timeout time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum timeout of 16 I2C function clocks and also a timeout resolution of 16 I2C function clocks."]
            #[inline(always)]
            pub fn tomin(&mut self) -> _TOMINW {
                _TOMINW { w: self }
            }
            #[doc = "Bits 4:15 - Timeout time value. Specifies the timeout interval value in increments of 16 I2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A timeout will occur after 65,536 counts of the I2C function clock."]
            #[inline(always)]
            pub fn to(&mut self) -> _TOW {
                _TOW { w: self }
            }
        }
    }
    #[doc = "Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
    pub struct DIV {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers."]
    pub mod div {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVVALR {
            bits: u16,
        }
        impl DIVVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function."]
            #[inline(always)]
            pub fn divval(&self) -> DIVVALR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function."]
            #[inline(always)]
            pub fn divval(&mut self) -> _DIVVALW {
                _DIVVALW { w: self }
            }
        }
    }
    #[doc = "Interrupt Status register for Master, Slave, and Monitor functions."]
    pub struct INTSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Status register for Master, Slave, and Monitor functions."]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTPENDINGR {
            bits: bool,
        }
        impl MSTPENDINGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTARBLOSSR {
            bits: bool,
        }
        impl MSTARBLOSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSTSTSTPERRR {
            bits: bool,
        }
        impl MSTSTSTPERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVPENDINGR {
            bits: bool,
        }
        impl SLVPENDINGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVNOTSTRR {
            bits: bool,
        }
        impl SLVNOTSTRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVDESELR {
            bits: bool,
        }
        impl SLVDESELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONRDYR {
            bits: bool,
        }
        impl MONRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONOVR {
            bits: bool,
        }
        impl MONOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONIDLER {
            bits: bool,
        }
        impl MONIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EVENTTIMEOUTR {
            bits: bool,
        }
        impl EVENTTIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCLTIMEOUTR {
            bits: bool,
        }
        impl SCLTIMEOUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Pending."]
            #[inline(always)]
            pub fn mstpending(&self) -> MSTPENDINGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTPENDINGR { bits }
            }
            #[doc = "Bit 4 - Master Arbitration Loss flag."]
            #[inline(always)]
            pub fn mstarbloss(&self) -> MSTARBLOSSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTARBLOSSR { bits }
            }
            #[doc = "Bit 6 - Master Start/Stop Error flag."]
            #[inline(always)]
            pub fn mstststperr(&self) -> MSTSTSTPERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MSTSTSTPERRR { bits }
            }
            #[doc = "Bit 8 - Slave Pending."]
            #[inline(always)]
            pub fn slvpending(&self) -> SLVPENDINGR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVPENDINGR { bits }
            }
            #[doc = "Bit 11 - Slave Not Stretching status."]
            #[inline(always)]
            pub fn slvnotstr(&self) -> SLVNOTSTRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVNOTSTRR { bits }
            }
            #[doc = "Bit 15 - Slave Deselected flag."]
            #[inline(always)]
            pub fn slvdesel(&self) -> SLVDESELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SLVDESELR { bits }
            }
            #[doc = "Bit 16 - Monitor Ready."]
            #[inline(always)]
            pub fn monrdy(&self) -> MONRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONRDYR { bits }
            }
            #[doc = "Bit 17 - Monitor Overflow flag."]
            #[inline(always)]
            pub fn monov(&self) -> MONOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONOVR { bits }
            }
            #[doc = "Bit 19 - Monitor Idle flag."]
            #[inline(always)]
            pub fn monidle(&self) -> MONIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MONIDLER { bits }
            }
            #[doc = "Bit 24 - Event Timeout Interrupt flag."]
            #[inline(always)]
            pub fn eventtimeout(&self) -> EVENTTIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EVENTTIMEOUTR { bits }
            }
            #[doc = "Bit 25 - SCL Timeout Interrupt flag."]
            #[inline(always)]
            pub fn scltimeout(&self) -> SCLTIMEOUTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SCLTIMEOUTR { bits }
            }
        }
    }
    #[doc = "Master control register."]
    pub struct MSTCTL {
        register: VolatileCell<u32>,
    }
    #[doc = "Master control register."]
    pub mod mstctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTCONTINUE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTCONTINUER {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE_INFORMS_TH,
        }
        impl MSTCONTINUER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTCONTINUER::NO_EFFECT_ => false,
                    MSTCONTINUER::CONTINUE_INFORMS_TH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTCONTINUER {
                match value {
                    false => MSTCONTINUER::NO_EFFECT_,
                    true => MSTCONTINUER::CONTINUE_INFORMS_TH,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_`"]
            #[inline(always)]
            pub fn is_no_effect_(&self) -> bool {
                *self == MSTCONTINUER::NO_EFFECT_
            }
            #[doc = "Checks if the value of the field is `CONTINUE_INFORMS_TH`"]
            #[inline(always)]
            pub fn is_continue_informs_th(&self) -> bool {
                *self == MSTCONTINUER::CONTINUE_INFORMS_TH
            }
        }
        #[doc = "Possible values of the field `MSTSTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTARTR {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            START_A_START_WILL_,
        }
        impl MSTSTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTARTR::NO_EFFECT_ => false,
                    MSTSTARTR::START_A_START_WILL_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTSTARTR {
                match value {
                    false => MSTSTARTR::NO_EFFECT_,
                    true => MSTSTARTR::START_A_START_WILL_,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_`"]
            #[inline(always)]
            pub fn is_no_effect_(&self) -> bool {
                *self == MSTSTARTR::NO_EFFECT_
            }
            #[doc = "Checks if the value of the field is `START_A_START_WILL_`"]
            #[inline(always)]
            pub fn is_start_a_start_will_(&self) -> bool {
                *self == MSTSTARTR::START_A_START_WILL_
            }
        }
        #[doc = "Possible values of the field `MSTSTOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSTOPR {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a Nack to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            STOP_A_STOP_WILL_BE,
        }
        impl MSTSTOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MSTSTOPR::NO_EFFECT_ => false,
                    MSTSTOPR::STOP_A_STOP_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MSTSTOPR {
                match value {
                    false => MSTSTOPR::NO_EFFECT_,
                    true => MSTSTOPR::STOP_A_STOP_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_`"]
            #[inline(always)]
            pub fn is_no_effect_(&self) -> bool {
                *self == MSTSTOPR::NO_EFFECT_
            }
            #[doc = "Checks if the value of the field is `STOP_A_STOP_WILL_BE`"]
            #[inline(always)]
            pub fn is_stop_a_stop_will_be(&self) -> bool {
                *self == MSTSTOPR::STOP_A_STOP_WILL_BE
            }
        }
        #[doc = "Values that can be written to the field `MSTCONTINUE`"]
        pub enum MSTCONTINUEW {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE_INFORMS_TH,
        }
        impl MSTCONTINUEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTCONTINUEW::NO_EFFECT_ => false,
                    MSTCONTINUEW::CONTINUE_INFORMS_TH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTCONTINUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTCONTINUEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTCONTINUEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline(always)]
            pub fn no_effect_(self) -> &'a mut W {
                self.variant(MSTCONTINUEW::NO_EFFECT_)
            }
            #[doc = "Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            #[inline(always)]
            pub fn continue_informs_th(self) -> &'a mut W {
                self.variant(MSTCONTINUEW::CONTINUE_INFORMS_TH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTART`"]
        pub enum MSTSTARTW {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            START_A_START_WILL_,
        }
        impl MSTSTARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTARTW::NO_EFFECT_ => false,
                    MSTSTARTW::START_A_START_WILL_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSTARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline(always)]
            pub fn no_effect_(self) -> &'a mut W {
                self.variant(MSTSTARTW::NO_EFFECT_)
            }
            #[doc = "Start. A Start will be generated on the I2C bus at the next allowed time."]
            #[inline(always)]
            pub fn start_a_start_will_(self) -> &'a mut W {
                self.variant(MSTSTARTW::START_A_START_WILL_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSTOP`"]
        pub enum MSTSTOPW {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a Nack to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            STOP_A_STOP_WILL_BE,
        }
        impl MSTSTOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSTSTOPW::NO_EFFECT_ => false,
                    MSTSTOPW::STOP_A_STOP_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSTOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSTOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline(always)]
            pub fn no_effect_(self) -> &'a mut W {
                self.variant(MSTSTOPW::NO_EFFECT_)
            }
            #[doc = "Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a Nack to the slave if the master is receiving data from the slave (Master Receiver mode)."]
            #[inline(always)]
            pub fn stop_a_stop_will_be(self) -> &'a mut W {
                self.variant(MSTSTOPW::STOP_A_STOP_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Master Continue. This bit is write-only."]
            #[inline(always)]
            pub fn mstcontinue(&self) -> MSTCONTINUER {
                MSTCONTINUER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Master Start control. This bit is write-only."]
            #[inline(always)]
            pub fn mststart(&self) -> MSTSTARTR {
                MSTSTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Master Stop control. This bit is write-only."]
            #[inline(always)]
            pub fn mststop(&self) -> MSTSTOPR {
                MSTSTOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Master Continue. This bit is write-only."]
            #[inline(always)]
            pub fn mstcontinue(&mut self) -> _MSTCONTINUEW {
                _MSTCONTINUEW { w: self }
            }
            #[doc = "Bit 1 - Master Start control. This bit is write-only."]
            #[inline(always)]
            pub fn mststart(&mut self) -> _MSTSTARTW {
                _MSTSTARTW { w: self }
            }
            #[doc = "Bit 2 - Master Stop control. This bit is write-only."]
            #[inline(always)]
            pub fn mststop(&mut self) -> _MSTSTOPW {
                _MSTSTOPW { w: self }
            }
        }
    }
    #[doc = "Master timing configuration."]
    pub struct MSTTIME {
        register: VolatileCell<u32>,
    }
    #[doc = "Master timing configuration."]
    pub mod msttime {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTTIME {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MSTSCLLOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSCLLOWR {
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            _2_CLOCKS_MINIMUM_SC,
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            _3_CLOCKS_MINIMUM_SC,
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            _4_CLOCKS_MINIMUM_SC,
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            _5_CLOCKS_MINIMUM_SC,
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            _6_CLOCKS_MINIMUM_SC,
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            _7_CLOCKS_MINIMUM_SC,
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            _8_CLOCKS_MINIMUM_SC,
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS_MINIMUM_SC,
        }
        impl MSTSCLLOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSCLLOWR::_2_CLOCKS_MINIMUM_SC => 0,
                    MSTSCLLOWR::_3_CLOCKS_MINIMUM_SC => 1,
                    MSTSCLLOWR::_4_CLOCKS_MINIMUM_SC => 2,
                    MSTSCLLOWR::_5_CLOCKS_MINIMUM_SC => 3,
                    MSTSCLLOWR::_6_CLOCKS_MINIMUM_SC => 4,
                    MSTSCLLOWR::_7_CLOCKS_MINIMUM_SC => 5,
                    MSTSCLLOWR::_8_CLOCKS_MINIMUM_SC => 6,
                    MSTSCLLOWR::_9_CLOCKS_MINIMUM_SC => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MSTSCLLOWR {
                match value {
                    0 => MSTSCLLOWR::_2_CLOCKS_MINIMUM_SC,
                    1 => MSTSCLLOWR::_3_CLOCKS_MINIMUM_SC,
                    2 => MSTSCLLOWR::_4_CLOCKS_MINIMUM_SC,
                    3 => MSTSCLLOWR::_5_CLOCKS_MINIMUM_SC,
                    4 => MSTSCLLOWR::_6_CLOCKS_MINIMUM_SC,
                    5 => MSTSCLLOWR::_7_CLOCKS_MINIMUM_SC,
                    6 => MSTSCLLOWR::_8_CLOCKS_MINIMUM_SC,
                    7 => MSTSCLLOWR::_9_CLOCKS_MINIMUM_SC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_2_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_2_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_2_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_3_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_3_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_3_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_4_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_4_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_4_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_5_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_5_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_5_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_6_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_6_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_6_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_7_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_7_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_7_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_8_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_8_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_8_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_9_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_9_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLLOWR::_9_CLOCKS_MINIMUM_SC
            }
        }
        #[doc = "Possible values of the field `MSTSCLHIGH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTSCLHIGHR {
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            _2_CLOCKS_MINIMUM_SC,
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            _3_CLOCKS_MINIMUM_SC,
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            _4_CLOCKS_MINIMUM_SC,
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            _5_CLOCKS_MINIMUM_SC,
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            _6_CLOCKS_MINIMUM_SC,
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            _7_CLOCKS_MINIMUM_SC,
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            _8_CLOCKS_MINIMUM_SC,
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS_MINIMUM_SC,
        }
        impl MSTSCLHIGHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    MSTSCLHIGHR::_2_CLOCKS_MINIMUM_SC => 0,
                    MSTSCLHIGHR::_3_CLOCKS_MINIMUM_SC => 1,
                    MSTSCLHIGHR::_4_CLOCKS_MINIMUM_SC => 2,
                    MSTSCLHIGHR::_5_CLOCKS_MINIMUM_SC => 3,
                    MSTSCLHIGHR::_6_CLOCKS_MINIMUM_SC => 4,
                    MSTSCLHIGHR::_7_CLOCKS_MINIMUM_SC => 5,
                    MSTSCLHIGHR::_8_CLOCKS_MINIMUM_SC => 6,
                    MSTSCLHIGHR::_9_CLOCKS_MINIMUM_SC => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> MSTSCLHIGHR {
                match value {
                    0 => MSTSCLHIGHR::_2_CLOCKS_MINIMUM_SC,
                    1 => MSTSCLHIGHR::_3_CLOCKS_MINIMUM_SC,
                    2 => MSTSCLHIGHR::_4_CLOCKS_MINIMUM_SC,
                    3 => MSTSCLHIGHR::_5_CLOCKS_MINIMUM_SC,
                    4 => MSTSCLHIGHR::_6_CLOCKS_MINIMUM_SC,
                    5 => MSTSCLHIGHR::_7_CLOCKS_MINIMUM_SC,
                    6 => MSTSCLHIGHR::_8_CLOCKS_MINIMUM_SC,
                    7 => MSTSCLHIGHR::_9_CLOCKS_MINIMUM_SC,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_2_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_2_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_2_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_3_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_3_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_3_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_4_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_4_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_4_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_5_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_5_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_5_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_6_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_6_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_6_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_7_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_7_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_7_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_8_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_8_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_8_CLOCKS_MINIMUM_SC
            }
            #[doc = "Checks if the value of the field is `_9_CLOCKS_MINIMUM_SC`"]
            #[inline(always)]
            pub fn is_9_clocks_minimum_sc(&self) -> bool {
                *self == MSTSCLHIGHR::_9_CLOCKS_MINIMUM_SC
            }
        }
        #[doc = "Values that can be written to the field `MSTSCLLOW`"]
        pub enum MSTSCLLOWW {
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            _2_CLOCKS_MINIMUM_SC,
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            _3_CLOCKS_MINIMUM_SC,
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            _4_CLOCKS_MINIMUM_SC,
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            _5_CLOCKS_MINIMUM_SC,
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            _6_CLOCKS_MINIMUM_SC,
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            _7_CLOCKS_MINIMUM_SC,
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            _8_CLOCKS_MINIMUM_SC,
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS_MINIMUM_SC,
        }
        impl MSTSCLLOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSCLLOWW::_2_CLOCKS_MINIMUM_SC => 0,
                    MSTSCLLOWW::_3_CLOCKS_MINIMUM_SC => 1,
                    MSTSCLLOWW::_4_CLOCKS_MINIMUM_SC => 2,
                    MSTSCLLOWW::_5_CLOCKS_MINIMUM_SC => 3,
                    MSTSCLLOWW::_6_CLOCKS_MINIMUM_SC => 4,
                    MSTSCLLOWW::_7_CLOCKS_MINIMUM_SC => 5,
                    MSTSCLLOWW::_8_CLOCKS_MINIMUM_SC => 6,
                    MSTSCLLOWW::_9_CLOCKS_MINIMUM_SC => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSCLLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSCLLOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSCLLOWW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _2_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_2_CLOCKS_MINIMUM_SC)
            }
            #[doc = "3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _3_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_3_CLOCKS_MINIMUM_SC)
            }
            #[doc = "4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _4_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_4_CLOCKS_MINIMUM_SC)
            }
            #[doc = "5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _5_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_5_CLOCKS_MINIMUM_SC)
            }
            #[doc = "6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _6_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_6_CLOCKS_MINIMUM_SC)
            }
            #[doc = "7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _7_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_7_CLOCKS_MINIMUM_SC)
            }
            #[doc = "8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _8_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_8_CLOCKS_MINIMUM_SC)
            }
            #[doc = "9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _9_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLLOWW::_9_CLOCKS_MINIMUM_SC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MSTSCLHIGH`"]
        pub enum MSTSCLHIGHW {
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            _2_CLOCKS_MINIMUM_SC,
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            _3_CLOCKS_MINIMUM_SC,
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            _4_CLOCKS_MINIMUM_SC,
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            _5_CLOCKS_MINIMUM_SC,
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            _6_CLOCKS_MINIMUM_SC,
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            _7_CLOCKS_MINIMUM_SC,
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            _8_CLOCKS_MINIMUM_SC,
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            _9_CLOCKS_MINIMUM_SC,
        }
        impl MSTSCLHIGHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MSTSCLHIGHW::_2_CLOCKS_MINIMUM_SC => 0,
                    MSTSCLHIGHW::_3_CLOCKS_MINIMUM_SC => 1,
                    MSTSCLHIGHW::_4_CLOCKS_MINIMUM_SC => 2,
                    MSTSCLHIGHW::_5_CLOCKS_MINIMUM_SC => 3,
                    MSTSCLHIGHW::_6_CLOCKS_MINIMUM_SC => 4,
                    MSTSCLHIGHW::_7_CLOCKS_MINIMUM_SC => 5,
                    MSTSCLHIGHW::_8_CLOCKS_MINIMUM_SC => 6,
                    MSTSCLHIGHW::_9_CLOCKS_MINIMUM_SC => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSTSCLHIGHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSTSCLHIGHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MSTSCLHIGHW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _2_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_2_CLOCKS_MINIMUM_SC)
            }
            #[doc = "3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider ."]
            #[inline(always)]
            pub fn _3_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_3_CLOCKS_MINIMUM_SC)
            }
            #[doc = "4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _4_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_4_CLOCKS_MINIMUM_SC)
            }
            #[doc = "5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _5_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_5_CLOCKS_MINIMUM_SC)
            }
            #[doc = "6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _6_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_6_CLOCKS_MINIMUM_SC)
            }
            #[doc = "7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _7_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_7_CLOCKS_MINIMUM_SC)
            }
            #[doc = "8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _8_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_8_CLOCKS_MINIMUM_SC)
            }
            #[doc = "9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider."]
            #[inline(always)]
            pub fn _9_clocks_minimum_sc(self) -> &'a mut W {
                self.variant(MSTSCLHIGHW::_9_CLOCKS_MINIMUM_SC)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter t LOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW."]
            #[inline(always)]
            pub fn mstscllow(&self) -> MSTSCLLOWR {
                MSTSCLLOWR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:6 - Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH."]
            #[inline(always)]
            pub fn mstsclhigh(&self) -> MSTSCLHIGHR {
                MSTSCLHIGHR::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 119 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter t LOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW."]
            #[inline(always)]
            pub fn mstscllow(&mut self) -> _MSTSCLLOWW {
                _MSTSCLLOWW { w: self }
            }
            #[doc = "Bits 4:6 - Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH."]
            #[inline(always)]
            pub fn mstsclhigh(&mut self) -> _MSTSCLHIGHW {
                _MSTSCLHIGHW { w: self }
            }
        }
    }
    #[doc = "Combined Master receiver and transmitter data register."]
    pub struct MSTDAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Combined Master receiver and transmitter data register."]
    pub mod mstdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MSTDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function."]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function."]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Slave control register."]
    pub struct SLVCTL {
        register: VolatileCell<u32>,
    }
    #[doc = "Slave control register."]
    pub mod slvctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SlvContinue`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVCONTINUER {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE_INFORMS_TH,
        }
        impl SLVCONTINUER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVCONTINUER::NO_EFFECT_ => false,
                    SLVCONTINUER::CONTINUE_INFORMS_TH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVCONTINUER {
                match value {
                    false => SLVCONTINUER::NO_EFFECT_,
                    true => SLVCONTINUER::CONTINUE_INFORMS_TH,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_`"]
            #[inline(always)]
            pub fn is_no_effect_(&self) -> bool {
                *self == SLVCONTINUER::NO_EFFECT_
            }
            #[doc = "Checks if the value of the field is `CONTINUE_INFORMS_TH`"]
            #[inline(always)]
            pub fn is_continue_informs_th(&self) -> bool {
                *self == SLVCONTINUER::CONTINUE_INFORMS_TH
            }
        }
        #[doc = "Possible values of the field `SlvNack`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLVNACKR {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Nack. Causes the Slave function to Nack the master when the slave is receiving data from the master (Slave Receiver mode)."]
            NACK_CAUSES_THE_SLA,
        }
        impl SLVNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SLVNACKR::NO_EFFECT_ => false,
                    SLVNACKR::NACK_CAUSES_THE_SLA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SLVNACKR {
                match value {
                    false => SLVNACKR::NO_EFFECT_,
                    true => SLVNACKR::NACK_CAUSES_THE_SLA,
                }
            }
            #[doc = "Checks if the value of the field is `NO_EFFECT_`"]
            #[inline(always)]
            pub fn is_no_effect_(&self) -> bool {
                *self == SLVNACKR::NO_EFFECT_
            }
            #[doc = "Checks if the value of the field is `NACK_CAUSES_THE_SLA`"]
            #[inline(always)]
            pub fn is_nack_causes_the_sla(&self) -> bool {
                *self == SLVNACKR::NACK_CAUSES_THE_SLA
            }
        }
        #[doc = "Values that can be written to the field `SlvContinue`"]
        pub enum SLVCONTINUEW {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            CONTINUE_INFORMS_TH,
        }
        impl SLVCONTINUEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVCONTINUEW::NO_EFFECT_ => false,
                    SLVCONTINUEW::CONTINUE_INFORMS_TH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVCONTINUEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVCONTINUEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVCONTINUEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline(always)]
            pub fn no_effect_(self) -> &'a mut W {
                self.variant(SLVCONTINUEW::NO_EFFECT_)
            }
            #[doc = "Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation."]
            #[inline(always)]
            pub fn continue_informs_th(self) -> &'a mut W {
                self.variant(SLVCONTINUEW::CONTINUE_INFORMS_TH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SlvNack`"]
        pub enum SLVNACKW {
            #[doc = "No effect."]
            NO_EFFECT_,
            #[doc = "Nack. Causes the Slave function to Nack the master when the slave is receiving data from the master (Slave Receiver mode)."]
            NACK_CAUSES_THE_SLA,
        }
        impl SLVNACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLVNACKW::NO_EFFECT_ => false,
                    SLVNACKW::NACK_CAUSES_THE_SLA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVNACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVNACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SLVNACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No effect."]
            #[inline(always)]
            pub fn no_effect_(self) -> &'a mut W {
                self.variant(SLVNACKW::NO_EFFECT_)
            }
            #[doc = "Nack. Causes the Slave function to Nack the master when the slave is receiving data from the master (Slave Receiver mode)."]
            #[inline(always)]
            pub fn nack_causes_the_sla(self) -> &'a mut W {
                self.variant(SLVNACKW::NACK_CAUSES_THE_SLA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Continue."]
            #[inline(always)]
            pub fn slv_continue(&self) -> SLVCONTINUER {
                SLVCONTINUER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Slave Nack."]
            #[inline(always)]
            pub fn slv_nack(&self) -> SLVNACKR {
                SLVNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Continue."]
            #[inline(always)]
            pub fn slv_continue(&mut self) -> _SLVCONTINUEW {
                _SLVCONTINUEW { w: self }
            }
            #[doc = "Bit 1 - Slave Nack."]
            #[inline(always)]
            pub fn slv_nack(&mut self) -> _SLVNACKW {
                _SLVNACKW { w: self }
            }
        }
    }
    #[doc = "Combined Slave receiver and transmitter data register."]
    pub struct SLVDAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Combined Slave receiver and transmitter data register."]
    pub mod slvdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function."]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function."]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Slave address 0."]
    pub struct SLVADR {
        register: VolatileCell<u32>,
    }
    #[doc = "Slave address 0."]
    pub mod slvadr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVADR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SADISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SADISABLER {
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            ENABLED_SLAVE_ADDRE,
            #[doc = "Ignored Slave Address n is ignored."]
            IGNORED_SLAVE_ADDRES,
        }
        impl SADISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SADISABLER::ENABLED_SLAVE_ADDRE => false,
                    SADISABLER::IGNORED_SLAVE_ADDRES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SADISABLER {
                match value {
                    false => SADISABLER::ENABLED_SLAVE_ADDRE,
                    true => SADISABLER::IGNORED_SLAVE_ADDRES,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED_SLAVE_ADDRE`"]
            #[inline(always)]
            pub fn is_enabled_slave_addre(&self) -> bool {
                *self == SADISABLER::ENABLED_SLAVE_ADDRE
            }
            #[doc = "Checks if the value of the field is `IGNORED_SLAVE_ADDRES`"]
            #[inline(always)]
            pub fn is_ignored_slave_addres(&self) -> bool {
                *self == SADISABLER::IGNORED_SLAVE_ADDRES
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVADRR {
            bits: u8,
        }
        impl SLVADRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SADISABLE`"]
        pub enum SADISABLEW {
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            ENABLED_SLAVE_ADDRE,
            #[doc = "Ignored Slave Address n is ignored."]
            IGNORED_SLAVE_ADDRES,
        }
        impl SADISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SADISABLEW::ENABLED_SLAVE_ADDRE => false,
                    SADISABLEW::IGNORED_SLAVE_ADDRES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SADISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SADISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SADISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register."]
            #[inline(always)]
            pub fn enabled_slave_addre(self) -> &'a mut W {
                self.variant(SADISABLEW::ENABLED_SLAVE_ADDRE)
            }
            #[doc = "Ignored Slave Address n is ignored."]
            #[inline(always)]
            pub fn ignored_slave_addres(self) -> &'a mut W {
                self.variant(SADISABLEW::IGNORED_SLAVE_ADDRES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVADRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVADRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Slave Address n Disable."]
            #[inline(always)]
            pub fn sadisable(&self) -> SADISABLER {
                SADISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:7 - Seven bit slave address that is compared to received addresses if enabled."]
            #[inline(always)]
            pub fn slvadr(&self) -> SLVADRR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SLVADRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 1 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Slave Address n Disable."]
            #[inline(always)]
            pub fn sadisable(&mut self) -> _SADISABLEW {
                _SADISABLEW { w: self }
            }
            #[doc = "Bits 1:7 - Seven bit slave address that is compared to received addresses if enabled."]
            #[inline(always)]
            pub fn slvadr(&mut self) -> _SLVADRW {
                _SLVADRW { w: self }
            }
        }
    }
    #[doc = "Slave Qualification for address 0."]
    pub struct SLVQUAL0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Slave Qualification for address 0."]
    pub mod slvqual0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SLVQUAL0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `QUALMODE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum QUALMODE0R {
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            THE_SLVQUAL0_FIELD_I0,
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            THE_SLVQUAL0_FIELD_I1,
        }
        impl QUALMODE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    QUALMODE0R::THE_SLVQUAL0_FIELD_I0 => false,
                    QUALMODE0R::THE_SLVQUAL0_FIELD_I1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> QUALMODE0R {
                match value {
                    false => QUALMODE0R::THE_SLVQUAL0_FIELD_I0,
                    true => QUALMODE0R::THE_SLVQUAL0_FIELD_I1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SLVQUAL0_FIELD_I0`"]
            #[inline(always)]
            pub fn is_the_slvqual0_field_i0(&self) -> bool {
                *self == QUALMODE0R::THE_SLVQUAL0_FIELD_I0
            }
            #[doc = "Checks if the value of the field is `THE_SLVQUAL0_FIELD_I1`"]
            #[inline(always)]
            pub fn is_the_slvqual0_field_i1(&self) -> bool {
                *self == QUALMODE0R::THE_SLVQUAL0_FIELD_I1
            }
        }
        #[doc = r" Value of the field"]
        pub struct SLVQUAL0R {
            bits: u8,
        }
        impl SLVQUAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `QUALMODE0`"]
        pub enum QUALMODE0W {
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            THE_SLVQUAL0_FIELD_I0,
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            THE_SLVQUAL0_FIELD_I1,
        }
        impl QUALMODE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    QUALMODE0W::THE_SLVQUAL0_FIELD_I0 => false,
                    QUALMODE0W::THE_SLVQUAL0_FIELD_I1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _QUALMODE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _QUALMODE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: QUALMODE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SLVQUAL0 field is used as a logical mask for matching address 0."]
            #[inline(always)]
            pub fn the_slvqual0_field_i0(self) -> &'a mut W {
                self.variant(QUALMODE0W::THE_SLVQUAL0_FIELD_I0)
            }
            #[doc = "The SLVQUAL0 field is used to extend address 0 matching in a range of addresses."]
            #[inline(always)]
            pub fn the_slvqual0_field_i1(self) -> &'a mut W {
                self.variant(QUALMODE0W::THE_SLVQUAL0_FIELD_I1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLVQUAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLVQUAL0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Reserved. Read value is undefined, only zero should be written."]
            #[inline(always)]
            pub fn qualmode0(&self) -> QUALMODE0R {
                QUALMODE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:7 - Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] less or equal than received address less or equal than SLVQUAL0[7:1])."]
            #[inline(always)]
            pub fn slvqual0(&self) -> SLVQUAL0R {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SLVQUAL0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Reserved. Read value is undefined, only zero should be written."]
            #[inline(always)]
            pub fn qualmode0(&mut self) -> _QUALMODE0W {
                _QUALMODE0W { w: self }
            }
            #[doc = "Bits 1:7 - Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] less or equal than received address less or equal than SLVQUAL0[7:1])."]
            #[inline(always)]
            pub fn slvqual0(&mut self) -> _SLVQUAL0W {
                _SLVQUAL0W { w: self }
            }
        }
    }
    #[doc = "Monitor receiver data register."]
    pub struct MONRXDAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Monitor receiver data register."]
    pub mod monrxdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MONRXDAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct MONRXDATR {
            bits: u8,
        }
        impl MONRXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `MONSTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONSTARTR {
            #[doc = "No detect. The monitor function has not detected a Start event on the I2C bus."]
            NO_DETECT_THE_MONIT,
            #[doc = "Start detect. The monitor function has detected a Start event on the I2C bus."]
            START_DETECT_THE_MO,
        }
        impl MONSTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONSTARTR::NO_DETECT_THE_MONIT => false,
                    MONSTARTR::START_DETECT_THE_MO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONSTARTR {
                match value {
                    false => MONSTARTR::NO_DETECT_THE_MONIT,
                    true => MONSTARTR::START_DETECT_THE_MO,
                }
            }
            #[doc = "Checks if the value of the field is `NO_DETECT_THE_MONIT`"]
            #[inline(always)]
            pub fn is_no_detect_the_monit(&self) -> bool {
                *self == MONSTARTR::NO_DETECT_THE_MONIT
            }
            #[doc = "Checks if the value of the field is `START_DETECT_THE_MO`"]
            #[inline(always)]
            pub fn is_start_detect_the_mo(&self) -> bool {
                *self == MONSTARTR::START_DETECT_THE_MO
            }
        }
        #[doc = "Possible values of the field `MONRESTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONRESTARTR {
            #[doc = "No start detect. The monitor function has not detected a Repeated Start event on the I2C bus."]
            NO_START_DETECT_THE,
            #[doc = "Repeated start detect. The monitor function has detected a Repeated Start event on the I 2C bus."]
            REPEATED_START_DETEC,
        }
        impl MONRESTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONRESTARTR::NO_START_DETECT_THE => false,
                    MONRESTARTR::REPEATED_START_DETEC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONRESTARTR {
                match value {
                    false => MONRESTARTR::NO_START_DETECT_THE,
                    true => MONRESTARTR::REPEATED_START_DETEC,
                }
            }
            #[doc = "Checks if the value of the field is `NO_START_DETECT_THE`"]
            #[inline(always)]
            pub fn is_no_start_detect_the(&self) -> bool {
                *self == MONRESTARTR::NO_START_DETECT_THE
            }
            #[doc = "Checks if the value of the field is `REPEATED_START_DETEC`"]
            #[inline(always)]
            pub fn is_repeated_start_detec(&self) -> bool {
                *self == MONRESTARTR::REPEATED_START_DETEC
            }
        }
        #[doc = "Possible values of the field `MONNACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MONNACKR {
            #[doc = "Acknowledged. The data currently being provided by the monitor function was acknowledged by at least one master or slave receiver."]
            ACKNOWLEDGED_THE_DA,
            #[doc = "Not acknowledged. The data currently being provided by the monitor function was not acknowledged by any receiver."]
            NOT_ACKNOWLEDGED_TH,
        }
        impl MONNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MONNACKR::ACKNOWLEDGED_THE_DA => false,
                    MONNACKR::NOT_ACKNOWLEDGED_TH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MONNACKR {
                match value {
                    false => MONNACKR::ACKNOWLEDGED_THE_DA,
                    true => MONNACKR::NOT_ACKNOWLEDGED_TH,
                }
            }
            #[doc = "Checks if the value of the field is `ACKNOWLEDGED_THE_DA`"]
            #[inline(always)]
            pub fn is_acknowledged_the_da(&self) -> bool {
                *self == MONNACKR::ACKNOWLEDGED_THE_DA
            }
            #[doc = "Checks if the value of the field is `NOT_ACKNOWLEDGED_TH`"]
            #[inline(always)]
            pub fn is_not_acknowledged_th(&self) -> bool {
                *self == MONNACKR::NOT_ACKNOWLEDGED_TH
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins, and adds indication of Start, Repeated Start, and data Nack."]
            #[inline(always)]
            pub fn monrxdat(&self) -> MONRXDATR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MONRXDATR { bits }
            }
            #[doc = "Bit 8 - Monitor Received Start."]
            #[inline(always)]
            pub fn monstart(&self) -> MONSTARTR {
                MONSTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Monitor Received Repeated Start."]
            #[inline(always)]
            pub fn monrestart(&self) -> MONRESTARTR {
                MONRESTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Monitor Received Nack."]
            #[inline(always)]
            pub fn monnack(&self) -> MONNACKR {
                MONNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
}
#[doc = "I2C-bus interface"]
pub struct I2C {
    register_block: i2c::RegisterBlock,
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    fn deref(&self) -> &i2c::RegisterBlock {
        &self.register_block
    }
}
#[doc = "SPI"]
pub const SPI0: Peripheral<SPI0> = unsafe { Peripheral::new(1074102272) };
#[doc = "SPI"]
pub mod spi0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SPI Configuration register"]
        pub cfg: CFG,
        #[doc = "0x04 - SPI Delay register"]
        pub dly: DLY,
        #[doc = "0x08 - SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
        pub stat: STAT,
        #[doc = "0x0c - SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
        pub intenset: INTENSET,
        #[doc = "0x10 - SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - SPI Receive Data"]
        pub rxdat: RXDAT,
        #[doc = "0x18 - SPI Transmit Data with Control"]
        pub txdatctl: TXDATCTL,
        #[doc = "0x1c - SPI Transmit Data"]
        pub txdat: TXDAT,
        #[doc = "0x20 - SPI Transmit Control"]
        pub txctl: TXCTL,
        #[doc = "0x24 - SPI clock Divider"]
        pub div: DIV,
        #[doc = "0x28 - SPI Interrupt Status"]
        pub intstat: INTSTAT,
    }
    #[doc = "SPI Configuration register"]
    pub struct CFG {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Configuration register"]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `Enable`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            DISABLED_THE_SPI_IS,
            #[doc = "Enabled. The SPI is enabled for operation."]
            ENABLED_THE_SPI_IS_,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED_THE_SPI_IS => false,
                    ENABLER::ENABLED_THE_SPI_IS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED_THE_SPI_IS,
                    true => ENABLER::ENABLED_THE_SPI_IS_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_SPI_IS`"]
            #[inline(always)]
            pub fn is_disabled_the_spi_is(&self) -> bool {
                *self == ENABLER::DISABLED_THE_SPI_IS
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_SPI_IS_`"]
            #[inline(always)]
            pub fn is_enabled_the_spi_is_(&self) -> bool {
                *self == ENABLER::ENABLED_THE_SPI_IS_
            }
        }
        #[doc = "Possible values of the field `Master`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MASTERR {
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            SLAVE_MODE_THE_SPI_,
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            MASTER_MODE_THE_SPI,
        }
        impl MASTERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    MASTERR::SLAVE_MODE_THE_SPI_ => false,
                    MASTERR::MASTER_MODE_THE_SPI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> MASTERR {
                match value {
                    false => MASTERR::SLAVE_MODE_THE_SPI_,
                    true => MASTERR::MASTER_MODE_THE_SPI,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_MODE_THE_SPI_`"]
            #[inline(always)]
            pub fn is_slave_mode_the_spi_(&self) -> bool {
                *self == MASTERR::SLAVE_MODE_THE_SPI_
            }
            #[doc = "Checks if the value of the field is `MASTER_MODE_THE_SPI`"]
            #[inline(always)]
            pub fn is_master_mode_the_spi(&self) -> bool {
                *self == MASTERR::MASTER_MODE_THE_SPI
            }
        }
        #[doc = "Possible values of the field `LSBF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSBFR {
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            STANDARD_DATA_IS_TR,
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            REVERSE_DATA_IS_TRA,
        }
        impl LSBFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LSBFR::STANDARD_DATA_IS_TR => false,
                    LSBFR::REVERSE_DATA_IS_TRA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LSBFR {
                match value {
                    false => LSBFR::STANDARD_DATA_IS_TR,
                    true => LSBFR::REVERSE_DATA_IS_TRA,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_DATA_IS_TR`"]
            #[inline(always)]
            pub fn is_standard_data_is_tr(&self) -> bool {
                *self == LSBFR::STANDARD_DATA_IS_TR
            }
            #[doc = "Checks if the value of the field is `REVERSE_DATA_IS_TRA`"]
            #[inline(always)]
            pub fn is_reverse_data_is_tra(&self) -> bool {
                *self == LSBFR::REVERSE_DATA_IS_TRA
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "Change. The SPI captures serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is changed on the following edge."]
            CHANGE_THE_SPI_CAPT,
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is captured on the following edge."]
            CAPTURE_THE_SPI_CHA,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::CHANGE_THE_SPI_CAPT => false,
                    CPHAR::CAPTURE_THE_SPI_CHA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::CHANGE_THE_SPI_CAPT,
                    true => CPHAR::CAPTURE_THE_SPI_CHA,
                }
            }
            #[doc = "Checks if the value of the field is `CHANGE_THE_SPI_CAPT`"]
            #[inline(always)]
            pub fn is_change_the_spi_capt(&self) -> bool {
                *self == CPHAR::CHANGE_THE_SPI_CAPT
            }
            #[doc = "Checks if the value of the field is `CAPTURE_THE_SPI_CHA`"]
            #[inline(always)]
            pub fn is_capture_the_spi_cha(&self) -> bool {
                *self == CPHAR::CAPTURE_THE_SPI_CHA
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "Low. The rest state of the clock (between frames) is low."]
            LOW_THE_REST_STATE_,
            #[doc = "High. The rest state of the clock (between frames) is high."]
            HIGH_THE_REST_STATE,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::LOW_THE_REST_STATE_ => false,
                    CPOLR::HIGH_THE_REST_STATE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::LOW_THE_REST_STATE_,
                    true => CPOLR::HIGH_THE_REST_STATE,
                }
            }
            #[doc = "Checks if the value of the field is `LOW_THE_REST_STATE_`"]
            #[inline(always)]
            pub fn is_low_the_rest_state_(&self) -> bool {
                *self == CPOLR::LOW_THE_REST_STATE_
            }
            #[doc = "Checks if the value of the field is `HIGH_THE_REST_STATE`"]
            #[inline(always)]
            pub fn is_high_the_rest_state(&self) -> bool {
                *self == CPOLR::HIGH_THE_REST_STATE
            }
        }
        #[doc = "Possible values of the field `Loop`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOOPR {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LOOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOOPR::DISABLED_ => false,
                    LOOPR::ENABLED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOOPR {
                match value {
                    false => LOOPR::DISABLED_,
                    true => LOOPR::ENABLED_,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_`"]
            #[inline(always)]
            pub fn is_disabled_(&self) -> bool {
                *self == LOOPR::DISABLED_
            }
            #[doc = "Checks if the value of the field is `ENABLED_`"]
            #[inline(always)]
            pub fn is_enabled_(&self) -> bool {
                *self == LOOPR::ENABLED_
            }
        }
        #[doc = "Possible values of the field `SPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPOLR {
            #[doc = "Low. The SSEL pin is active low. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is not inverted relative to the pins."]
            LOW_THE_SSEL_PIN_IS,
            #[doc = "High. The SSEL pin is active high. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is inverted relative to the pins."]
            HIGH_THE_SSEL_PIN_I,
        }
        impl SPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SPOLR::LOW_THE_SSEL_PIN_IS => false,
                    SPOLR::HIGH_THE_SSEL_PIN_I => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SPOLR {
                match value {
                    false => SPOLR::LOW_THE_SSEL_PIN_IS,
                    true => SPOLR::HIGH_THE_SSEL_PIN_I,
                }
            }
            #[doc = "Checks if the value of the field is `LOW_THE_SSEL_PIN_IS`"]
            #[inline(always)]
            pub fn is_low_the_ssel_pin_is(&self) -> bool {
                *self == SPOLR::LOW_THE_SSEL_PIN_IS
            }
            #[doc = "Checks if the value of the field is `HIGH_THE_SSEL_PIN_I`"]
            #[inline(always)]
            pub fn is_high_the_ssel_pin_i(&self) -> bool {
                *self == SPOLR::HIGH_THE_SSEL_PIN_I
            }
        }
        #[doc = "Values that can be written to the field `Enable`"]
        pub enum ENABLEW {
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            DISABLED_THE_SPI_IS,
            #[doc = "Enabled. The SPI is enabled for operation."]
            ENABLED_THE_SPI_IS_,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED_THE_SPI_IS => false,
                    ENABLEW::ENABLED_THE_SPI_IS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The SPI is disabled and the internal state machine and counters are reset."]
            #[inline(always)]
            pub fn disabled_the_spi_is(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED_THE_SPI_IS)
            }
            #[doc = "Enabled. The SPI is enabled for operation."]
            #[inline(always)]
            pub fn enabled_the_spi_is_(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED_THE_SPI_IS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `Master`"]
        pub enum MASTERW {
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            SLAVE_MODE_THE_SPI_,
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            MASTER_MODE_THE_SPI,
        }
        impl MASTERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    MASTERW::SLAVE_MODE_THE_SPI_ => false,
                    MASTERW::MASTER_MODE_THE_SPI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASTERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASTERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: MASTERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output."]
            #[inline(always)]
            pub fn slave_mode_the_spi_(self) -> &'a mut W {
                self.variant(MASTERW::SLAVE_MODE_THE_SPI_)
            }
            #[doc = "Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input."]
            #[inline(always)]
            pub fn master_mode_the_spi(self) -> &'a mut W {
                self.variant(MASTERW::MASTER_MODE_THE_SPI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LSBF`"]
        pub enum LSBFW {
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            STANDARD_DATA_IS_TR,
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            REVERSE_DATA_IS_TRA,
        }
        impl LSBFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LSBFW::STANDARD_DATA_IS_TR => false,
                    LSBFW::REVERSE_DATA_IS_TRA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LSBFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LSBFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LSBFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard. Data is transmitted and received in standard MSB first order."]
            #[inline(always)]
            pub fn standard_data_is_tr(self) -> &'a mut W {
                self.variant(LSBFW::STANDARD_DATA_IS_TR)
            }
            #[doc = "Reverse. Data is transmitted and received in reverse order (LSB first)."]
            #[inline(always)]
            pub fn reverse_data_is_tra(self) -> &'a mut W {
                self.variant(LSBFW::REVERSE_DATA_IS_TRA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "Change. The SPI captures serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is changed on the following edge."]
            CHANGE_THE_SPI_CAPT,
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is captured on the following edge."]
            CAPTURE_THE_SPI_CHA,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::CHANGE_THE_SPI_CAPT => false,
                    CPHAW::CAPTURE_THE_SPI_CHA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Change. The SPI captures serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is changed on the following edge."]
            #[inline(always)]
            pub fn change_the_spi_capt(self) -> &'a mut W {
                self.variant(CPHAW::CHANGE_THE_SPI_CAPT)
            }
            #[doc = "Capture. The SPI changes serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is captured on the following edge."]
            #[inline(always)]
            pub fn capture_the_spi_cha(self) -> &'a mut W {
                self.variant(CPHAW::CAPTURE_THE_SPI_CHA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "Low. The rest state of the clock (between frames) is low."]
            LOW_THE_REST_STATE_,
            #[doc = "High. The rest state of the clock (between frames) is high."]
            HIGH_THE_REST_STATE,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::LOW_THE_REST_STATE_ => false,
                    CPOLW::HIGH_THE_REST_STATE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The rest state of the clock (between frames) is low."]
            #[inline(always)]
            pub fn low_the_rest_state_(self) -> &'a mut W {
                self.variant(CPOLW::LOW_THE_REST_STATE_)
            }
            #[doc = "High. The rest state of the clock (between frames) is high."]
            #[inline(always)]
            pub fn high_the_rest_state(self) -> &'a mut W {
                self.variant(CPOLW::HIGH_THE_REST_STATE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `Loop`"]
        pub enum LOOPW {
            #[doc = "Disabled."]
            DISABLED_,
            #[doc = "Enabled."]
            ENABLED_,
        }
        impl LOOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOOPW::DISABLED_ => false,
                    LOOPW::ENABLED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LOOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline(always)]
            pub fn disabled_(self) -> &'a mut W {
                self.variant(LOOPW::DISABLED_)
            }
            #[doc = "Enabled."]
            #[inline(always)]
            pub fn enabled_(self) -> &'a mut W {
                self.variant(LOOPW::ENABLED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SPOL`"]
        pub enum SPOLW {
            #[doc = "Low. The SSEL pin is active low. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is not inverted relative to the pins."]
            LOW_THE_SSEL_PIN_IS,
            #[doc = "High. The SSEL pin is active high. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is inverted relative to the pins."]
            HIGH_THE_SSEL_PIN_I,
        }
        impl SPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SPOLW::LOW_THE_SSEL_PIN_IS => false,
                    SPOLW::HIGH_THE_SSEL_PIN_I => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Low. The SSEL pin is active low. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is not inverted relative to the pins."]
            #[inline(always)]
            pub fn low_the_ssel_pin_is(self) -> &'a mut W {
                self.variant(SPOLW::LOW_THE_SSEL_PIN_IS)
            }
            #[doc = "High. The SSEL pin is active high. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is inverted relative to the pins."]
            #[inline(always)]
            pub fn high_the_ssel_pin_i(self) -> &'a mut W {
                self.variant(SPOLW::HIGH_THE_SSEL_PIN_I)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SPI enable."]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Master mode select."]
            #[inline(always)]
            pub fn master(&self) -> MASTERR {
                MASTERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - LSB First mode enable."]
            #[inline(always)]
            pub fn lsbf(&self) -> LSBFR {
                LSBFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Clock Phase select. ."]
            #[inline(always)]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Clock Polarity select."]
            #[inline(always)]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing."]
            #[inline(always)]
            pub fn loop_(&self) -> LOOPR {
                LOOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - SSEL Polarity select."]
            #[inline(always)]
            pub fn spol(&self) -> SPOLR {
                SPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SPI enable."]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bit 2 - Master mode select."]
            #[inline(always)]
            pub fn master(&mut self) -> _MASTERW {
                _MASTERW { w: self }
            }
            #[doc = "Bit 3 - LSB First mode enable."]
            #[inline(always)]
            pub fn lsbf(&mut self) -> _LSBFW {
                _LSBFW { w: self }
            }
            #[doc = "Bit 4 - Clock Phase select. ."]
            #[inline(always)]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 5 - Clock Polarity select."]
            #[inline(always)]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 7 - Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing."]
            #[inline(always)]
            pub fn loop_(&mut self) -> _LOOPW {
                _LOOPW { w: self }
            }
            #[doc = "Bit 8 - SSEL Polarity select."]
            #[inline(always)]
            pub fn spol(&mut self) -> _SPOLW {
                _SPOLW { w: self }
            }
        }
    }
    #[doc = "SPI Delay register"]
    pub struct DLY {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Delay register"]
    pub mod dly {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLY {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_DELAYR {
            bits: u8,
        }
        impl PRE_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct POST_DELAYR {
            bits: u8,
        }
        impl POST_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_DELAYR {
            bits: u8,
        }
        impl FRAME_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRANSFER_DELAYR {
            bits: u8,
        }
        impl TRANSFER_DELAYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _POST_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POST_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRANSFER_DELAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRANSFER_DELAYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Controls the amount of time between SSEL assertion and the beginning of a data frame. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn pre_delay(&self) -> PRE_DELAYR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_DELAYR { bits }
            }
            #[doc = "Bits 4:7 - Controls the amount of time between the end of a data frame and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn post_delay(&self) -> POST_DELAYR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                POST_DELAYR { bits }
            }
            #[doc = "Bits 8:11 - Controls the minimum amount of time between adjacent data frames. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn frame_delay(&self) -> FRAME_DELAYR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FRAME_DELAYR { bits }
            }
            #[doc = "Bits 12:15 - Controls the minimum amount of time that the SSELs are deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times."]
            #[inline(always)]
            pub fn transfer_delay(&self) -> TRANSFER_DELAYR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRANSFER_DELAYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Controls the amount of time between SSEL assertion and the beginning of a data frame. There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn pre_delay(&mut self) -> _PRE_DELAYW {
                _PRE_DELAYW { w: self }
            }
            #[doc = "Bits 4:7 - Controls the amount of time between the end of a data frame and SSEL deassertion. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn post_delay(&mut self) -> _POST_DELAYW {
                _POST_DELAYW { w: self }
            }
            #[doc = "Bits 8:11 - Controls the minimum amount of time between adjacent data frames. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted."]
            #[inline(always)]
            pub fn frame_delay(&mut self) -> _FRAME_DELAYW {
                _FRAME_DELAYW { w: self }
            }
            #[doc = "Bits 12:15 - Controls the minimum amount of time that the SSELs are deasserted between transfers. 0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times."]
            #[inline(always)]
            pub fn transfer_delay(&mut self) -> _TRANSFER_DELAYW {
                _TRANSFER_DELAYW { w: self }
            }
        }
    }
    #[doc = "SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
    pub struct STAT {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Status. Some status flags can be cleared by writing a 1 to that bit position"]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOVR {
            bits: bool,
        }
        impl RXOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXURR {
            bits: bool,
        }
        impl TXURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSAR {
            bits: bool,
        }
        impl SSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSDR {
            bits: bool,
        }
        impl SSDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STALLEDR {
            bits: bool,
        }
        impl STALLEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENDTRANSFERR {
            bits: bool,
        }
        impl ENDTRANSFERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IDLER {
            bits: bool,
        }
        impl IDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STALLEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STALLEDW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDTRANSFERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDTRANSFERW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register."]
            #[inline(always)]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register."]
            #[inline(always)]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag. This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set."]
            #[inline(always)]
            pub fn rxov(&self) -> RXOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXOVR { bits }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TxUr flag is set. Data transmitted by the SPI should be considered undefined if TxUr is set."]
            #[inline(always)]
            pub fn txur(&self) -> TXURR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXURR { bits }
            }
            #[doc = "Bit 4 - Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software."]
            #[inline(always)]
            pub fn ssa(&self) -> SSAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSAR { bits }
            }
            #[doc = "Bit 5 - Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software."]
            #[inline(always)]
            pub fn ssd(&self) -> SSDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSDR { bits }
            }
            #[doc = "Bit 6 - Stalled status flag. This indicates whether the SPI is currently in a stall condition."]
            #[inline(always)]
            pub fn stalled(&self) -> STALLEDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STALLEDR { bits }
            }
            #[doc = "Bit 7 - End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes Idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FrameDelay and TransferDelay to be inserted."]
            #[inline(always)]
            pub fn endtransfer(&self) -> ENDTRANSFERR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ENDTRANSFERR { bits }
            }
            #[doc = "Bit 8 - Idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data."]
            #[inline(always)]
            pub fn idle(&self) -> IDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IDLER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 258 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register."]
            #[inline(always)]
            pub fn rxrdy(&mut self) -> _RXRDYW {
                _RXRDYW { w: self }
            }
            #[doc = "Bit 1 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register."]
            #[inline(always)]
            pub fn txrdy(&mut self) -> _TXRDYW {
                _TXRDYW { w: self }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag. This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set."]
            #[inline(always)]
            pub fn rxov(&mut self) -> _RXOVW {
                _RXOVW { w: self }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TxUr flag is set. Data transmitted by the SPI should be considered undefined if TxUr is set."]
            #[inline(always)]
            pub fn txur(&mut self) -> _TXURW {
                _TXURW { w: self }
            }
            #[doc = "Bit 4 - Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software."]
            #[inline(always)]
            pub fn ssa(&mut self) -> _SSAW {
                _SSAW { w: self }
            }
            #[doc = "Bit 5 - Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software."]
            #[inline(always)]
            pub fn ssd(&mut self) -> _SSDW {
                _SSDW { w: self }
            }
            #[doc = "Bit 6 - Stalled status flag. This indicates whether the SPI is currently in a stall condition."]
            #[inline(always)]
            pub fn stalled(&mut self) -> _STALLEDW {
                _STALLEDW { w: self }
            }
            #[doc = "Bit 7 - End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes Idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FrameDelay and TransferDelay to be inserted."]
            #[inline(always)]
            pub fn endtransfer(&mut self) -> _ENDTRANSFERW {
                _ENDTRANSFERW { w: self }
            }
            #[doc = "Bit 8 - Idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data."]
            #[inline(always)]
            pub fn idle(&mut self) -> _IDLEW {
                _IDLEW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RXRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXRDYENR {
            #[doc = "No interrupt will be generated when receiver data is available."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            AN_INTERRUPT_WILL_BE,
        }
        impl RXRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RXRDYENR::NO_INTERRUPT_WILL_BE => false,
                    RXRDYENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RXRDYENR {
                match value {
                    false => RXRDYENR::NO_INTERRUPT_WILL_BE,
                    true => RXRDYENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == RXRDYENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == RXRDYENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Possible values of the field `TXRDYEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXRDYENR {
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            AN_INTERRUPT_WILL_BE,
        }
        impl TXRDYENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXRDYENR::NO_INTERRUPT_WILL_BE => false,
                    TXRDYENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXRDYENR {
                match value {
                    false => TXRDYENR::NO_INTERRUPT_WILL_BE,
                    true => TXRDYENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == TXRDYENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == TXRDYENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Possible values of the field `RXOVEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXOVENR {
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            AN_INTERRUPT_WILL_BE,
        }
        impl RXOVENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RXOVENR::NO_INTERRUPT_WILL_BE => false,
                    RXOVENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RXOVENR {
                match value {
                    false => RXOVENR::NO_INTERRUPT_WILL_BE,
                    true => RXOVENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == RXOVENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == RXOVENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Possible values of the field `TXUREN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXURENR {
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            AN_INTERRUPT_WILL_BE,
        }
        impl TXURENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXURENR::NO_INTERRUPT_WILL_BE => false,
                    TXURENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXURENR {
                match value {
                    false => TXURENR::NO_INTERRUPT_WILL_BE,
                    true => TXURENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == TXURENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == TXURENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Possible values of the field `SSAEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSAENR {
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            AN_INTERRUPT_WILL_BE,
        }
        impl SSAENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SSAENR::NO_INTERRUPT_WILL_BE => false,
                    SSAENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SSAENR {
                match value {
                    false => SSAENR::NO_INTERRUPT_WILL_BE,
                    true => SSAENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == SSAENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == SSAENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Possible values of the field `SSDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSDENR {
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            AN_INTERRUPT_WILL_BE,
        }
        impl SSDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SSDENR::NO_INTERRUPT_WILL_BE => false,
                    SSDENR::AN_INTERRUPT_WILL_BE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SSDENR {
                match value {
                    false => SSDENR::NO_INTERRUPT_WILL_BE,
                    true => SSDENR::AN_INTERRUPT_WILL_BE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_no_interrupt_will_be(&self) -> bool {
                *self == SSDENR::NO_INTERRUPT_WILL_BE
            }
            #[doc = "Checks if the value of the field is `AN_INTERRUPT_WILL_BE`"]
            #[inline(always)]
            pub fn is_an_interrupt_will_be(&self) -> bool {
                *self == SSDENR::AN_INTERRUPT_WILL_BE
            }
        }
        #[doc = "Values that can be written to the field `RXRDYEN`"]
        pub enum RXRDYENW {
            #[doc = "No interrupt will be generated when receiver data is available."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            AN_INTERRUPT_WILL_BE,
        }
        impl RXRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXRDYENW::NO_INTERRUPT_WILL_BE => false,
                    RXRDYENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when receiver data is available."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(RXRDYENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated when receiver data is available in the RXDAT register."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(RXRDYENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXRDYEN`"]
        pub enum TXRDYENW {
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            AN_INTERRUPT_WILL_BE,
        }
        impl TXRDYENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXRDYENW::NO_INTERRUPT_WILL_BE => false,
                    TXRDYENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXRDYENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when the transmitter holding register is available."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(TXRDYENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated when data may be written to TXDAT."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(TXRDYENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXOVEN`"]
        pub enum RXOVENW {
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            AN_INTERRUPT_WILL_BE,
        }
        impl RXOVENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXOVENW::NO_INTERRUPT_WILL_BE => false,
                    RXOVENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXOVENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when a receiver overrun occurs."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(RXOVENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated if a receiver overrun occurs."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(RXOVENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXUREN`"]
        pub enum TXURENW {
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            AN_INTERRUPT_WILL_BE,
        }
        impl TXURENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXURENW::NO_INTERRUPT_WILL_BE => false,
                    TXURENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXURENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when the transmitter underruns."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(TXURENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated if the transmitter underruns."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(TXURENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSAEN`"]
        pub enum SSAENW {
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            AN_INTERRUPT_WILL_BE,
        }
        impl SSAENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSAENW::NO_INTERRUPT_WILL_BE => false,
                    SSAENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSAENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(SSAENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated when any Slave Select transitions from deasserted to asserted."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(SSAENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSDEN`"]
        pub enum SSDENW {
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            NO_INTERRUPT_WILL_BE,
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            AN_INTERRUPT_WILL_BE,
        }
        impl SSDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSDENW::NO_INTERRUPT_WILL_BE => false,
                    SSDENW::AN_INTERRUPT_WILL_BE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SSDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            #[inline(always)]
            pub fn no_interrupt_will_be(self) -> &'a mut W {
                self.variant(SSDENW::NO_INTERRUPT_WILL_BE)
            }
            #[doc = "An interrupt will be generated when all asserted Slave Selects transition to deasserted."]
            #[inline(always)]
            pub fn an_interrupt_will_be(self) -> &'a mut W {
                self.variant(SSDENW::AN_INTERRUPT_WILL_BE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Determines whether an interrupt occurs when receiver data is available."]
            #[inline(always)]
            pub fn rxrdyen(&self) -> RXRDYENR {
                RXRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Determines whether an interrupt occurs when the transmitter holding register is available."]
            #[inline(always)]
            pub fn txrdyen(&self) -> TXRDYENR {
                TXRDYENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur."]
            #[inline(always)]
            pub fn rxoven(&self) -> RXOVENR {
                RXOVENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available."]
            #[inline(always)]
            pub fn txuren(&self) -> TXURENR {
                TXURENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Determines whether an interrupt occurs when one or more Slave Select is asserted."]
            #[inline(always)]
            pub fn ssaen(&self) -> SSAENR {
                SSAENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Determines whether an interrupt occurs when all Slave Selects are deasserted."]
            #[inline(always)]
            pub fn ssden(&self) -> SSDENR {
                SSDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Determines whether an interrupt occurs when receiver data is available."]
            #[inline(always)]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 1 - Determines whether an interrupt occurs when the transmitter holding register is available."]
            #[inline(always)]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 2 - Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur."]
            #[inline(always)]
            pub fn rxoven(&mut self) -> _RXOVENW {
                _RXOVENW { w: self }
            }
            #[doc = "Bit 3 - Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available."]
            #[inline(always)]
            pub fn txuren(&mut self) -> _TXURENW {
                _TXURENW { w: self }
            }
            #[doc = "Bit 4 - Determines whether an interrupt occurs when one or more Slave Select is asserted."]
            #[inline(always)]
            pub fn ssaen(&mut self) -> _SSAENW {
                _SSAENW { w: self }
            }
            #[doc = "Bit 5 - Determines whether an interrupt occurs when all Slave Selects are deasserted."]
            #[inline(always)]
            pub fn ssden(&mut self) -> _SSDENW {
                _SSDENW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXOVENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXOVENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXURENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXURENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSAENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSAENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSDENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 1 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 2 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn rxoven(&mut self) -> _RXOVENW {
                _RXOVENW { w: self }
            }
            #[doc = "Bit 3 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn txuren(&mut self) -> _TXURENW {
                _TXURENW { w: self }
            }
            #[doc = "Bit 4 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn ssaen(&mut self) -> _SSAENW {
                _SSAENW { w: self }
            }
            #[doc = "Bit 5 - Writing 1 clears the corresponding bits in the INTENSET register."]
            #[inline(always)]
            pub fn ssden(&mut self) -> _SSDENW {
                _SSDENW { w: self }
            }
        }
    }
    #[doc = "SPI Receive Data"]
    pub struct RXDAT {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Receive Data"]
    pub mod rxdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXSSELNR {
            bits: bool,
        }
        impl RXSSELNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SOTR {
            bits: bool,
        }
        impl SOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Receiver Data. This contains the next piece of received data. The number of bits that are used depends on the FLen setting in TXCTL / TXDATCTL."]
            #[inline(always)]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
            #[doc = "Bit 16 - Slave Select for receive. This field allows the state of the SSEL pin to be saved along with received data. The value will reflect the SSEL pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG."]
            #[inline(always)]
            pub fn rxsseln(&self) -> RXSSELNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXSSELNR { bits }
            }
            #[doc = "Bit 20 - Start of Transfer flag. This flag will be 1 if this is the first frame after SSEL went from deasserted to asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the frame length is greater than 16 bit."]
            #[inline(always)]
            pub fn sot(&self) -> SOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SOTR { bits }
            }
        }
    }
    #[doc = "SPI Transmit Data with Control"]
    pub struct TXDATCTL {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Data with Control"]
    pub mod txdatctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDATCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDATR {
            bits: u16,
        }
        impl TXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `TXSSELN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXSSELNR {
            #[doc = "SSEL  asserted."]
            SSEL_ASSERTED_,
            #[doc = "SSEL not asserted."]
            SSEL_NOT_ASSERTED_,
        }
        impl TXSSELNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXSSELNR::SSEL_ASSERTED_ => false,
                    TXSSELNR::SSEL_NOT_ASSERTED_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXSSELNR {
                match value {
                    false => TXSSELNR::SSEL_ASSERTED_,
                    true => TXSSELNR::SSEL_NOT_ASSERTED_,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL_ASSERTED_`"]
            #[inline(always)]
            pub fn is_ssel_asserted_(&self) -> bool {
                *self == TXSSELNR::SSEL_ASSERTED_
            }
            #[doc = "Checks if the value of the field is `SSEL_NOT_ASSERTED_`"]
            #[inline(always)]
            pub fn is_ssel_not_asserted_(&self) -> bool {
                *self == TXSSELNR::SSEL_NOT_ASSERTED_
            }
        }
        #[doc = "Possible values of the field `EOT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOTR {
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            SSEL_NOT_DEASSERTED_,
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSELs will be deasserted at the end of this piece of data."]
            SSEL_DEASSERTED_THI,
        }
        impl EOTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EOTR::SSEL_NOT_DEASSERTED_ => false,
                    EOTR::SSEL_DEASSERTED_THI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EOTR {
                match value {
                    false => EOTR::SSEL_NOT_DEASSERTED_,
                    true => EOTR::SSEL_DEASSERTED_THI,
                }
            }
            #[doc = "Checks if the value of the field is `SSEL_NOT_DEASSERTED_`"]
            #[inline(always)]
            pub fn is_ssel_not_deasserted_(&self) -> bool {
                *self == EOTR::SSEL_NOT_DEASSERTED_
            }
            #[doc = "Checks if the value of the field is `SSEL_DEASSERTED_THI`"]
            #[inline(always)]
            pub fn is_ssel_deasserted_thi(&self) -> bool {
                *self == EOTR::SSEL_DEASSERTED_THI
            }
        }
        #[doc = "Possible values of the field `EOF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOFR {
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            DATA_NOT_EOF_THIS_P,
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            DATA_EOF_THIS_PIECE,
        }
        impl EOFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    EOFR::DATA_NOT_EOF_THIS_P => false,
                    EOFR::DATA_EOF_THIS_PIECE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> EOFR {
                match value {
                    false => EOFR::DATA_NOT_EOF_THIS_P,
                    true => EOFR::DATA_EOF_THIS_PIECE,
                }
            }
            #[doc = "Checks if the value of the field is `DATA_NOT_EOF_THIS_P`"]
            #[inline(always)]
            pub fn is_data_not_eof_this_p(&self) -> bool {
                *self == EOFR::DATA_NOT_EOF_THIS_P
            }
            #[doc = "Checks if the value of the field is `DATA_EOF_THIS_PIECE`"]
            #[inline(always)]
            pub fn is_data_eof_this_piece(&self) -> bool {
                *self == EOFR::DATA_EOF_THIS_PIECE
            }
        }
        #[doc = "Possible values of the field `RXIGNORE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXIGNORER {
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            READ_RECEIVED_DATA_,
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            IGNORE_RECEIVED_DATA,
        }
        impl RXIGNORER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    RXIGNORER::READ_RECEIVED_DATA_ => false,
                    RXIGNORER::IGNORE_RECEIVED_DATA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> RXIGNORER {
                match value {
                    false => RXIGNORER::READ_RECEIVED_DATA_,
                    true => RXIGNORER::IGNORE_RECEIVED_DATA,
                }
            }
            #[doc = "Checks if the value of the field is `READ_RECEIVED_DATA_`"]
            #[inline(always)]
            pub fn is_read_received_data_(&self) -> bool {
                *self == RXIGNORER::READ_RECEIVED_DATA_
            }
            #[doc = "Checks if the value of the field is `IGNORE_RECEIVED_DATA`"]
            #[inline(always)]
            pub fn is_ignore_received_data(&self) -> bool {
                *self == RXIGNORER::IGNORE_RECEIVED_DATA
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLENR {
            bits: u8,
        }
        impl FLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXSSELN`"]
        pub enum TXSSELNW {
            #[doc = "SSEL  asserted."]
            SSEL_ASSERTED_,
            #[doc = "SSEL not asserted."]
            SSEL_NOT_ASSERTED_,
        }
        impl TXSSELNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXSSELNW::SSEL_ASSERTED_ => false,
                    TXSSELNW::SSEL_NOT_ASSERTED_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXSSELNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXSSELNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXSSELNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL asserted."]
            #[inline(always)]
            pub fn ssel_asserted_(self) -> &'a mut W {
                self.variant(TXSSELNW::SSEL_ASSERTED_)
            }
            #[doc = "SSEL not asserted."]
            #[inline(always)]
            pub fn ssel_not_asserted_(self) -> &'a mut W {
                self.variant(TXSSELNW::SSEL_NOT_ASSERTED_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EOT`"]
        pub enum EOTW {
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            SSEL_NOT_DEASSERTED_,
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSELs will be deasserted at the end of this piece of data."]
            SSEL_DEASSERTED_THI,
        }
        impl EOTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    EOTW::SSEL_NOT_DEASSERTED_ => false,
                    EOTW::SSEL_DEASSERTED_THI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data."]
            #[inline(always)]
            pub fn ssel_not_deasserted_(self) -> &'a mut W {
                self.variant(EOTW::SSEL_NOT_DEASSERTED_)
            }
            #[doc = "SSEL deasserted. This piece of data is treated as the end of a transfer. SSELs will be deasserted at the end of this piece of data."]
            #[inline(always)]
            pub fn ssel_deasserted_thi(self) -> &'a mut W {
                self.variant(EOTW::SSEL_DEASSERTED_THI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EOF`"]
        pub enum EOFW {
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            DATA_NOT_EOF_THIS_P,
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            DATA_EOF_THIS_PIECE,
        }
        impl EOFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    EOFW::DATA_NOT_EOF_THIS_P => false,
                    EOFW::DATA_EOF_THIS_PIECE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: EOFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Data not EOF. This piece of data transmitted is not treated as the end of a frame."]
            #[inline(always)]
            pub fn data_not_eof_this_p(self) -> &'a mut W {
                self.variant(EOFW::DATA_NOT_EOF_THIS_P)
            }
            #[doc = "Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted."]
            #[inline(always)]
            pub fn data_eof_this_piece(self) -> &'a mut W {
                self.variant(EOFW::DATA_EOF_THIS_PIECE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXIGNORE`"]
        pub enum RXIGNOREW {
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            READ_RECEIVED_DATA_,
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            IGNORE_RECEIVED_DATA,
        }
        impl RXIGNOREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXIGNOREW::READ_RECEIVED_DATA_ => false,
                    RXIGNOREW::IGNORE_RECEIVED_DATA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIGNOREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIGNOREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: RXIGNOREW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received."]
            #[inline(always)]
            pub fn read_received_data_(self) -> &'a mut W {
                self.variant(RXIGNOREW::READ_RECEIVED_DATA_)
            }
            #[doc = "Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated."]
            #[inline(always)]
            pub fn ignore_received_data(self) -> &'a mut W {
                self.variant(RXIGNOREW::IGNORE_RECEIVED_DATA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 1 to 16 bits of data to be transmitted."]
            #[inline(always)]
            pub fn txdat(&self) -> TXDATR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXDATR { bits }
            }
            #[doc = "Bit 16 - Transmit Slave Select . This field controls what is output for SSEL in master mode. The active state of the SSEL function is configured by bits in the CFG register."]
            #[inline(always)]
            pub fn txsseln(&self) -> TXSSELNR {
                TXSSELNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register."]
            #[inline(always)]
            pub fn eot(&self) -> EOTR {
                EOTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - End of Frame. Between frames, a delay may be inserted, as defined by the Frame_delay value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits."]
            #[inline(always)]
            pub fn eof(&self) -> EOFR {
                EOFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver to simplify the transmit process."]
            #[inline(always)]
            pub fn rxignore(&self) -> RXIGNORER {
                RXIGNORER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 24:27 - Frame Length. Specifies the frame length from 1 to 16 bits. Note that frame lengths greater than 16 bits are supported by multiple sequential frames Note that if a 1-bit frame is selected, the master function will always insert a delay with a length of one SCK time following the single clock seen on the SCK pin. 0x0 = Data frame is 1 bit in length. 0x1 = Data frame is 1 bit in length. 0x2 = Data frame is 3 bits in length. ... 0xF = Data frame is 16 bits in length."]
            #[inline(always)]
            pub fn flen(&self) -> FLENR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 1 to 16 bits of data to be transmitted."]
            #[inline(always)]
            pub fn txdat(&mut self) -> _TXDATW {
                _TXDATW { w: self }
            }
            #[doc = "Bit 16 - Transmit Slave Select . This field controls what is output for SSEL in master mode. The active state of the SSEL function is configured by bits in the CFG register."]
            #[inline(always)]
            pub fn txsseln(&mut self) -> _TXSSELNW {
                _TXSSELNW { w: self }
            }
            #[doc = "Bit 20 - End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register."]
            #[inline(always)]
            pub fn eot(&mut self) -> _EOTW {
                _EOTW { w: self }
            }
            #[doc = "Bit 21 - End of Frame. Between frames, a delay may be inserted, as defined by the Frame_delay value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits."]
            #[inline(always)]
            pub fn eof(&mut self) -> _EOFW {
                _EOFW { w: self }
            }
            #[doc = "Bit 22 - Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver to simplify the transmit process."]
            #[inline(always)]
            pub fn rxignore(&mut self) -> _RXIGNOREW {
                _RXIGNOREW { w: self }
            }
            #[doc = "Bits 24:27 - Frame Length. Specifies the frame length from 1 to 16 bits. Note that frame lengths greater than 16 bits are supported by multiple sequential frames Note that if a 1-bit frame is selected, the master function will always insert a delay with a length of one SCK time following the single clock seen on the SCK pin. 0x0 = Data frame is 1 bit in length. 0x1 = Data frame is 1 bit in length. 0x2 = Data frame is 3 bits in length. ... 0xF = Data frame is 16 bits in length."]
            #[inline(always)]
            pub fn flen(&mut self) -> _FLENW {
                _FLENW { w: self }
            }
        }
    }
    #[doc = "SPI Transmit Data"]
    pub struct TXDAT {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Data"]
    pub mod txdat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 4 to 16 bits of data to be transmitted."]
            #[inline(always)]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Transmit Data. This field provides from 4 to 16 bits of data to be transmitted."]
            #[inline(always)]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "SPI Transmit Control"]
    pub struct TXCTL {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Transmit Control"]
    pub mod txctl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXCTL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TX_SSELR {
            bits: bool,
        }
        impl TX_SSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOTR {
            bits: bool,
        }
        impl EOTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EOFR {
            bits: bool,
        }
        impl EOFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXIGNORER {
            bits: bool,
        }
        impl RXIGNORER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLENR {
            bits: u8,
        }
        impl FLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_SSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_SSELW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EOFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIGNOREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIGNOREW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Transmit Slave Select."]
            #[inline(always)]
            pub fn tx_ssel(&self) -> TX_SSELR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TX_SSELR { bits }
            }
            #[doc = "Bit 20 - End of Transfer."]
            #[inline(always)]
            pub fn eot(&self) -> EOTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOTR { bits }
            }
            #[doc = "Bit 21 - End of Frame."]
            #[inline(always)]
            pub fn eof(&self) -> EOFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EOFR { bits }
            }
            #[doc = "Bit 22 - Receive Ignore."]
            #[inline(always)]
            pub fn rxignore(&self) -> RXIGNORER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXIGNORER { bits }
            }
            #[doc = "Bits 24:27 - Frame Length."]
            #[inline(always)]
            pub fn flen(&self) -> FLENR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FLENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Transmit Slave Select."]
            #[inline(always)]
            pub fn tx_ssel(&mut self) -> _TX_SSELW {
                _TX_SSELW { w: self }
            }
            #[doc = "Bit 20 - End of Transfer."]
            #[inline(always)]
            pub fn eot(&mut self) -> _EOTW {
                _EOTW { w: self }
            }
            #[doc = "Bit 21 - End of Frame."]
            #[inline(always)]
            pub fn eof(&mut self) -> _EOFW {
                _EOFW { w: self }
            }
            #[doc = "Bit 22 - Receive Ignore."]
            #[inline(always)]
            pub fn rxignore(&mut self) -> _RXIGNOREW {
                _RXIGNOREW { w: self }
            }
            #[doc = "Bits 24:27 - Frame Length."]
            #[inline(always)]
            pub fn flen(&mut self) -> _FLENW {
                _FLENW { w: self }
            }
        }
    }
    #[doc = "SPI clock Divider"]
    pub struct DIV {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI clock Divider"]
    pub mod div {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVVALR {
            bits: u16,
        }
        impl DIVVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Rate divider value -1. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, etc. the maximum possible divide is for the value 0xFFFF, which results in PCLK/65536."]
            #[inline(always)]
            pub fn divval(&self) -> DIVVALR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DIVVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Rate divider value -1. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode. DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, etc. the maximum possible divide is for the value 0xFFFF, which results in PCLK/65536."]
            #[inline(always)]
            pub fn divval(&mut self) -> _DIVVALW {
                _DIVVALW { w: self }
            }
        }
    }
    #[doc = "SPI Interrupt Status"]
    pub struct INTSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI Interrupt Status"]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXOVR {
            bits: bool,
        }
        impl RXOVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXURR {
            bits: bool,
        }
        impl TXURR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSAR {
            bits: bool,
        }
        impl SSAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SSDR {
            bits: bool,
        }
        impl SSDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag."]
            #[inline(always)]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Transmitter Ready flag."]
            #[inline(always)]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 2 - Receiver Overrun interrupt flag."]
            #[inline(always)]
            pub fn rxov(&self) -> RXOVR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXOVR { bits }
            }
            #[doc = "Bit 3 - Transmitter Underrun interrupt flag."]
            #[inline(always)]
            pub fn txur(&self) -> TXURR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXURR { bits }
            }
            #[doc = "Bit 4 - Slave Select Assert."]
            #[inline(always)]
            pub fn ssa(&self) -> SSAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSAR { bits }
            }
            #[doc = "Bit 5 - Slave Select Deassert."]
            #[inline(always)]
            pub fn ssd(&self) -> SSDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SSDR { bits }
            }
        }
    }
}
#[doc = "SPI"]
pub struct SPI0 {
    register_block: spi0::RegisterBlock,
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "SPI1"]
pub const SPI1: Peripheral<SPI1> = unsafe { Peripheral::new(1074118656) };
#[doc = r" Register block"]
pub struct SPI1 {
    register_block: spi0::RegisterBlock,
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USART"]
pub const USART0: Peripheral<USART0> = unsafe { Peripheral::new(1074151424) };
#[doc = "USART"]
pub mod usart0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
        pub cfg: CFG,
        #[doc = "0x04 - USART Control register. USART control settings that are more likely to change during operation."]
        pub ctrl: CTRL,
        #[doc = "0x08 - USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
        pub stat: STAT,
        #[doc = "0x0c - Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
        pub intenset: INTENSET,
        #[doc = "0x10 - Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
        pub intenclr: INTENCLR,
        #[doc = "0x14 - Receiver Data register. Contains the last character received."]
        pub rxdata: RXDATA,
        #[doc = "0x18 - Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together."]
        pub rxdatastat: RXDATASTAT,
        #[doc = "0x1c - Transmit Data register. Data to be transmitted is written here."]
        pub txdata: TXDATA,
        #[doc = "0x20 - Baud Rate Generator register. 16-bit integer baud rate divisor value."]
        pub brg: BRG,
        #[doc = "0x24 - Interrupt status register. Reflects interrupts that are currently enabled."]
        pub intstat: INTSTAT,
    }
    #[doc = "USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
    pub struct CFG {
        register: VolatileCell<u32>,
    }
    #[doc = "USART Configuration register. Basic USART configuration settings that typically are not changed during operation."]
    pub mod cfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts  are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if  enabled because the transmitter has been reset and is therefore available."]
            DISABLED_THE_USART_,
            #[doc = "Enabled. The USART is enabled for operation."]
            ENABLED_THE_USART_I,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED_THE_USART_ => false,
                    ENABLER::ENABLED_THE_USART_I => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED_THE_USART_,
                    true => ENABLER::ENABLED_THE_USART_I,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_USART_`"]
            #[inline(always)]
            pub fn is_disabled_the_usart_(&self) -> bool {
                *self == ENABLER::DISABLED_THE_USART_
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_USART_I`"]
            #[inline(always)]
            pub fn is_enabled_the_usart_i(&self) -> bool {
                *self == ENABLER::ENABLED_THE_USART_I
            }
        }
        #[doc = "Possible values of the field `DATALEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATALENR {
            #[doc = "7 bit Data length."]
            _7_BIT_DATA_LENGTH_,
            #[doc = "8 bit Data length."]
            _8_BIT_DATA_LENGTH_,
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register."]
            _9_BIT_DATA_LENGTH_T,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl DATALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DATALENR::_7_BIT_DATA_LENGTH_ => 0,
                    DATALENR::_8_BIT_DATA_LENGTH_ => 1,
                    DATALENR::_9_BIT_DATA_LENGTH_T => 2,
                    DATALENR::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DATALENR {
                match value {
                    0 => DATALENR::_7_BIT_DATA_LENGTH_,
                    1 => DATALENR::_8_BIT_DATA_LENGTH_,
                    2 => DATALENR::_9_BIT_DATA_LENGTH_T,
                    3 => DATALENR::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_7_BIT_DATA_LENGTH_`"]
            #[inline(always)]
            pub fn is_7_bit_data_length_(&self) -> bool {
                *self == DATALENR::_7_BIT_DATA_LENGTH_
            }
            #[doc = "Checks if the value of the field is `_8_BIT_DATA_LENGTH_`"]
            #[inline(always)]
            pub fn is_8_bit_data_length_(&self) -> bool {
                *self == DATALENR::_8_BIT_DATA_LENGTH_
            }
            #[doc = "Checks if the value of the field is `_9_BIT_DATA_LENGTH_T`"]
            #[inline(always)]
            pub fn is_9_bit_data_length_t(&self) -> bool {
                *self == DATALENR::_9_BIT_DATA_LENGTH_T
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == DATALENR::RESERVED_
            }
        }
        #[doc = "Possible values of the field `PARITYSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PARITYSELR {
            #[doc = "No parity."]
            NO_PARITY_,
            #[doc = "Reserved."]
            RESERVED_,
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            EVEN_PARITY_ADDS_A_,
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            ODD_PARITY_ADDS_A_B,
        }
        impl PARITYSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    PARITYSELR::NO_PARITY_ => 0,
                    PARITYSELR::RESERVED_ => 1,
                    PARITYSELR::EVEN_PARITY_ADDS_A_ => 2,
                    PARITYSELR::ODD_PARITY_ADDS_A_B => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> PARITYSELR {
                match value {
                    0 => PARITYSELR::NO_PARITY_,
                    1 => PARITYSELR::RESERVED_,
                    2 => PARITYSELR::EVEN_PARITY_ADDS_A_,
                    3 => PARITYSELR::ODD_PARITY_ADDS_A_B,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_PARITY_`"]
            #[inline(always)]
            pub fn is_no_parity_(&self) -> bool {
                *self == PARITYSELR::NO_PARITY_
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == PARITYSELR::RESERVED_
            }
            #[doc = "Checks if the value of the field is `EVEN_PARITY_ADDS_A_`"]
            #[inline(always)]
            pub fn is_even_parity_adds_a_(&self) -> bool {
                *self == PARITYSELR::EVEN_PARITY_ADDS_A_
            }
            #[doc = "Checks if the value of the field is `ODD_PARITY_ADDS_A_B`"]
            #[inline(always)]
            pub fn is_odd_parity_adds_a_b(&self) -> bool {
                *self == PARITYSELR::ODD_PARITY_ADDS_A_B
            }
        }
        #[doc = "Possible values of the field `STOPLEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPLENR {
            #[doc = "1 stop bit."]
            _1_STOP_BIT_,
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            _2_STOP_BITS_THIS_SE,
        }
        impl STOPLENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPLENR::_1_STOP_BIT_ => false,
                    STOPLENR::_2_STOP_BITS_THIS_SE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STOPLENR {
                match value {
                    false => STOPLENR::_1_STOP_BIT_,
                    true => STOPLENR::_2_STOP_BITS_THIS_SE,
                }
            }
            #[doc = "Checks if the value of the field is `_1_STOP_BIT_`"]
            #[inline(always)]
            pub fn is_1_stop_bit_(&self) -> bool {
                *self == STOPLENR::_1_STOP_BIT_
            }
            #[doc = "Checks if the value of the field is `_2_STOP_BITS_THIS_SE`"]
            #[inline(always)]
            pub fn is_2_stop_bits_this_se(&self) -> bool {
                *self == STOPLENR::_2_STOP_BITS_THIS_SE
            }
        }
        #[doc = "Possible values of the field `CTSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSENR {
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            NO_FLOW_CONTROL_THE,
            #[doc = "Flow control enabled. The transmitter uses external or internal CTS for flow control purposes."]
            FLOW_CONTROL_ENABLED,
        }
        impl CTSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CTSENR::NO_FLOW_CONTROL_THE => false,
                    CTSENR::FLOW_CONTROL_ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CTSENR {
                match value {
                    false => CTSENR::NO_FLOW_CONTROL_THE,
                    true => CTSENR::FLOW_CONTROL_ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_FLOW_CONTROL_THE`"]
            #[inline(always)]
            pub fn is_no_flow_control_the(&self) -> bool {
                *self == CTSENR::NO_FLOW_CONTROL_THE
            }
            #[doc = "Checks if the value of the field is `FLOW_CONTROL_ENABLED`"]
            #[inline(always)]
            pub fn is_flow_control_enabled(&self) -> bool {
                *self == CTSENR::FLOW_CONTROL_ENABLED
            }
        }
        #[doc = "Possible values of the field `SYNCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCENR {
            #[doc = "Asynchronous mode is selected."]
            ASYNCHRONOUS_MODE_IS,
            #[doc = "Synchronous mode is selected."]
            SYNCHRONOUS_MODE_IS_,
        }
        impl SYNCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCENR::ASYNCHRONOUS_MODE_IS => false,
                    SYNCENR::SYNCHRONOUS_MODE_IS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYNCENR {
                match value {
                    false => SYNCENR::ASYNCHRONOUS_MODE_IS,
                    true => SYNCENR::SYNCHRONOUS_MODE_IS_,
                }
            }
            #[doc = "Checks if the value of the field is `ASYNCHRONOUS_MODE_IS`"]
            #[inline(always)]
            pub fn is_asynchronous_mode_is(&self) -> bool {
                *self == SYNCENR::ASYNCHRONOUS_MODE_IS
            }
            #[doc = "Checks if the value of the field is `SYNCHRONOUS_MODE_IS_`"]
            #[inline(always)]
            pub fn is_synchronous_mode_is_(&self) -> bool {
                *self == SYNCENR::SYNCHRONOUS_MODE_IS_
            }
        }
        #[doc = "Possible values of the field `CLKPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKPOLR {
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            FALLING_EDGE_UN_RXD,
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            RISING_EDGE_UN_RXD_,
        }
        impl CLKPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLKPOLR::FALLING_EDGE_UN_RXD => false,
                    CLKPOLR::RISING_EDGE_UN_RXD_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLKPOLR {
                match value {
                    false => CLKPOLR::FALLING_EDGE_UN_RXD,
                    true => CLKPOLR::RISING_EDGE_UN_RXD_,
                }
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_UN_RXD`"]
            #[inline(always)]
            pub fn is_falling_edge_un_rxd(&self) -> bool {
                *self == CLKPOLR::FALLING_EDGE_UN_RXD
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_UN_RXD_`"]
            #[inline(always)]
            pub fn is_rising_edge_un_rxd_(&self) -> bool {
                *self == CLKPOLR::RISING_EDGE_UN_RXD_
            }
        }
        #[doc = "Possible values of the field `SYNCMST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYNCMSTR {
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            SLAVE_WHEN_SYNCHRON,
            #[doc = "Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin."]
            MASTER_WHEN_SYNCHRO,
        }
        impl SYNCMSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SYNCMSTR::SLAVE_WHEN_SYNCHRON => false,
                    SYNCMSTR::MASTER_WHEN_SYNCHRO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SYNCMSTR {
                match value {
                    false => SYNCMSTR::SLAVE_WHEN_SYNCHRON,
                    true => SYNCMSTR::MASTER_WHEN_SYNCHRO,
                }
            }
            #[doc = "Checks if the value of the field is `SLAVE_WHEN_SYNCHRON`"]
            #[inline(always)]
            pub fn is_slave_when_synchron(&self) -> bool {
                *self == SYNCMSTR::SLAVE_WHEN_SYNCHRON
            }
            #[doc = "Checks if the value of the field is `MASTER_WHEN_SYNCHRO`"]
            #[inline(always)]
            pub fn is_master_when_synchro(&self) -> bool {
                *self == SYNCMSTR::MASTER_WHEN_SYNCHRO
            }
        }
        #[doc = "Possible values of the field `LOOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOOPR {
            #[doc = "Normal operation."]
            NORMAL_OPERATION_,
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            LOOPBACK_MODE_THIS_,
        }
        impl LOOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    LOOPR::NORMAL_OPERATION_ => false,
                    LOOPR::LOOPBACK_MODE_THIS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> LOOPR {
                match value {
                    false => LOOPR::NORMAL_OPERATION_,
                    true => LOOPR::LOOPBACK_MODE_THIS_,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL_OPERATION_`"]
            #[inline(always)]
            pub fn is_normal_operation_(&self) -> bool {
                *self == LOOPR::NORMAL_OPERATION_
            }
            #[doc = "Checks if the value of the field is `LOOPBACK_MODE_THIS_`"]
            #[inline(always)]
            pub fn is_loopback_mode_this_(&self) -> bool {
                *self == LOOPR::LOOPBACK_MODE_THIS_
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts  are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if  enabled because the transmitter has been reset and is therefore available."]
            DISABLED_THE_USART_,
            #[doc = "Enabled. The USART is enabled for operation."]
            ENABLED_THE_USART_I,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED_THE_USART_ => false,
                    ENABLEW::ENABLED_THE_USART_I => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if enabled because the transmitter has been reset and is therefore available."]
            #[inline(always)]
            pub fn disabled_the_usart_(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED_THE_USART_)
            }
            #[doc = "Enabled. The USART is enabled for operation."]
            #[inline(always)]
            pub fn enabled_the_usart_i(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED_THE_USART_I)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DATALEN`"]
        pub enum DATALENW {
            #[doc = "7 bit Data length."]
            _7_BIT_DATA_LENGTH_,
            #[doc = "8 bit Data length."]
            _8_BIT_DATA_LENGTH_,
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register."]
            _9_BIT_DATA_LENGTH_T,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl DATALENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DATALENW::_7_BIT_DATA_LENGTH_ => 0,
                    DATALENW::_8_BIT_DATA_LENGTH_ => 1,
                    DATALENW::_9_BIT_DATA_LENGTH_T => 2,
                    DATALENW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATALENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DATALENW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "7 bit Data length."]
            #[inline(always)]
            pub fn _7_bit_data_length_(self) -> &'a mut W {
                self.variant(DATALENW::_7_BIT_DATA_LENGTH_)
            }
            #[doc = "8 bit Data length."]
            #[inline(always)]
            pub fn _8_bit_data_length_(self) -> &'a mut W {
                self.variant(DATALENW::_8_BIT_DATA_LENGTH_)
            }
            #[doc = "9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register."]
            #[inline(always)]
            pub fn _9_bit_data_length_t(self) -> &'a mut W {
                self.variant(DATALENW::_9_BIT_DATA_LENGTH_T)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(DATALENW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PARITYSEL`"]
        pub enum PARITYSELW {
            #[doc = "No parity."]
            NO_PARITY_,
            #[doc = "Reserved."]
            RESERVED_,
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            EVEN_PARITY_ADDS_A_,
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            ODD_PARITY_ADDS_A_B,
        }
        impl PARITYSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PARITYSELW::NO_PARITY_ => 0,
                    PARITYSELW::RESERVED_ => 1,
                    PARITYSELW::EVEN_PARITY_ADDS_A_ => 2,
                    PARITYSELW::ODD_PARITY_ADDS_A_B => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: PARITYSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No parity."]
            #[inline(always)]
            pub fn no_parity_(self) -> &'a mut W {
                self.variant(PARITYSELW::NO_PARITY_)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(PARITYSELW::RESERVED_)
            }
            #[doc = "Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even."]
            #[inline(always)]
            pub fn even_parity_adds_a_(self) -> &'a mut W {
                self.variant(PARITYSELW::EVEN_PARITY_ADDS_A_)
            }
            #[doc = "Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd."]
            #[inline(always)]
            pub fn odd_parity_adds_a_b(self) -> &'a mut W {
                self.variant(PARITYSELW::ODD_PARITY_ADDS_A_B)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STOPLEN`"]
        pub enum STOPLENW {
            #[doc = "1 stop bit."]
            _1_STOP_BIT_,
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            _2_STOP_BITS_THIS_SE,
        }
        impl STOPLENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPLENW::_1_STOP_BIT_ => false,
                    STOPLENW::_2_STOP_BITS_THIS_SE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPLENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STOPLENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 stop bit."]
            #[inline(always)]
            pub fn _1_stop_bit_(self) -> &'a mut W {
                self.variant(STOPLENW::_1_STOP_BIT_)
            }
            #[doc = "2 stop bits. This setting should only be used for asynchronous communication."]
            #[inline(always)]
            pub fn _2_stop_bits_this_se(self) -> &'a mut W {
                self.variant(STOPLENW::_2_STOP_BITS_THIS_SE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTSEN`"]
        pub enum CTSENW {
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            NO_FLOW_CONTROL_THE,
            #[doc = "Flow control enabled. The transmitter uses external or internal CTS for flow control purposes."]
            FLOW_CONTROL_ENABLED,
        }
        impl CTSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTSENW::NO_FLOW_CONTROL_THE => false,
                    CTSENW::FLOW_CONTROL_ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CTSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No flow control. The transmitter does not receive any automatic flow control signal."]
            #[inline(always)]
            pub fn no_flow_control_the(self) -> &'a mut W {
                self.variant(CTSENW::NO_FLOW_CONTROL_THE)
            }
            #[doc = "Flow control enabled. The transmitter uses external or internal CTS for flow control purposes."]
            #[inline(always)]
            pub fn flow_control_enabled(self) -> &'a mut W {
                self.variant(CTSENW::FLOW_CONTROL_ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCEN`"]
        pub enum SYNCENW {
            #[doc = "Asynchronous mode is selected."]
            ASYNCHRONOUS_MODE_IS,
            #[doc = "Synchronous mode is selected."]
            SYNCHRONOUS_MODE_IS_,
        }
        impl SYNCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCENW::ASYNCHRONOUS_MODE_IS => false,
                    SYNCENW::SYNCHRONOUS_MODE_IS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYNCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Asynchronous mode is selected."]
            #[inline(always)]
            pub fn asynchronous_mode_is(self) -> &'a mut W {
                self.variant(SYNCENW::ASYNCHRONOUS_MODE_IS)
            }
            #[doc = "Synchronous mode is selected."]
            #[inline(always)]
            pub fn synchronous_mode_is_(self) -> &'a mut W {
                self.variant(SYNCENW::SYNCHRONOUS_MODE_IS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKPOL`"]
        pub enum CLKPOLW {
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            FALLING_EDGE_UN_RXD,
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            RISING_EDGE_UN_RXD_,
        }
        impl CLKPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLKPOLW::FALLING_EDGE_UN_RXD => false,
                    CLKPOLW::RISING_EDGE_UN_RXD_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Falling edge. Un_RXD is sampled on the falling edge of SCLK."]
            #[inline(always)]
            pub fn falling_edge_un_rxd(self) -> &'a mut W {
                self.variant(CLKPOLW::FALLING_EDGE_UN_RXD)
            }
            #[doc = "Rising edge. Un_RXD is sampled on the rising edge of SCLK."]
            #[inline(always)]
            pub fn rising_edge_un_rxd_(self) -> &'a mut W {
                self.variant(CLKPOLW::RISING_EDGE_UN_RXD_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYNCMST`"]
        pub enum SYNCMSTW {
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            SLAVE_WHEN_SYNCHRON,
            #[doc = "Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin."]
            MASTER_WHEN_SYNCHRO,
        }
        impl SYNCMSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYNCMSTW::SLAVE_WHEN_SYNCHRON => false,
                    SYNCMSTW::MASTER_WHEN_SYNCHRO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYNCMSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYNCMSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SYNCMSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Slave. When synchronous mode is enabled, the USART is a slave."]
            #[inline(always)]
            pub fn slave_when_synchron(self) -> &'a mut W {
                self.variant(SYNCMSTW::SLAVE_WHEN_SYNCHRON)
            }
            #[doc = "Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin."]
            #[inline(always)]
            pub fn master_when_synchro(self) -> &'a mut W {
                self.variant(SYNCMSTW::MASTER_WHEN_SYNCHRO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOOP`"]
        pub enum LOOPW {
            #[doc = "Normal operation."]
            NORMAL_OPERATION_,
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            LOOPBACK_MODE_THIS_,
        }
        impl LOOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOOPW::NORMAL_OPERATION_ => false,
                    LOOPW::LOOPBACK_MODE_THIS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: LOOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Normal operation."]
            #[inline(always)]
            pub fn normal_operation_(self) -> &'a mut W {
                self.variant(LOOPW::NORMAL_OPERATION_)
            }
            #[doc = "Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN."]
            #[inline(always)]
            pub fn loopback_mode_this_(self) -> &'a mut W {
                self.variant(LOOPW::LOOPBACK_MODE_THIS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - USART Enable."]
            #[inline(always)]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 2:3 - Selects the data size for the USART."]
            #[inline(always)]
            pub fn datalen(&self) -> DATALENR {
                DATALENR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Selects what type of parity is used by the USART."]
            #[inline(always)]
            pub fn paritysel(&self) -> PARITYSELR {
                PARITYSELR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Number of stop bits appended to transmitted data. Only a single stop bit is required for received data."]
            #[inline(always)]
            pub fn stoplen(&self) -> STOPLENR {
                STOPLENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 16.7.3 for more information."]
            #[inline(always)]
            pub fn ctsen(&self) -> CTSENR {
                CTSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Selects synchronous or asynchronous operation."]
            #[inline(always)]
            pub fn syncen(&self) -> SYNCENR {
                SYNCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Selects the clock polarity and sampling edge of received data in synchronous mode."]
            #[inline(always)]
            pub fn clkpol(&self) -> CLKPOLR {
                CLKPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Synchronous mode Master select."]
            #[inline(always)]
            pub fn syncmst(&self) -> SYNCMSTR {
                SYNCMSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Selects data loopback mode."]
            #[inline(always)]
            pub fn loop_(&self) -> LOOPR {
                LOOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - USART Enable."]
            #[inline(always)]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
            #[doc = "Bits 2:3 - Selects the data size for the USART."]
            #[inline(always)]
            pub fn datalen(&mut self) -> _DATALENW {
                _DATALENW { w: self }
            }
            #[doc = "Bits 4:5 - Selects what type of parity is used by the USART."]
            #[inline(always)]
            pub fn paritysel(&mut self) -> _PARITYSELW {
                _PARITYSELW { w: self }
            }
            #[doc = "Bit 6 - Number of stop bits appended to transmitted data. Only a single stop bit is required for received data."]
            #[inline(always)]
            pub fn stoplen(&mut self) -> _STOPLENW {
                _STOPLENW { w: self }
            }
            #[doc = "Bit 9 - CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 16.7.3 for more information."]
            #[inline(always)]
            pub fn ctsen(&mut self) -> _CTSENW {
                _CTSENW { w: self }
            }
            #[doc = "Bit 11 - Selects synchronous or asynchronous operation."]
            #[inline(always)]
            pub fn syncen(&mut self) -> _SYNCENW {
                _SYNCENW { w: self }
            }
            #[doc = "Bit 12 - Selects the clock polarity and sampling edge of received data in synchronous mode."]
            #[inline(always)]
            pub fn clkpol(&mut self) -> _CLKPOLW {
                _CLKPOLW { w: self }
            }
            #[doc = "Bit 14 - Synchronous mode Master select."]
            #[inline(always)]
            pub fn syncmst(&mut self) -> _SYNCMSTW {
                _SYNCMSTW { w: self }
            }
            #[doc = "Bit 15 - Selects data loopback mode."]
            #[inline(always)]
            pub fn loop_(&mut self) -> _LOOPW {
                _LOOPW { w: self }
            }
        }
    }
    #[doc = "USART Control register. USART control settings that are more likely to change during operation."]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "USART Control register. USART control settings that are more likely to change during operation."]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TXBRKEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXBRKENR {
            #[doc = "Normal operation."]
            NORMAL_OPERATION_,
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            CONTINUOUS_BREAK_IS_,
        }
        impl TXBRKENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXBRKENR::NORMAL_OPERATION_ => false,
                    TXBRKENR::CONTINUOUS_BREAK_IS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXBRKENR {
                match value {
                    false => TXBRKENR::NORMAL_OPERATION_,
                    true => TXBRKENR::CONTINUOUS_BREAK_IS_,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL_OPERATION_`"]
            #[inline(always)]
            pub fn is_normal_operation_(&self) -> bool {
                *self == TXBRKENR::NORMAL_OPERATION_
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS_BREAK_IS_`"]
            #[inline(always)]
            pub fn is_continuous_break_is_(&self) -> bool {
                *self == TXBRKENR::CONTINUOUS_BREAK_IS_
            }
        }
        #[doc = "Possible values of the field `ADDRDET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRDETR {
            #[doc = "Enabled. The USART receiver is enabled for all incoming data."]
            ENABLED_THE_USART_R,
            #[doc = "Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            DISABLED_THE_USART_,
        }
        impl ADDRDETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRDETR::ENABLED_THE_USART_R => false,
                    ADDRDETR::DISABLED_THE_USART_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ADDRDETR {
                match value {
                    false => ADDRDETR::ENABLED_THE_USART_R,
                    true => ADDRDETR::DISABLED_THE_USART_,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED_THE_USART_R`"]
            #[inline(always)]
            pub fn is_enabled_the_usart_r(&self) -> bool {
                *self == ADDRDETR::ENABLED_THE_USART_R
            }
            #[doc = "Checks if the value of the field is `DISABLED_THE_USART_`"]
            #[inline(always)]
            pub fn is_disabled_the_usart_(&self) -> bool {
                *self == ADDRDETR::DISABLED_THE_USART_
            }
        }
        #[doc = "Possible values of the field `TXDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDISR {
            #[doc = "Not disabled. USART transmitter is not disabled."]
            NOT_DISABLED_USART_,
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            DISABLED_USART_TRAN,
        }
        impl TXDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDISR::NOT_DISABLED_USART_ => false,
                    TXDISR::DISABLED_USART_TRAN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> TXDISR {
                match value {
                    false => TXDISR::NOT_DISABLED_USART_,
                    true => TXDISR::DISABLED_USART_TRAN,
                }
            }
            #[doc = "Checks if the value of the field is `NOT_DISABLED_USART_`"]
            #[inline(always)]
            pub fn is_not_disabled_usart_(&self) -> bool {
                *self == TXDISR::NOT_DISABLED_USART_
            }
            #[doc = "Checks if the value of the field is `DISABLED_USART_TRAN`"]
            #[inline(always)]
            pub fn is_disabled_usart_tran(&self) -> bool {
                *self == TXDISR::DISABLED_USART_TRAN
            }
        }
        #[doc = "Possible values of the field `CC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCR {
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            CLOCK_ON_CHARACTER_,
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            CONTINUOUS_CLOCK_SC,
        }
        impl CCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CCR::CLOCK_ON_CHARACTER_ => false,
                    CCR::CONTINUOUS_CLOCK_SC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CCR {
                match value {
                    false => CCR::CLOCK_ON_CHARACTER_,
                    true => CCR::CONTINUOUS_CLOCK_SC,
                }
            }
            #[doc = "Checks if the value of the field is `CLOCK_ON_CHARACTER_`"]
            #[inline(always)]
            pub fn is_clock_on_character_(&self) -> bool {
                *self == CCR::CLOCK_ON_CHARACTER_
            }
            #[doc = "Checks if the value of the field is `CONTINUOUS_CLOCK_SC`"]
            #[inline(always)]
            pub fn is_continuous_clock_sc(&self) -> bool {
                *self == CCR::CONTINUOUS_CLOCK_SC
            }
        }
        #[doc = "Possible values of the field `CLRCC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLRCCR {
            #[doc = "No affect on the CC bit."]
            NO_AFFECT_ON_THE_CC_,
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            AUTO_CLEAR_THE_CC_B,
        }
        impl CLRCCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    CLRCCR::NO_AFFECT_ON_THE_CC_ => false,
                    CLRCCR::AUTO_CLEAR_THE_CC_B => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> CLRCCR {
                match value {
                    false => CLRCCR::NO_AFFECT_ON_THE_CC_,
                    true => CLRCCR::AUTO_CLEAR_THE_CC_B,
                }
            }
            #[doc = "Checks if the value of the field is `NO_AFFECT_ON_THE_CC_`"]
            #[inline(always)]
            pub fn is_no_affect_on_the_cc_(&self) -> bool {
                *self == CLRCCR::NO_AFFECT_ON_THE_CC_
            }
            #[doc = "Checks if the value of the field is `AUTO_CLEAR_THE_CC_B`"]
            #[inline(always)]
            pub fn is_auto_clear_the_cc_b(&self) -> bool {
                *self == CLRCCR::AUTO_CLEAR_THE_CC_B
            }
        }
        #[doc = "Values that can be written to the field `TXBRKEN`"]
        pub enum TXBRKENW {
            #[doc = "Normal operation."]
            NORMAL_OPERATION_,
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            CONTINUOUS_BREAK_IS_,
        }
        impl TXBRKENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXBRKENW::NORMAL_OPERATION_ => false,
                    TXBRKENW::CONTINUOUS_BREAK_IS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXBRKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXBRKENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXBRKENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Normal operation."]
            #[inline(always)]
            pub fn normal_operation_(self) -> &'a mut W {
                self.variant(TXBRKENW::NORMAL_OPERATION_)
            }
            #[doc = "Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN."]
            #[inline(always)]
            pub fn continuous_break_is_(self) -> &'a mut W {
                self.variant(TXBRKENW::CONTINUOUS_BREAK_IS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRDET`"]
        pub enum ADDRDETW {
            #[doc = "Enabled. The USART receiver is enabled for all incoming data."]
            ENABLED_THE_USART_R,
            #[doc = "Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            DISABLED_THE_USART_,
        }
        impl ADDRDETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRDETW::ENABLED_THE_USART_R => false,
                    ADDRDETW::DISABLED_THE_USART_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRDETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ADDRDETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled. The USART receiver is enabled for all incoming data."]
            #[inline(always)]
            pub fn enabled_the_usart_r(self) -> &'a mut W {
                self.variant(ADDRDETW::ENABLED_THE_USART_R)
            }
            #[doc = "Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally."]
            #[inline(always)]
            pub fn disabled_the_usart_(self) -> &'a mut W {
                self.variant(ADDRDETW::DISABLED_THE_USART_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDIS`"]
        pub enum TXDISW {
            #[doc = "Not disabled. USART transmitter is not disabled."]
            NOT_DISABLED_USART_,
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            DISABLED_USART_TRAN,
        }
        impl TXDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDISW::NOT_DISABLED_USART_ => false,
                    TXDISW::DISABLED_USART_TRAN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: TXDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Not disabled. USART transmitter is not disabled."]
            #[inline(always)]
            pub fn not_disabled_usart_(self) -> &'a mut W {
                self.variant(TXDISW::NOT_DISABLED_USART_)
            }
            #[doc = "Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control."]
            #[inline(always)]
            pub fn disabled_usart_tran(self) -> &'a mut W {
                self.variant(TXDISW::DISABLED_USART_TRAN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CC`"]
        pub enum CCW {
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            CLOCK_ON_CHARACTER_,
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            CONTINUOUS_CLOCK_SC,
        }
        impl CCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CCW::CLOCK_ON_CHARACTER_ => false,
                    CCW::CONTINUOUS_CLOCK_SC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received."]
            #[inline(always)]
            pub fn clock_on_character_(self) -> &'a mut W {
                self.variant(CCW::CLOCK_ON_CHARACTER_)
            }
            #[doc = "Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD)."]
            #[inline(always)]
            pub fn continuous_clock_sc(self) -> &'a mut W {
                self.variant(CCW::CONTINUOUS_CLOCK_SC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLRCC`"]
        pub enum CLRCCW {
            #[doc = "No affect on the CC bit."]
            NO_AFFECT_ON_THE_CC_,
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            AUTO_CLEAR_THE_CC_B,
        }
        impl CLRCCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    CLRCCW::NO_AFFECT_ON_THE_CC_ => false,
                    CLRCCW::AUTO_CLEAR_THE_CC_B => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLRCCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No affect on the CC bit."]
            #[inline(always)]
            pub fn no_affect_on_the_cc_(self) -> &'a mut W {
                self.variant(CLRCCW::NO_AFFECT_ON_THE_CC_)
            }
            #[doc = "Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time."]
            #[inline(always)]
            pub fn auto_clear_the_cc_b(self) -> &'a mut W {
                self.variant(CLRCCW::AUTO_CLEAR_THE_CC_B)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Break Enable."]
            #[inline(always)]
            pub fn txbrken(&self) -> TXBRKENR {
                TXBRKENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable address detect mode."]
            #[inline(always)]
            pub fn addrdet(&self) -> ADDRDETR {
                ADDRDETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Transmit Disable."]
            #[inline(always)]
            pub fn txdis(&self) -> TXDISR {
                TXDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode."]
            #[inline(always)]
            pub fn cc(&self) -> CCR {
                CCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Clear Continuous Clock."]
            #[inline(always)]
            pub fn clrcc(&self) -> CLRCCR {
                CLRCCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Break Enable."]
            #[inline(always)]
            pub fn txbrken(&mut self) -> _TXBRKENW {
                _TXBRKENW { w: self }
            }
            #[doc = "Bit 2 - Enable address detect mode."]
            #[inline(always)]
            pub fn addrdet(&mut self) -> _ADDRDETW {
                _ADDRDETW { w: self }
            }
            #[doc = "Bit 6 - Transmit Disable."]
            #[inline(always)]
            pub fn txdis(&mut self) -> _TXDISW {
                _TXDISW { w: self }
            }
            #[doc = "Bit 8 - Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode."]
            #[inline(always)]
            pub fn cc(&mut self) -> _CCW {
                _CCW { w: self }
            }
            #[doc = "Bit 9 - Clear Continuous Clock."]
            #[inline(always)]
            pub fn clrcc(&mut self) -> _CLRCCW {
                _CLRCCW { w: self }
            }
        }
    }
    #[doc = "USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
    pub struct STAT {
        register: VolatileCell<u32>,
    }
    #[doc = "USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXIDLER {
            bits: bool,
        }
        impl RXIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXIDLER {
            bits: bool,
        }
        impl TXIDLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSR {
            bits: bool,
        }
        impl CTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSR {
            bits: bool,
        }
        impl DELTACTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISINTR {
            bits: bool,
        }
        impl TXDISINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNINTR {
            bits: bool,
        }
        impl OVERRUNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXBRKR {
            bits: bool,
        }
        impl RXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKR {
            bits: bool,
        }
        impl DELTARXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRINTR {
            bits: bool,
        }
        impl FRAMERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRINTR {
            bits: bool,
        }
        impl PARITYERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEINTR {
            bits: bool,
        }
        impl RXNOISEINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXIDLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXIDLEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXBRKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISEINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISEINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDATA or RXDATASTAT registers."]
            #[inline(always)]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 1 - Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data."]
            #[inline(always)]
            pub fn rxidle(&self) -> RXIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXIDLER { bits }
            }
            #[doc = "Bit 2 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDATA until the data is moved to the transmit shift register."]
            #[inline(always)]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 3 - Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data."]
            #[inline(always)]
            pub fn txidle(&self) -> TXIDLER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXIDLER { bits }
            }
            #[doc = "Bit 4 - This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled."]
            #[inline(always)]
            pub fn cts(&self) -> CTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSR { bits }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software."]
            #[inline(always)]
            pub fn deltacts(&self) -> DELTACTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSR { bits }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1)."]
            #[inline(always)]
            pub fn txdisint(&self) -> TXDISINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISINTR { bits }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost."]
            #[inline(always)]
            pub fn overrunint(&self) -> OVERRUNINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNINTR { bits }
            }
            #[doc = "Bit 10 - Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high."]
            #[inline(always)]
            pub fn rxbrk(&self) -> RXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXBRKR { bits }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs. Cleared by software."]
            #[inline(always)]
            pub fn deltarxbrk(&self) -> DELTARXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKR { bits }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input and subsequently confirmed by a mid-bit sample. Its purpose is primarily to allow wakeup from Power-down mode immediately when a start is detected. Cleared by software."]
            #[inline(always)]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline(always)]
            pub fn framerrint(&self) -> FRAMERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRINTR { bits }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag. This flag is set when a parity error is detected in a received character, if parity is enabled via the Parity field in the CFG register."]
            #[inline(always)]
            pub fn parityerrint(&self) -> PARITYERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRINTR { bits }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. The Noise bit is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception. RXNOISEINT is not updated during a received break."]
            #[inline(always)]
            pub fn rxnoiseint(&self) -> RXNOISEINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEINTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 14 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDATA or RXDATASTAT registers."]
            #[inline(always)]
            pub fn rxrdy(&mut self) -> _RXRDYW {
                _RXRDYW { w: self }
            }
            #[doc = "Bit 1 - Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data."]
            #[inline(always)]
            pub fn rxidle(&mut self) -> _RXIDLEW {
                _RXIDLEW { w: self }
            }
            #[doc = "Bit 2 - Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDATA until the data is moved to the transmit shift register."]
            #[inline(always)]
            pub fn txrdy(&mut self) -> _TXRDYW {
                _TXRDYW { w: self }
            }
            #[doc = "Bit 3 - Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data."]
            #[inline(always)]
            pub fn txidle(&mut self) -> _TXIDLEW {
                _TXIDLEW { w: self }
            }
            #[doc = "Bit 4 - This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled."]
            #[inline(always)]
            pub fn cts(&mut self) -> _CTSW {
                _CTSW { w: self }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software."]
            #[inline(always)]
            pub fn deltacts(&mut self) -> _DELTACTSW {
                _DELTACTSW { w: self }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1)."]
            #[inline(always)]
            pub fn txdisint(&mut self) -> _TXDISINTW {
                _TXDISINTW { w: self }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost."]
            #[inline(always)]
            pub fn overrunint(&mut self) -> _OVERRUNINTW {
                _OVERRUNINTW { w: self }
            }
            #[doc = "Bit 10 - Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high."]
            #[inline(always)]
            pub fn rxbrk(&mut self) -> _RXBRKW {
                _RXBRKW { w: self }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs. Cleared by software."]
            #[inline(always)]
            pub fn deltarxbrk(&mut self) -> _DELTARXBRKW {
                _DELTARXBRKW { w: self }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input and subsequently confirmed by a mid-bit sample. Its purpose is primarily to allow wakeup from Power-down mode immediately when a start is detected. Cleared by software."]
            #[inline(always)]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline(always)]
            pub fn framerrint(&mut self) -> _FRAMERRINTW {
                _FRAMERRINTW { w: self }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag. This flag is set when a parity error is detected in a received character, if parity is enabled via the Parity field in the CFG register."]
            #[inline(always)]
            pub fn parityerrint(&mut self) -> _PARITYERRINTW {
                _PARITYERRINTW { w: self }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. The Noise bit is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception. RXNOISEINT is not updated during a received break."]
            #[inline(always)]
            pub fn rxnoiseint(&mut self) -> _RXNOISEINTW {
                _RXNOISEINTW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYENR {
            bits: bool,
        }
        impl RXRDYENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYENR {
            bits: bool,
        }
        impl TXRDYENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSENR {
            bits: bool,
        }
        impl DELTACTSENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISINTENR {
            bits: bool,
        }
        impl TXDISINTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNENR {
            bits: bool,
        }
        impl OVERRUNENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKENR {
            bits: bool,
        }
        impl DELTARXBRKENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTENR {
            bits: bool,
        }
        impl STARTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRENR {
            bits: bool,
        }
        impl FRAMERRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRENR {
            bits: bool,
        }
        impl PARITYERRENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEENR {
            bits: bool,
        }
        impl RXNOISEENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISINTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISINTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISEENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - When 1, enables an interrupt when there is a received character available to be read from the RXDATA register."]
            #[inline(always)]
            pub fn rxrdyen(&self) -> RXRDYENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYENR { bits }
            }
            #[doc = "Bit 2 - When 1, enables an interrupt when the TXDATA register is available to take another character to transmit."]
            #[inline(always)]
            pub fn txrdyen(&self) -> TXRDYENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYENR { bits }
            }
            #[doc = "Bit 5 - When 1, enables an interrupt when there is a change in the state of the CTS input."]
            #[inline(always)]
            pub fn deltactsen(&self) -> DELTACTSENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSENR { bits }
            }
            #[doc = "Bit 6 - When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details."]
            #[inline(always)]
            pub fn txdisinten(&self) -> TXDISINTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISINTENR { bits }
            }
            #[doc = "Bit 8 - When 1, enables an interrupt when an overrun error occurred."]
            #[inline(always)]
            pub fn overrunen(&self) -> OVERRUNENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNENR { bits }
            }
            #[doc = "Bit 11 - When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted)."]
            #[inline(always)]
            pub fn deltarxbrken(&self) -> DELTARXBRKENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKENR { bits }
            }
            #[doc = "Bit 12 - When 1, enables an interrupt when a received start bit has been detected."]
            #[inline(always)]
            pub fn starten(&self) -> STARTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTENR { bits }
            }
            #[doc = "Bit 13 - When 1, enables an interrupt when a framing error has been detected."]
            #[inline(always)]
            pub fn framerren(&self) -> FRAMERRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRENR { bits }
            }
            #[doc = "Bit 14 - When 1, enables an interrupt when a parity error has been detected."]
            #[inline(always)]
            pub fn parityerren(&self) -> PARITYERRENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRENR { bits }
            }
            #[doc = "Bit 15 - When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 164."]
            #[inline(always)]
            pub fn rxnoiseen(&self) -> RXNOISEENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - When 1, enables an interrupt when there is a received character available to be read from the RXDATA register."]
            #[inline(always)]
            pub fn rxrdyen(&mut self) -> _RXRDYENW {
                _RXRDYENW { w: self }
            }
            #[doc = "Bit 2 - When 1, enables an interrupt when the TXDATA register is available to take another character to transmit."]
            #[inline(always)]
            pub fn txrdyen(&mut self) -> _TXRDYENW {
                _TXRDYENW { w: self }
            }
            #[doc = "Bit 5 - When 1, enables an interrupt when there is a change in the state of the CTS input."]
            #[inline(always)]
            pub fn deltactsen(&mut self) -> _DELTACTSENW {
                _DELTACTSENW { w: self }
            }
            #[doc = "Bit 6 - When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details."]
            #[inline(always)]
            pub fn txdisinten(&mut self) -> _TXDISINTENW {
                _TXDISINTENW { w: self }
            }
            #[doc = "Bit 8 - When 1, enables an interrupt when an overrun error occurred."]
            #[inline(always)]
            pub fn overrunen(&mut self) -> _OVERRUNENW {
                _OVERRUNENW { w: self }
            }
            #[doc = "Bit 11 - When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted)."]
            #[inline(always)]
            pub fn deltarxbrken(&mut self) -> _DELTARXBRKENW {
                _DELTARXBRKENW { w: self }
            }
            #[doc = "Bit 12 - When 1, enables an interrupt when a received start bit has been detected."]
            #[inline(always)]
            pub fn starten(&mut self) -> _STARTENW {
                _STARTENW { w: self }
            }
            #[doc = "Bit 13 - When 1, enables an interrupt when a framing error has been detected."]
            #[inline(always)]
            pub fn framerren(&mut self) -> _FRAMERRENW {
                _FRAMERRENW { w: self }
            }
            #[doc = "Bit 14 - When 1, enables an interrupt when a parity error has been detected."]
            #[inline(always)]
            pub fn parityerren(&mut self) -> _PARITYERRENW {
                _PARITYERRENW { w: self }
            }
            #[doc = "Bit 15 - When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 164."]
            #[inline(always)]
            pub fn rxnoiseen(&mut self) -> _RXNOISEENW {
                _RXNOISEENW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared."]
    pub mod intenclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXRDYCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXRDYCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTACTSCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTACTSCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDISINTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDISINTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DELTARXBRKCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DELTARXBRKCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYERRCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYERRCLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXNOISECLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXNOISECLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn rxrdyclr(&mut self) -> _RXRDYCLRW {
                _RXRDYCLRW { w: self }
            }
            #[doc = "Bit 2 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn txrdyclr(&mut self) -> _TXRDYCLRW {
                _TXRDYCLRW { w: self }
            }
            #[doc = "Bit 5 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn deltactsclr(&mut self) -> _DELTACTSCLRW {
                _DELTACTSCLRW { w: self }
            }
            #[doc = "Bit 6 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn txdisintclr(&mut self) -> _TXDISINTCLRW {
                _TXDISINTCLRW { w: self }
            }
            #[doc = "Bit 8 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn overrunclr(&mut self) -> _OVERRUNCLRW {
                _OVERRUNCLRW { w: self }
            }
            #[doc = "Bit 11 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn deltarxbrkclr(&mut self) -> _DELTARXBRKCLRW {
                _DELTARXBRKCLRW { w: self }
            }
            #[doc = "Bit 12 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn startclr(&mut self) -> _STARTCLRW {
                _STARTCLRW { w: self }
            }
            #[doc = "Bit 13 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn framerrclr(&mut self) -> _FRAMERRCLRW {
                _FRAMERRCLRW { w: self }
            }
            #[doc = "Bit 14 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn parityerrclr(&mut self) -> _PARITYERRCLRW {
                _PARITYERRCLRW { w: self }
            }
            #[doc = "Bit 15 - Writing 1 clears the corresponding bit in the INTENSET register."]
            #[inline(always)]
            pub fn rxnoiseclr(&mut self) -> _RXNOISECLRW {
                _RXNOISECLRW { w: self }
            }
        }
    }
    #[doc = "Receiver Data register. Contains the last character received."]
    pub struct RXDATA {
        register: VolatileCell<u32>,
    }
    #[doc = "Receiver Data register. Contains the last character received."]
    pub mod rxdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDATA {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings."]
            #[inline(always)]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
        }
    }
    #[doc = "Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together."]
    pub struct RXDATASTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together."]
    pub mod rxdatastat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDATASTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDATR {
            bits: u16,
        }
        impl RXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRR {
            bits: bool,
        }
        impl FRAMERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRR {
            bits: bool,
        }
        impl PARITYERRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISER {
            bits: bool,
        }
        impl RXNOISER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings."]
            #[inline(always)]
            pub fn rxdat(&self) -> RXDATR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RXDATR { bits }
            }
            #[doc = "Bit 13 - Framing Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source."]
            #[inline(always)]
            pub fn framerr(&self) -> FRAMERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRR { bits }
            }
            #[doc = "Bit 14 - Parity Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will be set when a parity error is detected in a received character."]
            #[inline(always)]
            pub fn parityerr(&self) -> PARITYERRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRR { bits }
            }
            #[doc = "Bit 15 - Received Noise flag. See description of the RxNoiseInt bit in Table 164."]
            #[inline(always)]
            pub fn rxnoise(&self) -> RXNOISER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISER { bits }
            }
        }
    }
    #[doc = "Transmit Data register. Data to be transmitted is written here."]
    pub struct TXDATA {
        register: VolatileCell<u32>,
    }
    #[doc = "Transmit Data register. Data to be transmitted is written here."]
    pub mod txdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDATR {
            bits: u16,
        }
        impl TXDATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 511;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available."]
            #[inline(always)]
            pub fn txdat(&self) -> TXDATR {
                let bits = {
                    const MASK: u16 = 511;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TXDATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available."]
            #[inline(always)]
            pub fn txdat(&mut self) -> _TXDATW {
                _TXDATW { w: self }
            }
        }
    }
    #[doc = "Baud Rate Generator register. 16-bit integer baud rate divisor value."]
    pub struct BRG {
        register: VolatileCell<u32>,
    }
    #[doc = "Baud Rate Generator register. 16-bit integer baud rate divisor value."]
    pub mod brg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BRG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct BRGVALR {
            bits: u16,
        }
        impl BRGVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _BRGVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BRGVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function."]
            #[inline(always)]
            pub fn brgval(&self) -> BRGVALR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                BRGVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function."]
            #[inline(always)]
            pub fn brgval(&mut self) -> _BRGVALW {
                _BRGVALW { w: self }
            }
        }
    }
    #[doc = "Interrupt status register. Reflects interrupts that are currently enabled."]
    pub struct INTSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt status register. Reflects interrupts that are currently enabled."]
    pub mod intstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INTSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRDYR {
            bits: bool,
        }
        impl RXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRDYR {
            bits: bool,
        }
        impl TXRDYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTACTSR {
            bits: bool,
        }
        impl DELTACTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDISINTR {
            bits: bool,
        }
        impl TXDISINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNINTR {
            bits: bool,
        }
        impl OVERRUNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DELTARXBRKR {
            bits: bool,
        }
        impl DELTARXBRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: bool,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMERRINTR {
            bits: bool,
        }
        impl FRAMERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct PARITYERRINTR {
            bits: bool,
        }
        impl PARITYERRINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXNOISEINTR {
            bits: bool,
        }
        impl RXNOISEINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Ready flag."]
            #[inline(always)]
            pub fn rxrdy(&self) -> RXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRDYR { bits }
            }
            #[doc = "Bit 2 - Transmitter Ready flag."]
            #[inline(always)]
            pub fn txrdy(&self) -> TXRDYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRDYR { bits }
            }
            #[doc = "Bit 5 - This bit is set when a change in the state of the CTS input is detected."]
            #[inline(always)]
            pub fn deltacts(&self) -> DELTACTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTACTSR { bits }
            }
            #[doc = "Bit 6 - Transmitter Disabled Interrupt flag."]
            #[inline(always)]
            pub fn txdisint(&self) -> TXDISINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXDISINTR { bits }
            }
            #[doc = "Bit 8 - Overrun Error interrupt flag."]
            #[inline(always)]
            pub fn overrunint(&self) -> OVERRUNINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNINTR { bits }
            }
            #[doc = "Bit 11 - This bit is set when a change in the state of receiver break detection occurs."]
            #[inline(always)]
            pub fn deltarxbrk(&self) -> DELTARXBRKR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DELTARXBRKR { bits }
            }
            #[doc = "Bit 12 - This bit is set when a start is detected on the receiver input."]
            #[inline(always)]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STARTR { bits }
            }
            #[doc = "Bit 13 - Framing Error interrupt flag."]
            #[inline(always)]
            pub fn framerrint(&self) -> FRAMERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMERRINTR { bits }
            }
            #[doc = "Bit 14 - Parity Error interrupt flag."]
            #[inline(always)]
            pub fn parityerrint(&self) -> PARITYERRINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                PARITYERRINTR { bits }
            }
            #[doc = "Bit 15 - Received Noise interrupt flag."]
            #[inline(always)]
            pub fn rxnoiseint(&self) -> RXNOISEINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXNOISEINTR { bits }
            }
        }
    }
}
#[doc = "USART"]
pub struct USART0 {
    register_block: usart0::RegisterBlock,
}
impl Deref for USART0 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USART1"]
pub const USART1: Peripheral<USART1> = unsafe { Peripheral::new(1074167808) };
#[doc = r" Register block"]
pub struct USART1 {
    register_block: usart0::RegisterBlock,
}
impl Deref for USART1 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "USART2"]
pub const USART2: Peripheral<USART2> = unsafe { Peripheral::new(1074184192) };
#[doc = r" Register block"]
pub struct USART2 {
    register_block: usart0::RegisterBlock,
}
impl Deref for USART2 {
    type Target = usart0::RegisterBlock;
    fn deref(&self) -> &usart0::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Cyclic Redundancy Check (CRC) engine"]
pub const CRC: Peripheral<CRC> = unsafe { Peripheral::new(1342177280) };
#[doc = "Cyclic Redundancy Check (CRC) engine"]
pub mod crc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - CRC mode register"]
        pub mode: MODE,
        #[doc = "0x04 - CRC seed register"]
        pub seed: SEED,
        #[doc = "0x08 - CRC checksum register"]
        pub sum: SUM,
    }
    #[doc = "CRC mode register"]
    pub struct MODE {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC mode register"]
    pub mod mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_POLYR {
            bits: u8,
        }
        impl CRC_POLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIT_RVS_WRR {
            bits: bool,
        }
        impl BIT_RVS_WRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMPL_WRR {
            bits: bool,
        }
        impl CMPL_WRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BIT_RVS_SUMR {
            bits: bool,
        }
        impl BIT_RVS_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMPL_SUMR {
            bits: bool,
        }
        impl CMPL_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_POLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_POLYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIT_RVS_WRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIT_RVS_WRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMPL_WRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMPL_WRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIT_RVS_SUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIT_RVS_SUMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMPL_SUMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMPL_SUMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial"]
            #[inline(always)]
            pub fn crc_poly(&self) -> CRC_POLYR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CRC_POLYR { bits }
            }
            #[doc = "Bit 2 - Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)"]
            #[inline(always)]
            pub fn bit_rvs_wr(&self) -> BIT_RVS_WRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIT_RVS_WRR { bits }
            }
            #[doc = "Bit 3 - Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA"]
            #[inline(always)]
            pub fn cmpl_wr(&self) -> CMPL_WRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMPL_WRR { bits }
            }
            #[doc = "Bit 4 - CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM"]
            #[inline(always)]
            pub fn bit_rvs_sum(&self) -> BIT_RVS_SUMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BIT_RVS_SUMR { bits }
            }
            #[doc = "Bit 5 - CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM"]
            #[inline(always)]
            pub fn cmpl_sum(&self) -> CMPL_SUMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CMPL_SUMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial"]
            #[inline(always)]
            pub fn crc_poly(&mut self) -> _CRC_POLYW {
                _CRC_POLYW { w: self }
            }
            #[doc = "Bit 2 - Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)"]
            #[inline(always)]
            pub fn bit_rvs_wr(&mut self) -> _BIT_RVS_WRW {
                _BIT_RVS_WRW { w: self }
            }
            #[doc = "Bit 3 - Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA"]
            #[inline(always)]
            pub fn cmpl_wr(&mut self) -> _CMPL_WRW {
                _CMPL_WRW { w: self }
            }
            #[doc = "Bit 4 - CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM"]
            #[inline(always)]
            pub fn bit_rvs_sum(&mut self) -> _BIT_RVS_SUMW {
                _BIT_RVS_SUMW { w: self }
            }
            #[doc = "Bit 5 - CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM"]
            #[inline(always)]
            pub fn cmpl_sum(&mut self) -> _CMPL_SUMW {
                _CMPL_SUMW { w: self }
            }
        }
    }
    #[doc = "CRC seed register"]
    pub struct SEED {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC seed register"]
    pub mod seed {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SEED {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_SEEDR {
            bits: u32,
        }
        impl CRC_SEEDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_SEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_SEEDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses."]
            #[inline(always)]
            pub fn crc_seed(&self) -> CRC_SEEDR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRC_SEEDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 65535 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses."]
            #[inline(always)]
            pub fn crc_seed(&mut self) -> _CRC_SEEDW {
                _CRC_SEEDW { w: self }
            }
        }
    }
    #[doc = "CRC checksum register"]
    pub struct SUM {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC checksum register"]
    pub mod sum {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SUM {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRC_SUMR {
            bits: u32,
        }
        impl CRC_SUMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - The most recent CRC sum can be read through this register with selected bit order and 1's complement post-processes."]
            #[inline(always)]
            pub fn crc_sum(&self) -> CRC_SUMR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRC_SUMR { bits }
            }
        }
    }
    #[doc = "CRC data register"]
    pub struct WR_DATA {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC data register"]
    pub mod wr_data {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WR_DATA {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRC_WR_DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRC_WR_DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data written to this register will be taken to perform CRC calculation with selected bit order and 1's complement pre-process. Any write size 8, 16 or 32-bit are allowed and accept back-to-back transactions."]
            #[inline(always)]
            pub fn crc_wr_data(&mut self) -> _CRC_WR_DATAW {
                _CRC_WR_DATAW { w: self }
            }
        }
    }
}
#[doc = "Cyclic Redundancy Check (CRC) engine"]
pub struct CRC {
    register_block: crc::RegisterBlock,
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    fn deref(&self) -> &crc::RegisterBlock {
        &self.register_block
    }
}
#[doc = "State Configurable Timer (SCT)"]
pub const SCT: Peripheral<SCT> = unsafe { Peripheral::new(1342193664) };
#[doc = "State Configurable Timer (SCT)"]
pub mod sct {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - SCT configuration register"]
        pub config: CONFIG,
        #[doc = "0x04 - SCT control register"]
        pub ctrl: CTRL,
        #[doc = "0x08 - SCT limit register"]
        pub limit: LIMIT,
        #[doc = "0x0c - SCT halt condition register"]
        pub halt: HALT,
        #[doc = "0x10 - SCT stop condition register"]
        pub stop: STOP,
        #[doc = "0x14 - SCT start condition register"]
        pub start: START,
        _reserved0: [u8; 40usize],
        #[doc = "0x40 - SCT counter register"]
        pub count: COUNT,
        #[doc = "0x44 - SCT state register"]
        pub state: STATE,
        #[doc = "0x48 - SCT input register"]
        pub input: INPUT,
        #[doc = "0x4c - SCT match/capture registers mode register"]
        pub regmode: REGMODE,
        #[doc = "0x50 - SCT output register"]
        pub output: OUTPUT,
        #[doc = "0x54 - SCT output counter direction control register"]
        pub outputdirctrl: OUTPUTDIRCTRL,
        #[doc = "0x58 - SCT conflict resolution register"]
        pub res: RES,
        _reserved1: [u8; 148usize],
        #[doc = "0xf0 - SCT event enable register"]
        pub even: EVEN,
        #[doc = "0xf4 - SCT event flag register"]
        pub evflag: EVFLAG,
        #[doc = "0xf8 - SCT conflict enable register"]
        pub conen: CONEN,
        #[doc = "0xfc - SCT conflict flag register"]
        pub conflag: CONFLAG,
        #[doc = "0x100 - SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
        pub match0: MATCH,
        #[doc = "0x104 - SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
        pub match1: MATCH,
        #[doc = "0x108 - SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
        pub match2: MATCH,
        #[doc = "0x10c - SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
        pub match3: MATCH,
        #[doc = "0x110 - SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
        pub match4: MATCH,
        _reserved2: [u8; 236usize],
        #[doc = "0x200 - SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
        pub matchrel0: MATCHREL,
        #[doc = "0x204 - SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
        pub matchrel1: MATCHREL,
        #[doc = "0x208 - SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
        pub matchrel2: MATCHREL,
        #[doc = "0x20c - SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
        pub matchrel3: MATCHREL,
        #[doc = "0x210 - SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
        pub matchrel4: MATCHREL,
        _reserved3: [u8; 236usize],
        #[doc = "0x300 - SCT event state register 0"]
        pub ev0_state: EV0_STATE,
        #[doc = "0x304 - SCT event control register 0"]
        pub ev0_ctrl: EV0_CTRL,
        #[doc = "0x308 - SCT event state register 1"]
        pub ev1_state: EV1_STATE,
        #[doc = "0x30c - SCT event control register 1"]
        pub ev1_ctrl: EV1_CTRL,
        #[doc = "0x310 - SCT event state register 2"]
        pub ev2_state: EV2_STATE,
        #[doc = "0x314 - SCT event control register 2"]
        pub ev2_ctrl: EV2_CTRL,
        #[doc = "0x318 - SCT event state register 3"]
        pub ev3_state: EV3_STATE,
        #[doc = "0x31c - SCT event control register 3"]
        pub ev3_ctrl: EV3_CTRL,
        #[doc = "0x320 - SCT event state register 4"]
        pub ev4_state: EV4_STATE,
        #[doc = "0x324 - SCT event control register 4"]
        pub ev4_ctrl: EV4_CTRL,
        #[doc = "0x328 - SCT event state register 5"]
        pub ev5_state: EV5_STATE,
        #[doc = "0x32c - SCT event control register 5"]
        pub ev5_ctrl: EV5_CTRL,
        _reserved4: [u8; 464usize],
        #[doc = "0x500 - SCT output 0 set register"]
        pub out0_set: OUT0_SET,
        #[doc = "0x504 - SCT output 0 clear register"]
        pub out0_clr: OUT0_CLR,
        #[doc = "0x508 - SCT output 1 set register"]
        pub out1_set: OUT1_SET,
        #[doc = "0x50c - SCT output 1 clear register"]
        pub out1_clr: OUT1_CLR,
        #[doc = "0x510 - SCT output 2 set register"]
        pub out2_set: OUT2_SET,
        #[doc = "0x514 - SCT output 2 clear register"]
        pub out2_clr: OUT2_CLR,
        #[doc = "0x518 - SCT output 3 set register"]
        pub out3_set: OUT3_SET,
        #[doc = "0x51c - SCT output 3 clear register"]
        pub out3_clr: OUT3_CLR,
    }
    #[doc = "SCT configuration register"]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT configuration register"]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `UNIFY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UNIFYR {
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            THE_SCT_OPERATES_AS_0,
            #[doc = "The SCT operates as a unified 32-bit counter."]
            THE_SCT_OPERATES_AS_1,
        }
        impl UNIFYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    UNIFYR::THE_SCT_OPERATES_AS_0 => false,
                    UNIFYR::THE_SCT_OPERATES_AS_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> UNIFYR {
                match value {
                    false => UNIFYR::THE_SCT_OPERATES_AS_0,
                    true => UNIFYR::THE_SCT_OPERATES_AS_1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_SCT_OPERATES_AS_0`"]
            #[inline(always)]
            pub fn is_the_sct_operates_as_0(&self) -> bool {
                *self == UNIFYR::THE_SCT_OPERATES_AS_0
            }
            #[doc = "Checks if the value of the field is `THE_SCT_OPERATES_AS_1`"]
            #[inline(always)]
            pub fn is_the_sct_operates_as_1(&self) -> bool {
                *self == UNIFYR::THE_SCT_OPERATES_AS_1
            }
        }
        #[doc = "Possible values of the field `CLKMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKMODER {
            #[doc = "The bus clock clocks the SCT and prescalers."]
            THE_BUS_CLOCK_CLOCKS,
            #[doc = "The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode."]
            THE_SCT_CLOCK_IS_THE,
            #[doc = "The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode."]
            THE_INPUT_SELECTED_B,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl CLKMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLKMODER::THE_BUS_CLOCK_CLOCKS => 0,
                    CLKMODER::THE_SCT_CLOCK_IS_THE => 1,
                    CLKMODER::THE_INPUT_SELECTED_B => 2,
                    CLKMODER::RESERVED_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLKMODER {
                match value {
                    0 => CLKMODER::THE_BUS_CLOCK_CLOCKS,
                    1 => CLKMODER::THE_SCT_CLOCK_IS_THE,
                    2 => CLKMODER::THE_INPUT_SELECTED_B,
                    3 => CLKMODER::RESERVED_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `THE_BUS_CLOCK_CLOCKS`"]
            #[inline(always)]
            pub fn is_the_bus_clock_clocks(&self) -> bool {
                *self == CLKMODER::THE_BUS_CLOCK_CLOCKS
            }
            #[doc = "Checks if the value of the field is `THE_SCT_CLOCK_IS_THE`"]
            #[inline(always)]
            pub fn is_the_sct_clock_is_the(&self) -> bool {
                *self == CLKMODER::THE_SCT_CLOCK_IS_THE
            }
            #[doc = "Checks if the value of the field is `THE_INPUT_SELECTED_B`"]
            #[inline(always)]
            pub fn is_the_input_selected_b(&self) -> bool {
                *self == CLKMODER::THE_INPUT_SELECTED_B
            }
            #[doc = "Checks if the value of the field is `RESERVED_`"]
            #[inline(always)]
            pub fn is_reserved_(&self) -> bool {
                *self == CLKMODER::RESERVED_
            }
        }
        #[doc = "Possible values of the field `CLKSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKSELR {
            #[doc = "Rising edges on input 0."]
            RISING_EDGES_ON_INPU0,
            #[doc = "Falling edges on input 0."]
            FALLING_EDGES_ON_INP0,
            #[doc = "Rising edges on input 1."]
            RISING_EDGES_ON_INPU1,
            #[doc = "Falling edges on input 1."]
            FALLING_EDGES_ON_INP1,
            #[doc = "Rising edges on input 2."]
            RISING_EDGES_ON_INPU2,
            #[doc = "Falling edges on input 2."]
            FALLING_EDGES_ON_INP2,
            #[doc = "Rising edges on input 3."]
            RISING_EDGES_ON_INPU3,
            #[doc = "Falling edges on input 3."]
            FALLING_EDGES_ON_INP3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CLKSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLKSELR::RISING_EDGES_ON_INPU0 => 0,
                    CLKSELR::FALLING_EDGES_ON_INP0 => 1,
                    CLKSELR::RISING_EDGES_ON_INPU1 => 2,
                    CLKSELR::FALLING_EDGES_ON_INP1 => 3,
                    CLKSELR::RISING_EDGES_ON_INPU2 => 4,
                    CLKSELR::FALLING_EDGES_ON_INP2 => 5,
                    CLKSELR::RISING_EDGES_ON_INPU3 => 6,
                    CLKSELR::FALLING_EDGES_ON_INP3 => 7,
                    CLKSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CLKSELR {
                match value {
                    0 => CLKSELR::RISING_EDGES_ON_INPU0,
                    1 => CLKSELR::FALLING_EDGES_ON_INP0,
                    2 => CLKSELR::RISING_EDGES_ON_INPU1,
                    3 => CLKSELR::FALLING_EDGES_ON_INP1,
                    4 => CLKSELR::RISING_EDGES_ON_INPU2,
                    5 => CLKSELR::FALLING_EDGES_ON_INP2,
                    6 => CLKSELR::RISING_EDGES_ON_INPU3,
                    7 => CLKSELR::FALLING_EDGES_ON_INP3,
                    i => CLKSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_ON_INPU0`"]
            #[inline(always)]
            pub fn is_rising_edges_on_inpu0(&self) -> bool {
                *self == CLKSELR::RISING_EDGES_ON_INPU0
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_ON_INP0`"]
            #[inline(always)]
            pub fn is_falling_edges_on_inp0(&self) -> bool {
                *self == CLKSELR::FALLING_EDGES_ON_INP0
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_ON_INPU1`"]
            #[inline(always)]
            pub fn is_rising_edges_on_inpu1(&self) -> bool {
                *self == CLKSELR::RISING_EDGES_ON_INPU1
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_ON_INP1`"]
            #[inline(always)]
            pub fn is_falling_edges_on_inp1(&self) -> bool {
                *self == CLKSELR::FALLING_EDGES_ON_INP1
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_ON_INPU2`"]
            #[inline(always)]
            pub fn is_rising_edges_on_inpu2(&self) -> bool {
                *self == CLKSELR::RISING_EDGES_ON_INPU2
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_ON_INP2`"]
            #[inline(always)]
            pub fn is_falling_edges_on_inp2(&self) -> bool {
                *self == CLKSELR::FALLING_EDGES_ON_INP2
            }
            #[doc = "Checks if the value of the field is `RISING_EDGES_ON_INPU3`"]
            #[inline(always)]
            pub fn is_rising_edges_on_inpu3(&self) -> bool {
                *self == CLKSELR::RISING_EDGES_ON_INPU3
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGES_ON_INP3`"]
            #[inline(always)]
            pub fn is_falling_edges_on_inp3(&self) -> bool {
                *self == CLKSELR::FALLING_EDGES_ON_INP3
            }
        }
        #[doc = r" Value of the field"]
        pub struct NORELAOD_LR {
            bits: bool,
        }
        impl NORELAOD_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct NORELOAD_HR {
            bits: bool,
        }
        impl NORELOAD_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct INSYNCR {
            bits: u8,
        }
        impl INSYNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOLIMIT_LR {
            bits: bool,
        }
        impl AUTOLIMIT_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AUTOLIMIT_HR {
            bits: bool,
        }
        impl AUTOLIMIT_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `UNIFY`"]
        pub enum UNIFYW {
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            THE_SCT_OPERATES_AS_0,
            #[doc = "The SCT operates as a unified 32-bit counter."]
            THE_SCT_OPERATES_AS_1,
        }
        impl UNIFYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    UNIFYW::THE_SCT_OPERATES_AS_0 => false,
                    UNIFYW::THE_SCT_OPERATES_AS_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UNIFYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UNIFYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: UNIFYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SCT operates as two 16-bit counters named L and H."]
            #[inline(always)]
            pub fn the_sct_operates_as_0(self) -> &'a mut W {
                self.variant(UNIFYW::THE_SCT_OPERATES_AS_0)
            }
            #[doc = "The SCT operates as a unified 32-bit counter."]
            #[inline(always)]
            pub fn the_sct_operates_as_1(self) -> &'a mut W {
                self.variant(UNIFYW::THE_SCT_OPERATES_AS_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKMODE`"]
        pub enum CLKMODEW {
            #[doc = "The bus clock clocks the SCT and prescalers."]
            THE_BUS_CLOCK_CLOCKS,
            #[doc = "The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode."]
            THE_SCT_CLOCK_IS_THE,
            #[doc = "The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode."]
            THE_INPUT_SELECTED_B,
            #[doc = "Reserved."]
            RESERVED_,
        }
        impl CLKMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLKMODEW::THE_BUS_CLOCK_CLOCKS => 0,
                    CLKMODEW::THE_SCT_CLOCK_IS_THE => 1,
                    CLKMODEW::THE_INPUT_SELECTED_B => 2,
                    CLKMODEW::RESERVED_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "The bus clock clocks the SCT and prescalers."]
            #[inline(always)]
            pub fn the_bus_clock_clocks(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_BUS_CLOCK_CLOCKS)
            }
            #[doc = "The SCT clock is the bus clock, but the prescalers are enabled to count only when sampling of the input selected by the CKSEL field finds the selected edge. The minimum pulse width on the clock input is 1 bus clock period. This mode is the high-performance sampled-clock mode."]
            #[inline(always)]
            pub fn the_sct_clock_is_the(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_SCT_CLOCK_IS_THE)
            }
            #[doc = "The input selected by CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted. The minimum pulse width on the clock input is 1 bus clock period. This mode is the low-power sampled-clock mode."]
            #[inline(always)]
            pub fn the_input_selected_b(self) -> &'a mut W {
                self.variant(CLKMODEW::THE_INPUT_SELECTED_B)
            }
            #[doc = "Reserved."]
            #[inline(always)]
            pub fn reserved_(self) -> &'a mut W {
                self.variant(CLKMODEW::RESERVED_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKSEL`"]
        pub enum CLKSELW {
            #[doc = "Rising edges on input 0."]
            RISING_EDGES_ON_INPU0,
            #[doc = "Falling edges on input 0."]
            FALLING_EDGES_ON_INP0,
            #[doc = "Rising edges on input 1."]
            RISING_EDGES_ON_INPU1,
            #[doc = "Falling edges on input 1."]
            FALLING_EDGES_ON_INP1,
            #[doc = "Rising edges on input 2."]
            RISING_EDGES_ON_INPU2,
            #[doc = "Falling edges on input 2."]
            FALLING_EDGES_ON_INP2,
            #[doc = "Rising edges on input 3."]
            RISING_EDGES_ON_INPU3,
            #[doc = "Falling edges on input 3."]
            FALLING_EDGES_ON_INP3,
        }
        impl CLKSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLKSELW::RISING_EDGES_ON_INPU0 => 0,
                    CLKSELW::FALLING_EDGES_ON_INP0 => 1,
                    CLKSELW::RISING_EDGES_ON_INPU1 => 2,
                    CLKSELW::FALLING_EDGES_ON_INP1 => 3,
                    CLKSELW::RISING_EDGES_ON_INPU2 => 4,
                    CLKSELW::FALLING_EDGES_ON_INP2 => 5,
                    CLKSELW::RISING_EDGES_ON_INPU3 => 6,
                    CLKSELW::FALLING_EDGES_ON_INP3 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CLKSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Rising edges on input 0."]
            #[inline(always)]
            pub fn rising_edges_on_inpu0(self) -> &'a mut W {
                self.variant(CLKSELW::RISING_EDGES_ON_INPU0)
            }
            #[doc = "Falling edges on input 0."]
            #[inline(always)]
            pub fn falling_edges_on_inp0(self) -> &'a mut W {
                self.variant(CLKSELW::FALLING_EDGES_ON_INP0)
            }
            #[doc = "Rising edges on input 1."]
            #[inline(always)]
            pub fn rising_edges_on_inpu1(self) -> &'a mut W {
                self.variant(CLKSELW::RISING_EDGES_ON_INPU1)
            }
            #[doc = "Falling edges on input 1."]
            #[inline(always)]
            pub fn falling_edges_on_inp1(self) -> &'a mut W {
                self.variant(CLKSELW::FALLING_EDGES_ON_INP1)
            }
            #[doc = "Rising edges on input 2."]
            #[inline(always)]
            pub fn rising_edges_on_inpu2(self) -> &'a mut W {
                self.variant(CLKSELW::RISING_EDGES_ON_INPU2)
            }
            #[doc = "Falling edges on input 2."]
            #[inline(always)]
            pub fn falling_edges_on_inp2(self) -> &'a mut W {
                self.variant(CLKSELW::FALLING_EDGES_ON_INP2)
            }
            #[doc = "Rising edges on input 3."]
            #[inline(always)]
            pub fn rising_edges_on_inpu3(self) -> &'a mut W {
                self.variant(CLKSELW::RISING_EDGES_ON_INPU3)
            }
            #[doc = "Falling edges on input 3."]
            #[inline(always)]
            pub fn falling_edges_on_inp3(self) -> &'a mut W {
                self.variant(CLKSELW::FALLING_EDGES_ON_INP3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NORELAOD_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NORELAOD_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _NORELOAD_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NORELOAD_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _INSYNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INSYNCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOLIMIT_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOLIMIT_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTOLIMIT_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTOLIMIT_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SCT operation"]
            #[inline(always)]
            pub fn unify(&self) -> UNIFYR {
                UNIFYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:2 - SCT clock mode"]
            #[inline(always)]
            pub fn clkmode(&self) -> CLKMODER {
                CLKMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:6 - SCT clock select"]
            #[inline(always)]
            pub fn clksel(&self) -> CLKSELR {
                CLKSELR::_from({
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 7 - A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline(always)]
            pub fn norelaod_l(&self) -> NORELAOD_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NORELAOD_LR { bits }
            }
            #[doc = "Bit 8 - A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline(always)]
            pub fn noreload_h(&self) -> NORELOAD_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                NORELOAD_HR { bits }
            }
            #[doc = "Bits 9:16 - Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 16 = input 7). A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is synchronous to the SCT clock, keep its bit 0 for faster response. When the CKMODE field is 1x, the bit in this field, corresponding to the input selected by the CKSEL field, is not used."]
            #[inline(always)]
            pub fn insync(&self) -> INSYNCR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                INSYNCR { bits }
            }
            #[doc = "Bit 17 - A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline(always)]
            pub fn autolimit_l(&self) -> AUTOLIMIT_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOLIMIT_LR { bits }
            }
            #[doc = "Bit 18 - A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline(always)]
            pub fn autolimit_h(&self) -> AUTOLIMIT_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AUTOLIMIT_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 32256 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SCT operation"]
            #[inline(always)]
            pub fn unify(&mut self) -> _UNIFYW {
                _UNIFYW { w: self }
            }
            #[doc = "Bits 1:2 - SCT clock mode"]
            #[inline(always)]
            pub fn clkmode(&mut self) -> _CLKMODEW {
                _CLKMODEW { w: self }
            }
            #[doc = "Bits 3:6 - SCT clock select"]
            #[inline(always)]
            pub fn clksel(&mut self) -> _CLKSELW {
                _CLKSELW { w: self }
            }
            #[doc = "Bit 7 - A 1 in this bit prevents the lower match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline(always)]
            pub fn norelaod_l(&mut self) -> _NORELAOD_LW {
                _NORELAOD_LW { w: self }
            }
            #[doc = "Bit 8 - A 1 in this bit prevents the higher match registers from being reloaded from their respective reload registers. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline(always)]
            pub fn noreload_h(&mut self) -> _NORELOAD_HW {
                _NORELOAD_HW { w: self }
            }
            #[doc = "Bits 9:16 - Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 16 = input 7). A 1 in one of these bits subjects the corresponding input to synchronization to the SCT clock, before it is used to create an event. If an input is synchronous to the SCT clock, keep its bit 0 for faster response. When the CKMODE field is 1x, the bit in this field, corresponding to the input selected by the CKSEL field, is not used."]
            #[inline(always)]
            pub fn insync(&mut self) -> _INSYNCW {
                _INSYNCW { w: self }
            }
            #[doc = "Bit 17 - A one in this bit causes a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit applies to both the higher and lower registers when the UNIFY bit is set."]
            #[inline(always)]
            pub fn autolimit_l(&mut self) -> _AUTOLIMIT_LW {
                _AUTOLIMIT_LW { w: self }
            }
            #[doc = "Bit 18 - A one in this bit will cause a match on match register 0 to be treated as a de-facto LIMIT condition without the need to define an associated event. As with any LIMIT event, this automatic limit causes the counter to be cleared to zero in uni-directional mode or to change the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is not used when the UNIFY bit is set."]
            #[inline(always)]
            pub fn autolimit_h(&mut self) -> _AUTOLIMIT_HW {
                _AUTOLIMIT_HW { w: self }
            }
        }
    }
    #[doc = "SCT control register"]
    pub struct CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT control register"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DOWN_LR {
            bits: bool,
        }
        impl DOWN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_LR {
            bits: bool,
        }
        impl STOP_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALT_LR {
            bits: bool,
        }
        impl HALT_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRCTR_LR {
            bits: bool,
        }
        impl CLRCTR_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BIDIR_L`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIR_LR {
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            THE_COUNTER_COUNTS_U0,
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            THE_COUNTER_COUNTS_U1,
        }
        impl BIDIR_LR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BIDIR_LR::THE_COUNTER_COUNTS_U0 => false,
                    BIDIR_LR::THE_COUNTER_COUNTS_U1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BIDIR_LR {
                match value {
                    false => BIDIR_LR::THE_COUNTER_COUNTS_U0,
                    true => BIDIR_LR::THE_COUNTER_COUNTS_U1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_COUNTER_COUNTS_U0`"]
            #[inline(always)]
            pub fn is_the_counter_counts_u0(&self) -> bool {
                *self == BIDIR_LR::THE_COUNTER_COUNTS_U0
            }
            #[doc = "Checks if the value of the field is `THE_COUNTER_COUNTS_U1`"]
            #[inline(always)]
            pub fn is_the_counter_counts_u1(&self) -> bool {
                *self == BIDIR_LR::THE_COUNTER_COUNTS_U1
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_LR {
            bits: u8,
        }
        impl PRE_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct DOWN_HR {
            bits: bool,
        }
        impl DOWN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOP_HR {
            bits: bool,
        }
        impl STOP_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALT_HR {
            bits: bool,
        }
        impl HALT_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRCTR_HR {
            bits: bool,
        }
        impl CLRCTR_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `BIDIR_H`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIR_HR {
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            THE_H_COUNTER_COUNTS0,
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            THE_H_COUNTER_COUNTS1,
        }
        impl BIDIR_HR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    BIDIR_HR::THE_H_COUNTER_COUNTS0 => false,
                    BIDIR_HR::THE_H_COUNTER_COUNTS1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> BIDIR_HR {
                match value {
                    false => BIDIR_HR::THE_H_COUNTER_COUNTS0,
                    true => BIDIR_HR::THE_H_COUNTER_COUNTS1,
                }
            }
            #[doc = "Checks if the value of the field is `THE_H_COUNTER_COUNTS0`"]
            #[inline(always)]
            pub fn is_the_h_counter_counts0(&self) -> bool {
                *self == BIDIR_HR::THE_H_COUNTER_COUNTS0
            }
            #[doc = "Checks if the value of the field is `THE_H_COUNTER_COUNTS1`"]
            #[inline(always)]
            pub fn is_the_h_counter_counts1(&self) -> bool {
                *self == BIDIR_HR::THE_H_COUNTER_COUNTS1
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRE_HR {
            bits: u8,
        }
        impl PRE_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWN_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALT_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALT_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCTR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCTR_LW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BIDIR_L`"]
        pub enum BIDIR_LW {
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            THE_COUNTER_COUNTS_U0,
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            THE_COUNTER_COUNTS_U1,
        }
        impl BIDIR_LW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BIDIR_LW::THE_COUNTER_COUNTS_U0 => false,
                    BIDIR_LW::THE_COUNTER_COUNTS_U1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIR_LW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIR_LW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The counter counts up to its limit condition, then is cleared to zero."]
            #[inline(always)]
            pub fn the_counter_counts_u0(self) -> &'a mut W {
                self.variant(BIDIR_LW::THE_COUNTER_COUNTS_U0)
            }
            #[doc = "The counter counts up to its limit, then counts down to a limit condition or to 0."]
            #[inline(always)]
            pub fn the_counter_counts_u1(self) -> &'a mut W {
                self.variant(BIDIR_LW::THE_COUNTER_COUNTS_U1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWN_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOP_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOP_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALT_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALT_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRCTR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRCTR_HW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BIDIR_H`"]
        pub enum BIDIR_HW {
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            THE_H_COUNTER_COUNTS0,
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            THE_H_COUNTER_COUNTS1,
        }
        impl BIDIR_HW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    BIDIR_HW::THE_H_COUNTER_COUNTS0 => false,
                    BIDIR_HW::THE_H_COUNTER_COUNTS1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BIDIR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BIDIR_HW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: BIDIR_HW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The H counter counts up to its limit condition, then is cleared to zero."]
            #[inline(always)]
            pub fn the_h_counter_counts0(self) -> &'a mut W {
                self.variant(BIDIR_HW::THE_H_COUNTER_COUNTS0)
            }
            #[doc = "The H counter counts up to its limit, then counts down to a limit condition or to 0."]
            #[inline(always)]
            pub fn the_h_counter_counts1(self) -> &'a mut W {
                self.variant(BIDIR_HW::THE_H_COUNTER_COUNTS1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRE_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRE_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - This bit is 1 when the L or unified counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline(always)]
            pub fn down_l(&self) -> DOWN_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DOWN_LR { bits }
            }
            #[doc = "Bit 1 - When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline(always)]
            pub fn stop_l(&self) -> STOP_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_LR { bits }
            }
            #[doc = "Bit 2 - When this bit is 1, the L or unified counter does not run and no events can occur. A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation."]
            #[inline(always)]
            pub fn halt_l(&self) -> HALT_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HALT_LR { bits }
            }
            #[doc = "Bit 3 - Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0."]
            #[inline(always)]
            pub fn clrctr_l(&self) -> CLRCTR_LR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRCTR_LR { bits }
            }
            #[doc = "Bit 4 - L or unified counter direction select"]
            #[inline(always)]
            pub fn bidir_l(&self) -> BIDIR_LR {
                BIDIR_LR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 5:12 - Specifies the factor by which the SCT clock is prescaled to produce the L or unified counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRE_L+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline(always)]
            pub fn pre_l(&self) -> PRE_LR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_LR { bits }
            }
            #[doc = "Bit 16 - This bit is 1 when the H counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline(always)]
            pub fn down_h(&self) -> DOWN_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DOWN_HR { bits }
            }
            #[doc = "Bit 17 - When this bit is 1 and HALT is 0, the H counter does not, run but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline(always)]
            pub fn stop_h(&self) -> STOP_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOP_HR { bits }
            }
            #[doc = "Bit 18 - When this bit is 1, the H counter does not run and no events can occur. A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation."]
            #[inline(always)]
            pub fn halt_h(&self) -> HALT_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                HALT_HR { bits }
            }
            #[doc = "Bit 19 - Writing a 1 to this bit clears the H counter. This bit always reads as 0."]
            #[inline(always)]
            pub fn clrctr_h(&self) -> CLRCTR_HR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CLRCTR_HR { bits }
            }
            #[doc = "Bit 20 - Direction select"]
            #[inline(always)]
            pub fn bidir_h(&self) -> BIDIR_HR {
                BIDIR_HR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 21:28 - Specifies the factor by which the SCT clock is prescaled to produce the H counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRELH+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline(always)]
            pub fn pre_h(&self) -> PRE_HR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRE_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 262148 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - This bit is 1 when the L or unified counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline(always)]
            pub fn down_l(&mut self) -> _DOWN_LW {
                _DOWN_LW { w: self }
            }
            #[doc = "Bit 1 - When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline(always)]
            pub fn stop_l(&mut self) -> _STOP_LW {
                _STOP_LW { w: self }
            }
            #[doc = "Bit 2 - When this bit is 1, the L or unified counter does not run and no events can occur. A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation."]
            #[inline(always)]
            pub fn halt_l(&mut self) -> _HALT_LW {
                _HALT_LW { w: self }
            }
            #[doc = "Bit 3 - Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0."]
            #[inline(always)]
            pub fn clrctr_l(&mut self) -> _CLRCTR_LW {
                _CLRCTR_LW { w: self }
            }
            #[doc = "Bit 4 - L or unified counter direction select"]
            #[inline(always)]
            pub fn bidir_l(&mut self) -> _BIDIR_LW {
                _BIDIR_LW { w: self }
            }
            #[doc = "Bits 5:12 - Specifies the factor by which the SCT clock is prescaled to produce the L or unified counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRE_L+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline(always)]
            pub fn pre_l(&mut self) -> _PRE_LW {
                _PRE_LW { w: self }
            }
            #[doc = "Bit 16 - This bit is 1 when the H counter is counting down. Hardware sets this bit when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0."]
            #[inline(always)]
            pub fn down_h(&mut self) -> _DOWN_HW {
                _DOWN_HW { w: self }
            }
            #[doc = "Bit 17 - When this bit is 1 and HALT is 0, the H counter does not, run but I/O events related to the counter can occur. If such an event matches the mask in the Start register, this bit is cleared and counting resumes."]
            #[inline(always)]
            pub fn stop_h(&mut self) -> _STOP_HW {
                _STOP_HW { w: self }
            }
            #[doc = "Bit 18 - When this bit is 1, the H counter does not run and no events can occur. A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation."]
            #[inline(always)]
            pub fn halt_h(&mut self) -> _HALT_HW {
                _HALT_HW { w: self }
            }
            #[doc = "Bit 19 - Writing a 1 to this bit clears the H counter. This bit always reads as 0."]
            #[inline(always)]
            pub fn clrctr_h(&mut self) -> _CLRCTR_HW {
                _CLRCTR_HW { w: self }
            }
            #[doc = "Bit 20 - Direction select"]
            #[inline(always)]
            pub fn bidir_h(&mut self) -> _BIDIR_HW {
                _BIDIR_HW { w: self }
            }
            #[doc = "Bits 21:28 - Specifies the factor by which the SCT clock is prescaled to produce the H counter clock. The counter clock is clocked at the rate of the SCT clock divided by PRELH+1. Clear the counter (by writing a 1 to the CLRCTR bit) whenever changing the PRE value."]
            #[inline(always)]
            pub fn pre_h(&mut self) -> _PRE_HW {
                _PRE_HW { w: self }
            }
        }
    }
    #[doc = "SCT limit register"]
    pub struct LIMIT {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT limit register"]
    pub mod limit {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LIMIT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LIMMSK_LR {
            bits: u8,
        }
        impl LIMMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct LIMMSK_HR {
            bits: u8,
        }
        impl LIMMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LIMMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LIMMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LIMMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LIMMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn limmsk_l(&self) -> LIMMSK_LR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LIMMSK_LR { bits }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn limmsk_h(&self) -> LIMMSK_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LIMMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn limmsk_l(&mut self) -> _LIMMSK_LW {
                _LIMMSK_LW { w: self }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn limmsk_h(&mut self) -> _LIMMSK_HW {
                _LIMMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT halt condition register"]
    pub struct HALT {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT halt condition register"]
    pub mod halt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::HALT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALTMSK_LR {
            bits: u8,
        }
        impl HALTMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct HALTMSK_HR {
            bits: u8,
        }
        impl HALTMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn haltmsk_l(&self) -> HALTMSK_LR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HALTMSK_LR { bits }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn haltmsk_h(&self) -> HALTMSK_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                HALTMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn haltmsk_l(&mut self) -> _HALTMSK_LW {
                _HALTMSK_LW { w: self }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn haltmsk_h(&mut self) -> _HALTMSK_HW {
                _HALTMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT stop condition register"]
    pub struct STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT stop condition register"]
    pub mod stop {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STOP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPMSK_LR {
            bits: u8,
        }
        impl STOPMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPMSK_HR {
            bits: u8,
        }
        impl STOPMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn stopmsk_l(&self) -> STOPMSK_LR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPMSK_LR { bits }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn stopmsk_h(&self) -> STOPMSK_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STOPMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn stopmsk_l(&mut self) -> _STOPMSK_LW {
                _STOPMSK_LW { w: self }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn stopmsk_h(&mut self) -> _STOPMSK_HW {
                _STOPMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT start condition register"]
    pub struct START {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT start condition register"]
    pub mod start {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::START {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTMSK_LR {
            bits: u8,
        }
        impl STARTMSK_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTMSK_HR {
            bits: u8,
        }
        impl STARTMSK_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTMSK_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTMSK_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTMSK_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTMSK_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn startmsk_l(&self) -> STARTMSK_LR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTMSK_LR { bits }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn startmsk_h(&self) -> STARTMSK_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STARTMSK_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5)."]
            #[inline(always)]
            pub fn startmsk_l(&mut self) -> _STARTMSK_LW {
                _STARTMSK_LW { w: self }
            }
            #[doc = "Bits 16:20 - If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20)."]
            #[inline(always)]
            pub fn startmsk_h(&mut self) -> _STARTMSK_HW {
                _STARTMSK_HW { w: self }
            }
        }
    }
    #[doc = "SCT counter register"]
    pub struct COUNT {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT counter register"]
    pub mod count {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::COUNT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTR_LR {
            bits: u16,
        }
        impl CTR_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTR_HR {
            bits: u16,
        }
        impl CTR_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTR_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTR_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTR_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTR_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter."]
            #[inline(always)]
            pub fn ctr_l(&self) -> CTR_LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CTR_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter."]
            #[inline(always)]
            pub fn ctr_h(&self) -> CTR_HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CTR_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter."]
            #[inline(always)]
            pub fn ctr_l(&mut self) -> _CTR_LW {
                _CTR_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter."]
            #[inline(always)]
            pub fn ctr_h(&mut self) -> _CTR_HW {
                _CTR_HW { w: self }
            }
        }
    }
    #[doc = "SCT state register"]
    pub struct STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT state register"]
    pub mod state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE_LR {
            bits: u8,
        }
        impl STATE_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATE_HR {
            bits: u8,
        }
        impl STATE_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATE_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATE_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATE_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATE_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - State variable."]
            #[inline(always)]
            pub fn state_l(&self) -> STATE_LR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATE_LR { bits }
            }
            #[doc = "Bits 16:20 - State variable."]
            #[inline(always)]
            pub fn state_h(&self) -> STATE_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATE_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - State variable."]
            #[inline(always)]
            pub fn state_l(&mut self) -> _STATE_LW {
                _STATE_LW { w: self }
            }
            #[doc = "Bits 16:20 - State variable."]
            #[inline(always)]
            pub fn state_h(&mut self) -> _STATE_HW {
                _STATE_HW { w: self }
            }
        }
    }
    #[doc = "SCT input register"]
    pub struct INPUT {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT input register"]
    pub mod input {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::INPUT {
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN0R {
            bits: bool,
        }
        impl AIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN1R {
            bits: bool,
        }
        impl AIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN2R {
            bits: bool,
        }
        impl AIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct AIN3R {
            bits: bool,
        }
        impl AIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN0R {
            bits: bool,
        }
        impl SIN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN1R {
            bits: bool,
        }
        impl SIN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN2R {
            bits: bool,
        }
        impl SIN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIN3R {
            bits: bool,
        }
        impl SIN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Real-time status of input 0."]
            #[inline(always)]
            pub fn ain0(&self) -> AIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN0R { bits }
            }
            #[doc = "Bit 1 - Real-time status of input 1."]
            #[inline(always)]
            pub fn ain1(&self) -> AIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN1R { bits }
            }
            #[doc = "Bit 2 - Real-time status of input 2."]
            #[inline(always)]
            pub fn ain2(&self) -> AIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN2R { bits }
            }
            #[doc = "Bit 3 - Real-time status of input 3."]
            #[inline(always)]
            pub fn ain3(&self) -> AIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AIN3R { bits }
            }
            #[doc = "Bit 16 - Input 0 state synchronized to the SCT clock."]
            #[inline(always)]
            pub fn sin0(&self) -> SIN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN0R { bits }
            }
            #[doc = "Bit 17 - Input 1 state synchronized to the SCT clock."]
            #[inline(always)]
            pub fn sin1(&self) -> SIN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN1R { bits }
            }
            #[doc = "Bit 18 - Input 2 state synchronized to the SCT clock."]
            #[inline(always)]
            pub fn sin2(&self) -> SIN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN2R { bits }
            }
            #[doc = "Bit 19 - Input 3 state synchronized to the SCT clock."]
            #[inline(always)]
            pub fn sin3(&self) -> SIN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIN3R { bits }
            }
        }
    }
    #[doc = "SCT match/capture registers mode register"]
    pub struct REGMODE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT match/capture registers mode register"]
    pub mod regmode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REGMODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct REGMOD_LR {
            bits: u8,
        }
        impl REGMOD_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct REGMOD_HR {
            bits: u8,
        }
        impl REGMOD_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _REGMOD_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REGMOD_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _REGMOD_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REGMOD_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Each bit controls one pair of match/capture registers (register 0 = bit 0, register 1 = bit 1,..., register 4 = bit 4). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline(always)]
            pub fn regmod_l(&self) -> REGMOD_LR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REGMOD_LR { bits }
            }
            #[doc = "Bits 16:19 - Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 4 = bit 19). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline(always)]
            pub fn regmod_h(&self) -> REGMOD_HR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                REGMOD_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Each bit controls one pair of match/capture registers (register 0 = bit 0, register 1 = bit 1,..., register 4 = bit 4). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline(always)]
            pub fn regmod_l(&mut self) -> _REGMOD_LW {
                _REGMOD_LW { w: self }
            }
            #[doc = "Bits 16:19 - Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 4 = bit 19). 0 = registers operate as match registers. 1 = registers operate as capture registers."]
            #[inline(always)]
            pub fn regmod_h(&mut self) -> _REGMOD_HW {
                _REGMOD_HW { w: self }
            }
        }
    }
    #[doc = "SCT output register"]
    pub struct OUTPUT {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output register"]
    pub mod output {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OUTR {
            bits: u8,
        }
        impl OUTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn out(&self) -> OUTR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                OUTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn out(&mut self) -> _OUTW {
                _OUTW { w: self }
            }
        }
    }
    #[doc = "SCT output counter direction control register"]
    pub struct OUTPUTDIRCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output counter direction control register"]
    pub mod outputdirctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPUTDIRCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SETCLR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR0R {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR0R::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR0R::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR0R::SET_AND_CLEAR_ARE_RE1 => 2,
                    SETCLR0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SETCLR0R {
                match value {
                    0 => SETCLR0R::SET_AND_CLEAR_DO_NOT,
                    1 => SETCLR0R::SET_AND_CLEAR_ARE_RE0,
                    2 => SETCLR0R::SET_AND_CLEAR_ARE_RE1,
                    i => SETCLR0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_DO_NOT`"]
            #[inline(always)]
            pub fn is_set_and_clear_do_not(&self) -> bool {
                *self == SETCLR0R::SET_AND_CLEAR_DO_NOT
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE0`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re0(&self) -> bool {
                *self == SETCLR0R::SET_AND_CLEAR_ARE_RE0
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE1`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re1(&self) -> bool {
                *self == SETCLR0R::SET_AND_CLEAR_ARE_RE1
            }
        }
        #[doc = "Possible values of the field `SETCLR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR1R {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR1R::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR1R::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR1R::SET_AND_CLEAR_ARE_RE1 => 2,
                    SETCLR1R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SETCLR1R {
                match value {
                    0 => SETCLR1R::SET_AND_CLEAR_DO_NOT,
                    1 => SETCLR1R::SET_AND_CLEAR_ARE_RE0,
                    2 => SETCLR1R::SET_AND_CLEAR_ARE_RE1,
                    i => SETCLR1R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_DO_NOT`"]
            #[inline(always)]
            pub fn is_set_and_clear_do_not(&self) -> bool {
                *self == SETCLR1R::SET_AND_CLEAR_DO_NOT
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE0`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re0(&self) -> bool {
                *self == SETCLR1R::SET_AND_CLEAR_ARE_RE0
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE1`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re1(&self) -> bool {
                *self == SETCLR1R::SET_AND_CLEAR_ARE_RE1
            }
        }
        #[doc = "Possible values of the field `SETCLR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR2R {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR2R::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR2R::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR2R::SET_AND_CLEAR_ARE_RE1 => 2,
                    SETCLR2R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SETCLR2R {
                match value {
                    0 => SETCLR2R::SET_AND_CLEAR_DO_NOT,
                    1 => SETCLR2R::SET_AND_CLEAR_ARE_RE0,
                    2 => SETCLR2R::SET_AND_CLEAR_ARE_RE1,
                    i => SETCLR2R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_DO_NOT`"]
            #[inline(always)]
            pub fn is_set_and_clear_do_not(&self) -> bool {
                *self == SETCLR2R::SET_AND_CLEAR_DO_NOT
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE0`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re0(&self) -> bool {
                *self == SETCLR2R::SET_AND_CLEAR_ARE_RE0
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE1`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re1(&self) -> bool {
                *self == SETCLR2R::SET_AND_CLEAR_ARE_RE1
            }
        }
        #[doc = "Possible values of the field `SETCLR3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SETCLR3R {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SETCLR3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SETCLR3R::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR3R::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR3R::SET_AND_CLEAR_ARE_RE1 => 2,
                    SETCLR3R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SETCLR3R {
                match value {
                    0 => SETCLR3R::SET_AND_CLEAR_DO_NOT,
                    1 => SETCLR3R::SET_AND_CLEAR_ARE_RE0,
                    2 => SETCLR3R::SET_AND_CLEAR_ARE_RE1,
                    i => SETCLR3R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_DO_NOT`"]
            #[inline(always)]
            pub fn is_set_and_clear_do_not(&self) -> bool {
                *self == SETCLR3R::SET_AND_CLEAR_DO_NOT
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE0`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re0(&self) -> bool {
                *self == SETCLR3R::SET_AND_CLEAR_ARE_RE0
            }
            #[doc = "Checks if the value of the field is `SET_AND_CLEAR_ARE_RE1`"]
            #[inline(always)]
            pub fn is_set_and_clear_are_re1(&self) -> bool {
                *self == SETCLR3R::SET_AND_CLEAR_ARE_RE1
            }
        }
        #[doc = "Values that can be written to the field `SETCLR0`"]
        pub enum SETCLR0W {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
        }
        impl SETCLR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR0W::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR0W::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR0W::SET_AND_CLEAR_ARE_RE1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SETCLR0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline(always)]
            pub fn set_and_clear_do_not(self) -> &'a mut W {
                self.variant(SETCLR0W::SET_AND_CLEAR_DO_NOT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline(always)]
            pub fn set_and_clear_are_re0(self) -> &'a mut W {
                self.variant(SETCLR0W::SET_AND_CLEAR_ARE_RE0)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline(always)]
            pub fn set_and_clear_are_re1(self) -> &'a mut W {
                self.variant(SETCLR0W::SET_AND_CLEAR_ARE_RE1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR1`"]
        pub enum SETCLR1W {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
        }
        impl SETCLR1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR1W::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR1W::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR1W::SET_AND_CLEAR_ARE_RE1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SETCLR1W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline(always)]
            pub fn set_and_clear_do_not(self) -> &'a mut W {
                self.variant(SETCLR1W::SET_AND_CLEAR_DO_NOT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline(always)]
            pub fn set_and_clear_are_re0(self) -> &'a mut W {
                self.variant(SETCLR1W::SET_AND_CLEAR_ARE_RE0)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline(always)]
            pub fn set_and_clear_are_re1(self) -> &'a mut W {
                self.variant(SETCLR1W::SET_AND_CLEAR_ARE_RE1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR2`"]
        pub enum SETCLR2W {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
        }
        impl SETCLR2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR2W::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR2W::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR2W::SET_AND_CLEAR_ARE_RE1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SETCLR2W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline(always)]
            pub fn set_and_clear_do_not(self) -> &'a mut W {
                self.variant(SETCLR2W::SET_AND_CLEAR_DO_NOT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline(always)]
            pub fn set_and_clear_are_re0(self) -> &'a mut W {
                self.variant(SETCLR2W::SET_AND_CLEAR_ARE_RE0)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline(always)]
            pub fn set_and_clear_are_re1(self) -> &'a mut W {
                self.variant(SETCLR2W::SET_AND_CLEAR_ARE_RE1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SETCLR3`"]
        pub enum SETCLR3W {
            #[doc = "Set and clear do not depend on any counter."]
            SET_AND_CLEAR_DO_NOT,
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            SET_AND_CLEAR_ARE_RE0,
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            SET_AND_CLEAR_ARE_RE1,
        }
        impl SETCLR3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SETCLR3W::SET_AND_CLEAR_DO_NOT => 0,
                    SETCLR3W::SET_AND_CLEAR_ARE_RE0 => 1,
                    SETCLR3W::SET_AND_CLEAR_ARE_RE1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETCLR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETCLR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SETCLR3W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Set and clear do not depend on any counter."]
            #[inline(always)]
            pub fn set_and_clear_do_not(self) -> &'a mut W {
                self.variant(SETCLR3W::SET_AND_CLEAR_DO_NOT)
            }
            #[doc = "Set and clear are reversed when counter L or the unified counter is counting down."]
            #[inline(always)]
            pub fn set_and_clear_are_re0(self) -> &'a mut W {
                self.variant(SETCLR3W::SET_AND_CLEAR_ARE_RE0)
            }
            #[doc = "Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1."]
            #[inline(always)]
            pub fn set_and_clear_are_re1(self) -> &'a mut W {
                self.variant(SETCLR3W::SET_AND_CLEAR_ARE_RE1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr0(&self) -> SETCLR0R {
                SETCLR0R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr1(&self) -> SETCLR1R {
                SETCLR1R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr2(&self) -> SETCLR2R {
                SETCLR2R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr3(&self) -> SETCLR3R {
                SETCLR3R::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr0(&mut self) -> _SETCLR0W {
                _SETCLR0W { w: self }
            }
            #[doc = "Bits 2:3 - Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr1(&mut self) -> _SETCLR1W {
                _SETCLR1W { w: self }
            }
            #[doc = "Bits 4:5 - Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr2(&mut self) -> _SETCLR2W {
                _SETCLR2W { w: self }
            }
            #[doc = "Bits 6:7 - Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value."]
            #[inline(always)]
            pub fn setclr3(&mut self) -> _SETCLR3W {
                _SETCLR3W { w: self }
            }
        }
    }
    #[doc = "SCT conflict resolution register"]
    pub struct RES {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT conflict resolution register"]
    pub mod res {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RES {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `O0RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O0RESR {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O0RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    O0RESR::NO_CHANGE_ => 0,
                    O0RESR::SET_OUTPUT_OR_CLEAR => 1,
                    O0RESR::CLEAR_OUTPUT_OR_SET => 2,
                    O0RESR::TOGGLE_OUTPUT_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> O0RESR {
                match value {
                    0 => O0RESR::NO_CHANGE_,
                    1 => O0RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O0RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O0RESR::TOGGLE_OUTPUT_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE_`"]
            #[inline(always)]
            pub fn is_no_change_(&self) -> bool {
                *self == O0RESR::NO_CHANGE_
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline(always)]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O0RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline(always)]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O0RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT_`"]
            #[inline(always)]
            pub fn is_toggle_output_(&self) -> bool {
                *self == O0RESR::TOGGLE_OUTPUT_
            }
        }
        #[doc = "Possible values of the field `O1RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O1RESR {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O1RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    O1RESR::NO_CHANGE_ => 0,
                    O1RESR::SET_OUTPUT_OR_CLEAR => 1,
                    O1RESR::CLEAR_OUTPUT_OR_SET => 2,
                    O1RESR::TOGGLE_OUTPUT_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> O1RESR {
                match value {
                    0 => O1RESR::NO_CHANGE_,
                    1 => O1RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O1RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O1RESR::TOGGLE_OUTPUT_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE_`"]
            #[inline(always)]
            pub fn is_no_change_(&self) -> bool {
                *self == O1RESR::NO_CHANGE_
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline(always)]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O1RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline(always)]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O1RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT_`"]
            #[inline(always)]
            pub fn is_toggle_output_(&self) -> bool {
                *self == O1RESR::TOGGLE_OUTPUT_
            }
        }
        #[doc = "Possible values of the field `O2RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O2RESR {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            CLEAR_OUTPUT_N_OR_S,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O2RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    O2RESR::NO_CHANGE_ => 0,
                    O2RESR::SET_OUTPUT_OR_CLEAR => 1,
                    O2RESR::CLEAR_OUTPUT_N_OR_S => 2,
                    O2RESR::TOGGLE_OUTPUT_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> O2RESR {
                match value {
                    0 => O2RESR::NO_CHANGE_,
                    1 => O2RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O2RESR::CLEAR_OUTPUT_N_OR_S,
                    3 => O2RESR::TOGGLE_OUTPUT_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE_`"]
            #[inline(always)]
            pub fn is_no_change_(&self) -> bool {
                *self == O2RESR::NO_CHANGE_
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline(always)]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O2RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_N_OR_S`"]
            #[inline(always)]
            pub fn is_clear_output_n_or_s(&self) -> bool {
                *self == O2RESR::CLEAR_OUTPUT_N_OR_S
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT_`"]
            #[inline(always)]
            pub fn is_toggle_output_(&self) -> bool {
                *self == O2RESR::TOGGLE_OUTPUT_
            }
        }
        #[doc = "Possible values of the field `O3RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum O3RESR {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O3RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    O3RESR::NO_CHANGE_ => 0,
                    O3RESR::SET_OUTPUT_OR_CLEAR => 1,
                    O3RESR::CLEAR_OUTPUT_OR_SET => 2,
                    O3RESR::TOGGLE_OUTPUT_ => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> O3RESR {
                match value {
                    0 => O3RESR::NO_CHANGE_,
                    1 => O3RESR::SET_OUTPUT_OR_CLEAR,
                    2 => O3RESR::CLEAR_OUTPUT_OR_SET,
                    3 => O3RESR::TOGGLE_OUTPUT_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE_`"]
            #[inline(always)]
            pub fn is_no_change_(&self) -> bool {
                *self == O3RESR::NO_CHANGE_
            }
            #[doc = "Checks if the value of the field is `SET_OUTPUT_OR_CLEAR`"]
            #[inline(always)]
            pub fn is_set_output_or_clear(&self) -> bool {
                *self == O3RESR::SET_OUTPUT_OR_CLEAR
            }
            #[doc = "Checks if the value of the field is `CLEAR_OUTPUT_OR_SET`"]
            #[inline(always)]
            pub fn is_clear_output_or_set(&self) -> bool {
                *self == O3RESR::CLEAR_OUTPUT_OR_SET
            }
            #[doc = "Checks if the value of the field is `TOGGLE_OUTPUT_`"]
            #[inline(always)]
            pub fn is_toggle_output_(&self) -> bool {
                *self == O3RESR::TOGGLE_OUTPUT_
            }
        }
        #[doc = "Values that can be written to the field `O0RES`"]
        pub enum O0RESW {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O0RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O0RESW::NO_CHANGE_ => 0,
                    O0RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O0RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O0RESW::TOGGLE_OUTPUT_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O0RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O0RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: O0RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline(always)]
            pub fn no_change_(self) -> &'a mut W {
                self.variant(O0RESW::NO_CHANGE_)
            }
            #[doc = "Set output (or clear based on the SETCLR0 field)."]
            #[inline(always)]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O0RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR0 field)."]
            #[inline(always)]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O0RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline(always)]
            pub fn toggle_output_(self) -> &'a mut W {
                self.variant(O0RESW::TOGGLE_OUTPUT_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O1RES`"]
        pub enum O1RESW {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O1RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O1RESW::NO_CHANGE_ => 0,
                    O1RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O1RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O1RESW::TOGGLE_OUTPUT_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O1RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O1RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: O1RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline(always)]
            pub fn no_change_(self) -> &'a mut W {
                self.variant(O1RESW::NO_CHANGE_)
            }
            #[doc = "Set output (or clear based on the SETCLR1 field)."]
            #[inline(always)]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O1RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR1 field)."]
            #[inline(always)]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O1RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline(always)]
            pub fn toggle_output_(self) -> &'a mut W {
                self.variant(O1RESW::TOGGLE_OUTPUT_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O2RES`"]
        pub enum O2RESW {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            CLEAR_OUTPUT_N_OR_S,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O2RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O2RESW::NO_CHANGE_ => 0,
                    O2RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O2RESW::CLEAR_OUTPUT_N_OR_S => 2,
                    O2RESW::TOGGLE_OUTPUT_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O2RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O2RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: O2RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline(always)]
            pub fn no_change_(self) -> &'a mut W {
                self.variant(O2RESW::NO_CHANGE_)
            }
            #[doc = "Set output (or clear based on the SETCLR2 field)."]
            #[inline(always)]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O2RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output n (or set based on the SETCLR2 field)."]
            #[inline(always)]
            pub fn clear_output_n_or_s(self) -> &'a mut W {
                self.variant(O2RESW::CLEAR_OUTPUT_N_OR_S)
            }
            #[doc = "Toggle output."]
            #[inline(always)]
            pub fn toggle_output_(self) -> &'a mut W {
                self.variant(O2RESW::TOGGLE_OUTPUT_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `O3RES`"]
        pub enum O3RESW {
            #[doc = "No change."]
            NO_CHANGE_,
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            SET_OUTPUT_OR_CLEAR,
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            CLEAR_OUTPUT_OR_SET,
            #[doc = "Toggle output."]
            TOGGLE_OUTPUT_,
        }
        impl O3RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    O3RESW::NO_CHANGE_ => 0,
                    O3RESW::SET_OUTPUT_OR_CLEAR => 1,
                    O3RESW::CLEAR_OUTPUT_OR_SET => 2,
                    O3RESW::TOGGLE_OUTPUT_ => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _O3RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _O3RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: O3RESW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No change."]
            #[inline(always)]
            pub fn no_change_(self) -> &'a mut W {
                self.variant(O3RESW::NO_CHANGE_)
            }
            #[doc = "Set output (or clear based on the SETCLR3 field)."]
            #[inline(always)]
            pub fn set_output_or_clear(self) -> &'a mut W {
                self.variant(O3RESW::SET_OUTPUT_OR_CLEAR)
            }
            #[doc = "Clear output (or set based on the SETCLR3 field)."]
            #[inline(always)]
            pub fn clear_output_or_set(self) -> &'a mut W {
                self.variant(O3RESW::CLEAR_OUTPUT_OR_SET)
            }
            #[doc = "Toggle output."]
            #[inline(always)]
            pub fn toggle_output_(self) -> &'a mut W {
                self.variant(O3RESW::TOGGLE_OUTPUT_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Effect of simultaneous set and clear on output 0."]
            #[inline(always)]
            pub fn o0res(&self) -> O0RESR {
                O0RESR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Effect of simultaneous set and clear on output 1."]
            #[inline(always)]
            pub fn o1res(&self) -> O1RESR {
                O1RESR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Effect of simultaneous set and clear on output 2."]
            #[inline(always)]
            pub fn o2res(&self) -> O2RESR {
                O2RESR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - Effect of simultaneous set and clear on output 3."]
            #[inline(always)]
            pub fn o3res(&self) -> O3RESR {
                O3RESR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Effect of simultaneous set and clear on output 0."]
            #[inline(always)]
            pub fn o0res(&mut self) -> _O0RESW {
                _O0RESW { w: self }
            }
            #[doc = "Bits 2:3 - Effect of simultaneous set and clear on output 1."]
            #[inline(always)]
            pub fn o1res(&mut self) -> _O1RESW {
                _O1RESW { w: self }
            }
            #[doc = "Bits 4:5 - Effect of simultaneous set and clear on output 2."]
            #[inline(always)]
            pub fn o2res(&mut self) -> _O2RESW {
                _O2RESW { w: self }
            }
            #[doc = "Bits 6:7 - Effect of simultaneous set and clear on output 3."]
            #[inline(always)]
            pub fn o3res(&mut self) -> _O3RESW {
                _O3RESW { w: self }
            }
        }
    }
    #[doc = "SCT event enable register"]
    pub struct EVEN {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event enable register"]
    pub mod even {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IENR {
            bits: u8,
        }
        impl IENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _IENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn ien(&self) -> IENR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn ien(&mut self) -> _IENW {
                _IENW { w: self }
            }
        }
    }
    #[doc = "SCT event flag register"]
    pub struct EVFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event flag register"]
    pub mod evflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FLAGR {
            bits: u8,
        }
        impl FLAGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLAGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn flag(&self) -> FLAGR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FLAGR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn flag(&mut self) -> _FLAGW {
                _FLAGW { w: self }
            }
        }
    }
    #[doc = "SCT conflict enable register"]
    pub struct CONEN {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT conflict enable register"]
    pub mod conen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NCENR {
            bits: u8,
        }
        impl NCENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn ncen(&self) -> NCENR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NCENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn ncen(&mut self) -> _NCENW {
                _NCENW { w: self }
            }
        }
    }
    #[doc = "SCT conflict flag register"]
    pub struct CONFLAG {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT conflict flag register"]
    pub mod conflag {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFLAG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NCFLAGR {
            bits: u8,
        }
        impl NCFLAGR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSERRLR {
            bits: bool,
        }
        impl BUSERRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BUSERRHR {
            bits: bool,
        }
        impl BUSERRHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCFLAGW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSERRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSERRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BUSERRHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BUSERRHW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn ncflag(&self) -> NCFLAGR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NCFLAGR { bits }
            }
            #[doc = "Bit 30 - The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful."]
            #[inline(always)]
            pub fn buserrl(&self) -> BUSERRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSERRLR { bits }
            }
            #[doc = "Bit 31 - The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted."]
            #[inline(always)]
            pub fn buserrh(&self) -> BUSERRHR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BUSERRHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Bit n is one if a no-change conflict event occurred on output n since reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3)."]
            #[inline(always)]
            pub fn ncflag(&mut self) -> _NCFLAGW {
                _NCFLAGW { w: self }
            }
            #[doc = "Bit 30 - The most recent bus error from this SCT involved writing CTR L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the L/U counter was not halted. A word write to certain L and H registers can be half successful and half unsuccessful."]
            #[inline(always)]
            pub fn buserrl(&mut self) -> _BUSERRLW {
                _BUSERRLW { w: self }
            }
            #[doc = "Bit 31 - The most recent bus error from this SCT involved writing CTR H, STATE H, MATCH H, or the Output register when the H counter was not halted."]
            #[inline(always)]
            pub fn buserrh(&mut self) -> _BUSERRHW {
                _BUSERRHW { w: self }
            }
        }
    }
    #[doc = "SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
    pub struct MATCH {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0"]
    pub mod match_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MATCH {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHN_LR {
            bits: u16,
        }
        impl MATCHN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHN_HR {
            bits: u16,
        }
        impl MATCHN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline(always)]
            pub fn matchn_l(&self) -> MATCHN_LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MATCHN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit value to be compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline(always)]
            pub fn matchn_h(&self) -> MATCHN_HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MATCHN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline(always)]
            pub fn matchn_l(&mut self) -> _MATCHN_LW {
                _MATCHN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit value to be compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter."]
            #[inline(always)]
            pub fn matchn_h(&mut self) -> _MATCHN_HW {
                _MATCHN_HW { w: self }
            }
        }
    }
    #[doc = "SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1"]
    pub struct CAP {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1"]
    pub mod cap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPN_LR {
            bits: u16,
        }
        impl CAPN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPN_HR {
            bits: u16,
        }
        impl CAPN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured."]
            #[inline(always)]
            pub fn capn_l(&self) -> CAPN_LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CAPN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured."]
            #[inline(always)]
            pub fn capn_h(&self) -> CAPN_HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CAPN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured."]
            #[inline(always)]
            pub fn capn_l(&mut self) -> _CAPN_LW {
                _CAPN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured."]
            #[inline(always)]
            pub fn capn_h(&mut self) -> _CAPN_HW {
                _CAPN_HW { w: self }
            }
        }
    }
    #[doc = "SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
    pub struct MATCHREL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0"]
    pub mod matchrel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MATCHREL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RELOADN_LR {
            bits: u16,
        }
        impl RELOADN_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct RELOADN_HR {
            bits: u16,
        }
        impl RELOADN_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADN_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADN_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RELOADN_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RELOADN_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 65535;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline(always)]
            pub fn reloadn_l(&self) -> RELOADN_LR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RELOADN_LR { bits }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline(always)]
            pub fn reloadn_h(&self) -> RELOADN_HR {
                let bits = {
                    const MASK: u16 = 65535;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RELOADN_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline(always)]
            pub fn reloadn_l(&mut self) -> _RELOADN_LW {
                _RELOADN_LW { w: self }
            }
            #[doc = "Bits 16:31 - When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register."]
            #[inline(always)]
            pub fn reloadn_h(&mut self) -> _RELOADN_HW {
                _RELOADN_HW { w: self }
            }
        }
    }
    #[doc = "SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1"]
    pub struct CAPCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1"]
    pub mod capctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CAPCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPCONM_LR {
            bits: u8,
        }
        impl CAPCONM_LR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPCONM_HR {
            bits: u8,
        }
        impl CAPCONM_HR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPCONM_LW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPCONM_LW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAPCONM_HW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAPCONM_HW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn capconm_l(&self) -> CAPCONM_LR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CAPCONM_LR { bits }
            }
            #[doc = "Bits 16:20 - If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20)."]
            #[inline(always)]
            pub fn capconm_h(&self) -> CAPCONM_HR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CAPCONM_HR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5)."]
            #[inline(always)]
            pub fn capconm_l(&mut self) -> _CAPCONM_LW {
                _CAPCONM_LW { w: self }
            }
            #[doc = "Bits 16:20 - If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20)."]
            #[inline(always)]
            pub fn capconm_h(&mut self) -> _CAPCONM_HW {
                _CAPCONM_HW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 0"]
    pub struct EV0_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 0"]
    pub mod ev0_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV0_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 0"]
    pub struct EV0_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 0"]
    pub mod ev0_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV0_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 1"]
    pub struct EV1_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 1"]
    pub mod ev1_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV1_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 1"]
    pub struct EV1_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 1"]
    pub mod ev1_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV1_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 2"]
    pub struct EV2_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 2"]
    pub mod ev2_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV2_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 2"]
    pub struct EV2_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 2"]
    pub mod ev2_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV2_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 3"]
    pub struct EV3_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 3"]
    pub mod ev3_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV3_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 3"]
    pub struct EV3_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 3"]
    pub mod ev3_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV3_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 4"]
    pub struct EV4_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 4"]
    pub mod ev4_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV4_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 4"]
    pub struct EV4_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 4"]
    pub mod ev4_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV4_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT event state register 5"]
    pub struct EV5_STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event state register 5"]
    pub mod ev5_state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV5_STATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEMSKMR {
            bits: u8,
        }
        impl STATEMSKMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEMSKMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEMSKMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&self) -> STATEMSKMR {
                let bits = {
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEMSKMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1)."]
            #[inline(always)]
            pub fn statemskm(&mut self) -> _STATEMSKMW {
                _STATEMSKMW { w: self }
            }
        }
    }
    #[doc = "SCT event control register 5"]
    pub struct EV5_CTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT event control register 5"]
    pub mod ev5_ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EV5_CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHSELR {
            bits: u8,
        }
        impl MATCHSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `HEVENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HEVENTR {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    HEVENTR::SELECTS_THE_L_STATE_ => false,
                    HEVENTR::SELECTS_THE_H_STATE_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> HEVENTR {
                match value {
                    false => HEVENTR::SELECTS_THE_L_STATE_,
                    true => HEVENTR::SELECTS_THE_H_STATE_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_L_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_l_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_L_STATE_
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_H_STATE_`"]
            #[inline(always)]
            pub fn is_selects_the_h_state_(&self) -> bool {
                *self == HEVENTR::SELECTS_THE_H_STATE_
            }
        }
        #[doc = "Possible values of the field `OUTSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTSELR {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTSELR::SELECTS_THE_INPUTS_E => false,
                    OUTSELR::SELECTS_THE_OUTPUTS_ => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> OUTSELR {
                match value {
                    false => OUTSELR::SELECTS_THE_INPUTS_E,
                    true => OUTSELR::SELECTS_THE_OUTPUTS_,
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_INPUTS_E`"]
            #[inline(always)]
            pub fn is_selects_the_inputs_e(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_INPUTS_E
            }
            #[doc = "Checks if the value of the field is `SELECTS_THE_OUTPUTS_`"]
            #[inline(always)]
            pub fn is_selects_the_outputs_(&self) -> bool {
                *self == OUTSELR::SELECTS_THE_OUTPUTS_
            }
        }
        #[doc = r" Value of the field"]
        pub struct IOSELR {
            bits: u8,
        }
        impl IOSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `IOCOND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONDR {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    IOCONDR::LOW => 0,
                    IOCONDR::RISE => 1,
                    IOCONDR::FALL => 2,
                    IOCONDR::HIGH => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> IOCONDR {
                match value {
                    0 => IOCONDR::LOW,
                    1 => IOCONDR::RISE,
                    2 => IOCONDR::FALL,
                    3 => IOCONDR::HIGH,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                *self == IOCONDR::LOW
            }
            #[doc = "Checks if the value of the field is `RISE`"]
            #[inline(always)]
            pub fn is_rise(&self) -> bool {
                *self == IOCONDR::RISE
            }
            #[doc = "Checks if the value of the field is `FALL`"]
            #[inline(always)]
            pub fn is_fall(&self) -> bool {
                *self == IOCONDR::FALL
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                *self == IOCONDR::HIGH
            }
        }
        #[doc = "Possible values of the field `COMBMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMBMODER {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    COMBMODER::OR_THE_EVENT_OCCURS => 0,
                    COMBMODER::MATCH_USES_THE_SPEC => 1,
                    COMBMODER::IO_USES_THE_SPECIFI => 2,
                    COMBMODER::AND_THE_EVENT_OCCUR => 3,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> COMBMODER {
                match value {
                    0 => COMBMODER::OR_THE_EVENT_OCCURS,
                    1 => COMBMODER::MATCH_USES_THE_SPEC,
                    2 => COMBMODER::IO_USES_THE_SPECIFI,
                    3 => COMBMODER::AND_THE_EVENT_OCCUR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `OR_THE_EVENT_OCCURS`"]
            #[inline(always)]
            pub fn is_or_the_event_occurs(&self) -> bool {
                *self == COMBMODER::OR_THE_EVENT_OCCURS
            }
            #[doc = "Checks if the value of the field is `MATCH_USES_THE_SPEC`"]
            #[inline(always)]
            pub fn is_match_uses_the_spec(&self) -> bool {
                *self == COMBMODER::MATCH_USES_THE_SPEC
            }
            #[doc = "Checks if the value of the field is `IO_USES_THE_SPECIFI`"]
            #[inline(always)]
            pub fn is_io_uses_the_specifi(&self) -> bool {
                *self == COMBMODER::IO_USES_THE_SPECIFI
            }
            #[doc = "Checks if the value of the field is `AND_THE_EVENT_OCCUR`"]
            #[inline(always)]
            pub fn is_and_the_event_occur(&self) -> bool {
                *self == COMBMODER::AND_THE_EVENT_OCCUR
            }
        }
        #[doc = "Possible values of the field `STATELD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATELDR {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    STATELDR::STATEV_VALUE_IS_ADDE => false,
                    STATELDR::STATEV_VALUE_IS_LOAD => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> STATELDR {
                match value {
                    false => STATELDR::STATEV_VALUE_IS_ADDE,
                    true => STATELDR::STATEV_VALUE_IS_LOAD,
                }
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_ADDE`"]
            #[inline(always)]
            pub fn is_statev_value_is_adde(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_ADDE
            }
            #[doc = "Checks if the value of the field is `STATEV_VALUE_IS_LOAD`"]
            #[inline(always)]
            pub fn is_statev_value_is_load(&self) -> bool {
                *self == STATELDR::STATEV_VALUE_IS_LOAD
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATEVR {
            bits: u8,
        }
        impl STATEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHMEMR {
            bits: bool,
        }
        impl MATCHMEMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `DIRECTION`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRECTIONR {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DIRECTIONR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    DIRECTIONR::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONR::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONR::COUNTING_DOWN_THIS_ => 2,
                    DIRECTIONR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> DIRECTIONR {
                match value {
                    0 => DIRECTIONR::DIRECTION_INDEPENDEN,
                    1 => DIRECTIONR::COUNTING_UP_THIS_EV,
                    2 => DIRECTIONR::COUNTING_DOWN_THIS_,
                    i => DIRECTIONR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DIRECTION_INDEPENDEN`"]
            #[inline(always)]
            pub fn is_direction_independen(&self) -> bool {
                *self == DIRECTIONR::DIRECTION_INDEPENDEN
            }
            #[doc = "Checks if the value of the field is `COUNTING_UP_THIS_EV`"]
            #[inline(always)]
            pub fn is_counting_up_this_ev(&self) -> bool {
                *self == DIRECTIONR::COUNTING_UP_THIS_EV
            }
            #[doc = "Checks if the value of the field is `COUNTING_DOWN_THIS_`"]
            #[inline(always)]
            pub fn is_counting_down_this_(&self) -> bool {
                *self == DIRECTIONR::COUNTING_DOWN_THIS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HEVENT`"]
        pub enum HEVENTW {
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            SELECTS_THE_L_STATE_,
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            SELECTS_THE_H_STATE_,
        }
        impl HEVENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    HEVENTW::SELECTS_THE_L_STATE_ => false,
                    HEVENTW::SELECTS_THE_H_STATE_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HEVENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HEVENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: HEVENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the L state and the L match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_l_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_L_STATE_)
            }
            #[doc = "Selects the H state and the H match register selected by MATCHSEL."]
            #[inline(always)]
            pub fn selects_the_h_state_(self) -> &'a mut W {
                self.variant(HEVENTW::SELECTS_THE_H_STATE_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTSEL`"]
        pub enum OUTSELW {
            #[doc = "Selects the inputs elected by IOSEL."]
            SELECTS_THE_INPUTS_E,
            #[doc = "Selects the outputs selected by IOSEL."]
            SELECTS_THE_OUTPUTS_,
        }
        impl OUTSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTSELW::SELECTS_THE_INPUTS_E => false,
                    OUTSELW::SELECTS_THE_OUTPUTS_ => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: OUTSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Selects the inputs elected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_inputs_e(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_INPUTS_E)
            }
            #[doc = "Selects the outputs selected by IOSEL."]
            #[inline(always)]
            pub fn selects_the_outputs_(self) -> &'a mut W {
                self.variant(OUTSELW::SELECTS_THE_OUTPUTS_)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 15;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCOND`"]
        pub enum IOCONDW {
            #[doc = "LOW"]
            LOW,
            #[doc = "Rise"]
            RISE,
            #[doc = "Fall"]
            FALL,
            #[doc = "HIGH"]
            HIGH,
        }
        impl IOCONDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    IOCONDW::LOW => 0,
                    IOCONDW::RISE => 1,
                    IOCONDW::FALL => 2,
                    IOCONDW::HIGH => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: IOCONDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "LOW"]
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(IOCONDW::LOW)
            }
            #[doc = "Rise"]
            #[inline(always)]
            pub fn rise(self) -> &'a mut W {
                self.variant(IOCONDW::RISE)
            }
            #[doc = "Fall"]
            #[inline(always)]
            pub fn fall(self) -> &'a mut W {
                self.variant(IOCONDW::FALL)
            }
            #[doc = "HIGH"]
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(IOCONDW::HIGH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMBMODE`"]
        pub enum COMBMODEW {
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            OR_THE_EVENT_OCCURS,
            #[doc = "MATCH. Uses the specified match only."]
            MATCH_USES_THE_SPEC,
            #[doc = "IO. Uses the specified I/O condition only."]
            IO_USES_THE_SPECIFI,
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            AND_THE_EVENT_OCCUR,
        }
        impl COMBMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    COMBMODEW::OR_THE_EVENT_OCCURS => 0,
                    COMBMODEW::MATCH_USES_THE_SPEC => 1,
                    COMBMODEW::IO_USES_THE_SPECIFI => 2,
                    COMBMODEW::AND_THE_EVENT_OCCUR => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMBMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMBMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: COMBMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "OR. The event occurs when either the specified match or I/O condition occurs."]
            #[inline(always)]
            pub fn or_the_event_occurs(self) -> &'a mut W {
                self.variant(COMBMODEW::OR_THE_EVENT_OCCURS)
            }
            #[doc = "MATCH. Uses the specified match only."]
            #[inline(always)]
            pub fn match_uses_the_spec(self) -> &'a mut W {
                self.variant(COMBMODEW::MATCH_USES_THE_SPEC)
            }
            #[doc = "IO. Uses the specified I/O condition only."]
            #[inline(always)]
            pub fn io_uses_the_specifi(self) -> &'a mut W {
                self.variant(COMBMODEW::IO_USES_THE_SPECIFI)
            }
            #[doc = "AND. The event occurs when the specified match and I/O condition occur simultaneously."]
            #[inline(always)]
            pub fn and_the_event_occur(self) -> &'a mut W {
                self.variant(COMBMODEW::AND_THE_EVENT_OCCUR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STATELD`"]
        pub enum STATELDW {
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            STATEV_VALUE_IS_ADDE,
            #[doc = "STATEV value is loaded into STATE."]
            STATEV_VALUE_IS_LOAD,
        }
        impl STATELDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    STATELDW::STATEV_VALUE_IS_ADDE => false,
                    STATELDW::STATEV_VALUE_IS_LOAD => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATELDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATELDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: STATELDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "STATEV value is added into STATE (the carry-out is ignored)."]
            #[inline(always)]
            pub fn statev_value_is_adde(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_ADDE)
            }
            #[doc = "STATEV value is loaded into STATE."]
            #[inline(always)]
            pub fn statev_value_is_load(self) -> &'a mut W {
                self.variant(STATELDW::STATEV_VALUE_IS_LOAD)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATEVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 31;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHMEMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHMEMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIRECTION`"]
        pub enum DIRECTIONW {
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            DIRECTION_INDEPENDEN,
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            COUNTING_UP_THIS_EV,
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            COUNTING_DOWN_THIS_,
        }
        impl DIRECTIONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DIRECTIONW::DIRECTION_INDEPENDEN => 0,
                    DIRECTIONW::COUNTING_UP_THIS_EV => 1,
                    DIRECTIONW::COUNTING_DOWN_THIS_ => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRECTIONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRECTIONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: DIRECTIONW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Direction independent. This event is triggered regardless of the count direction."]
            #[inline(always)]
            pub fn direction_independen(self) -> &'a mut W {
                self.variant(DIRECTIONW::DIRECTION_INDEPENDEN)
            }
            #[doc = "Counting up. This event is triggered only during up-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_up_this_ev(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_UP_THIS_EV)
            }
            #[doc = "Counting down. This event is triggered only during down-counting when BIDIR = 1."]
            #[inline(always)]
            pub fn counting_down_this_(self) -> &'a mut W {
                self.variant(DIRECTIONW::COUNTING_DOWN_THIS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 3;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&self) -> MATCHSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MATCHSELR { bits }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&self) -> HEVENTR {
                HEVENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&self) -> OUTSELR {
                OUTSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&self) -> IOSELR {
                let bits = {
                    const MASK: u8 = 15;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                IOSELR { bits }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&self) -> IOCONDR {
                IOCONDR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&self) -> COMBMODER {
                COMBMODER::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&self) -> STATELDR {
                STATELDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&self) -> STATEVR {
                let bits = {
                    const MASK: u8 = 31;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATEVR { bits }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&self) -> MATCHMEMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MATCHMEMR { bits }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&self) -> DIRECTIONR {
                DIRECTIONR::_from({
                    const MASK: u8 = 3;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Selects the Match register associated with this event (if any). A match can occur only when the counter selected by the HEVENT bit is running."]
            #[inline(always)]
            pub fn matchsel(&mut self) -> _MATCHSELW {
                _MATCHSELW { w: self }
            }
            #[doc = "Bit 4 - Select L/H counter. Do not set this bit if UNIFY = 1."]
            #[inline(always)]
            pub fn hevent(&mut self) -> _HEVENTW {
                _HEVENTW { w: self }
            }
            #[doc = "Bit 5 - Input/output select"]
            #[inline(always)]
            pub fn outsel(&mut self) -> _OUTSELW {
                _OUTSELW { w: self }
            }
            #[doc = "Bits 6:9 - Selects the input or output signal associated with this event (if any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of every event."]
            #[inline(always)]
            pub fn iosel(&mut self) -> _IOSELW {
                _IOSELW { w: self }
            }
            #[doc = "Bits 10:11 - Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT clock period ."]
            #[inline(always)]
            pub fn iocond(&mut self) -> _IOCONDW {
                _IOCONDW { w: self }
            }
            #[doc = "Bits 12:13 - Selects how the specified match and I/O condition are used and combined."]
            #[inline(always)]
            pub fn combmode(&mut self) -> _COMBMODEW {
                _COMBMODEW { w: self }
            }
            #[doc = "Bit 14 - This bit controls how the STATEV value modifies the state selected by HEVENT when this event is the highest-numbered event occurring for that state."]
            #[inline(always)]
            pub fn stateld(&mut self) -> _STATELDW {
                _STATELDW { w: self }
            }
            #[doc = "Bits 15:19 - This value is loaded into or added to the state selected by HEVENT, depending on STATELD, when this event is the highest-numbered event occurring for that state. If STATELD and STATEV are both zero, there is no change to the STATE value."]
            #[inline(always)]
            pub fn statev(&mut self) -> _STATEVW {
                _STATEVW { w: self }
            }
            #[doc = "Bit 20 - If this bit is one and the COMBMODE field specifies a match component to the triggering of this event, then a match is considered to be active whenever the counter value is GREATER THAN OR EQUAL TO the value specified in the match register when counting up, LESS THEN OR EQUAL TO the match value when counting down. If this bit is zero, a match is only be active during the cycle when the counter is equal to the match value."]
            #[inline(always)]
            pub fn matchmem(&mut self) -> _MATCHMEMW {
                _MATCHMEMW { w: self }
            }
            #[doc = "Bits 21:22 - Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved."]
            #[inline(always)]
            pub fn direction(&mut self) -> _DIRECTIONW {
                _DIRECTIONW { w: self }
            }
        }
    }
    #[doc = "SCT output 0 set register"]
    pub struct OUT0_SET {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 0 set register"]
    pub mod out0_set {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT0_SET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETR {
            bits: u8,
        }
        impl SETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&self) -> SETR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&mut self) -> _SETW {
                _SETW { w: self }
            }
        }
    }
    #[doc = "SCT output 0 clear register"]
    pub struct OUT0_CLR {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 0 clear register"]
    pub mod out0_clr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT0_CLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: u8,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
    #[doc = "SCT output 1 set register"]
    pub struct OUT1_SET {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 1 set register"]
    pub mod out1_set {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT1_SET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETR {
            bits: u8,
        }
        impl SETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&self) -> SETR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&mut self) -> _SETW {
                _SETW { w: self }
            }
        }
    }
    #[doc = "SCT output 1 clear register"]
    pub struct OUT1_CLR {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 1 clear register"]
    pub mod out1_clr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT1_CLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: u8,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
    #[doc = "SCT output 2 set register"]
    pub struct OUT2_SET {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 2 set register"]
    pub mod out2_set {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT2_SET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETR {
            bits: u8,
        }
        impl SETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&self) -> SETR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&mut self) -> _SETW {
                _SETW { w: self }
            }
        }
    }
    #[doc = "SCT output 2 clear register"]
    pub struct OUT2_CLR {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 2 clear register"]
    pub mod out2_clr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT2_CLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: u8,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
    #[doc = "SCT output 3 set register"]
    pub struct OUT3_SET {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 3 set register"]
    pub mod out3_set {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT3_SET {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETR {
            bits: u8,
        }
        impl SETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&self) -> SETR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn set(&mut self) -> _SETW {
                _SETW { w: self }
            }
        }
    }
    #[doc = "SCT output 3 clear register"]
    pub struct OUT3_CLR {
        register: VolatileCell<u32>,
    }
    #[doc = "SCT output 3 clear register"]
    pub mod out3_clr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT3_CLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLRR {
            bits: u8,
        }
        impl CLRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 63;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&self) -> CLRR {
                let bits = {
                    const MASK: u8 = 63;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:5 - A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5."]
            #[inline(always)]
            pub fn clr(&mut self) -> _CLRW {
                _CLRW { w: self }
            }
        }
    }
}
#[doc = "State Configurable Timer (SCT)"]
pub struct SCT {
    register_block: sct::RegisterBlock,
}
impl Deref for SCT {
    type Target = sct::RegisterBlock;
    fn deref(&self) -> &sct::RegisterBlock {
        &self.register_block
    }
}
#[doc = "General Purpose I/O port (GPIO)"]
pub const GPIO_PORT: Peripheral<GPIO_PORT> = unsafe { Peripheral::new(2684354560) };
#[doc = "General Purpose I/O port (GPIO)"]
pub mod gpio_port {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b0: B,
        #[doc = "0x01 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b1: B,
        #[doc = "0x02 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b2: B,
        #[doc = "0x03 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b3: B,
        #[doc = "0x04 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b4: B,
        #[doc = "0x05 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b5: B,
        #[doc = "0x06 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b6: B,
        #[doc = "0x07 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b7: B,
        #[doc = "0x08 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b8: B,
        #[doc = "0x09 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b9: B,
        #[doc = "0x0a - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b10: B,
        #[doc = "0x0b - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b11: B,
        #[doc = "0x0c - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b12: B,
        #[doc = "0x0d - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b13: B,
        #[doc = "0x0e - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b14: B,
        #[doc = "0x0f - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b15: B,
        #[doc = "0x10 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b16: B,
        #[doc = "0x11 - Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
        pub b17: B,
        _reserved0: [u8; 4078usize],
        #[doc = "0x1000 - Word pin registers port 0"]
        pub w0: W,
        #[doc = "0x1004 - Word pin registers port 0"]
        pub w1: W,
        #[doc = "0x1008 - Word pin registers port 0"]
        pub w2: W,
        #[doc = "0x100c - Word pin registers port 0"]
        pub w3: W,
        #[doc = "0x1010 - Word pin registers port 0"]
        pub w4: W,
        #[doc = "0x1014 - Word pin registers port 0"]
        pub w5: W,
        #[doc = "0x1018 - Word pin registers port 0"]
        pub w6: W,
        #[doc = "0x101c - Word pin registers port 0"]
        pub w7: W,
        #[doc = "0x1020 - Word pin registers port 0"]
        pub w8: W,
        #[doc = "0x1024 - Word pin registers port 0"]
        pub w9: W,
        #[doc = "0x1028 - Word pin registers port 0"]
        pub w10: W,
        #[doc = "0x102c - Word pin registers port 0"]
        pub w11: W,
        #[doc = "0x1030 - Word pin registers port 0"]
        pub w12: W,
        #[doc = "0x1034 - Word pin registers port 0"]
        pub w13: W,
        #[doc = "0x1038 - Word pin registers port 0"]
        pub w14: W,
        #[doc = "0x103c - Word pin registers port 0"]
        pub w15: W,
        #[doc = "0x1040 - Word pin registers port 0"]
        pub w16: W,
        #[doc = "0x1044 - Word pin registers port 0"]
        pub w17: W,
        _reserved1: [u8; 4024usize],
        #[doc = "0x2000 - Direction registers port 0"]
        pub dir0: DIR0,
        _reserved2: [u8; 124usize],
        #[doc = "0x2080 - Mask register port 0"]
        pub mask0: MASK0,
        _reserved3: [u8; 124usize],
        #[doc = "0x2100 - Port pin register port 0"]
        pub pin0: PIN0,
        _reserved4: [u8; 124usize],
        #[doc = "0x2180 - Masked port register port 0"]
        pub mpin0: MPIN0,
        _reserved5: [u8; 124usize],
        #[doc = "0x2200 - Write: Set register for port 0 Read: output bits for port 0"]
        pub set0: SET0,
        _reserved6: [u8; 124usize],
        #[doc = "0x2280 - Clear port 0"]
        pub clr0: CLR0,
        _reserved7: [u8; 124usize],
        #[doc = "0x2300 - Toggle port 0"]
        pub not0: NOT0,
    }
    #[doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
    pub struct B {
        register: VolatileCell<u8>,
    }
    #[doc = "Byte pin registers port 0; pins PIO0_0 to PIO0_17"]
    pub mod b {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u8,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u8,
        }
        impl super::B {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PBYTER {
            bits: bool,
        }
        impl PBYTER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _PBYTEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PBYTEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u8) << OFFSET);
                self.w.bits |= ((value & MASK) as u8) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
            #[doc = "Bit 0 - Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit."]
            #[inline(always)]
            pub fn pbyte(&self) -> PBYTER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u8) != 0
                };
                PBYTER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u8) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit."]
            #[inline(always)]
            pub fn pbyte(&mut self) -> _PBYTEW {
                _PBYTEW { w: self }
            }
        }
    }
    #[doc = "Word pin registers port 0"]
    pub struct W {
        register: VolatileCell<u32>,
    }
    #[doc = "Word pin registers port 0"]
    pub mod w {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::W {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PWORDR {
            bits: u32,
        }
        impl PWORDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWORDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWORDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 4294967295;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit."]
            #[inline(always)]
            pub fn pword(&self) -> PWORDR {
                let bits = {
                    const MASK: u32 = 4294967295;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PWORDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Read 0: pin is LOW. Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH. Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit."]
            #[inline(always)]
            pub fn pword(&mut self) -> _PWORDW {
                _PWORDW { w: self }
            }
        }
    }
    #[doc = "Direction registers port 0"]
    pub struct DIR0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Direction registers port 0"]
    pub mod dir0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIRP0R {
            bits: u32,
        }
        impl DIRP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Selects pin direction for pin P0_n (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = input. 1 = output."]
            #[inline(always)]
            pub fn dirp0(&self) -> DIRP0R {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DIRP0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Selects pin direction for pin P0_n (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = input. 1 = output."]
            #[inline(always)]
            pub fn dirp0(&mut self) -> _DIRP0W {
                _DIRP0W { w: self }
            }
        }
    }
    #[doc = "Mask register port 0"]
    pub struct MASK0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Mask register port 0"]
    pub mod mask0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MASK0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASKP0R {
            bits: u32,
        }
        impl MASKP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASKP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASKP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Controls which bits corresponding to P0_n are active in the P0MPORT register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected."]
            #[inline(always)]
            pub fn maskp0(&self) -> MASKP0R {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MASKP0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Controls which bits corresponding to P0_n are active in the P0MPORT register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected."]
            #[inline(always)]
            pub fn maskp0(&mut self) -> _MASKP0W {
                _MASKP0W { w: self }
            }
        }
    }
    #[doc = "Port pin register port 0"]
    pub struct PIN0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Port pin register port 0"]
    pub mod pin0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PORT0R {
            bits: u32,
        }
        impl PORT0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORT0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORT0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Reads pin states or loads output bits (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit."]
            #[inline(always)]
            pub fn port0(&self) -> PORT0R {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PORT0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Reads pin states or loads output bits (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit."]
            #[inline(always)]
            pub fn port0(&mut self) -> _PORT0W {
                _PORT0W { w: self }
            }
        }
    }
    #[doc = "Masked port register port 0"]
    pub struct MPIN0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Masked port register port 0"]
    pub mod mpin0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MPIN0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MPORTP0R {
            bits: u32,
        }
        impl MPORTP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MPORTP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MPORTP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Masked port register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0."]
            #[inline(always)]
            pub fn mportp0(&self) -> MPORTP0R {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MPORTP0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Masked port register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0."]
            #[inline(always)]
            pub fn mportp0(&mut self) -> _MPORTP0W {
                _MPORTP0W { w: self }
            }
        }
    }
    #[doc = "Write: Set register for port 0 Read: output bits for port 0"]
    pub struct SET0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Write: Set register for port 0 Read: output bits for port 0"]
    pub mod set0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SET0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SETP0R {
            bits: u32,
        }
        impl SETP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:17 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit."]
            #[inline(always)]
            pub fn setp0(&self) -> SETP0R {
                let bits = {
                    const MASK: u32 = 262143;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SETP0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit."]
            #[inline(always)]
            pub fn setp0(&mut self) -> _SETP0W {
                _SETP0W { w: self }
            }
        }
    }
    #[doc = "Clear port 0"]
    pub struct CLR0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Clear port 0"]
    pub mod clr0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLR0 {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLRP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLRP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Clear output bits: 0 = No operation. 1 = Clear output bit."]
            #[inline(always)]
            pub fn clrp0(&mut self) -> _CLRP0W {
                _CLRP0W { w: self }
            }
        }
    }
    #[doc = "Toggle port 0"]
    pub struct NOT0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Toggle port 0"]
    pub mod not0 {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NOT0 {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _NOTP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _NOTP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 262143;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:17 - Toggle output bits: 0 = no operation. 1 = Toggle output bit."]
            #[inline(always)]
            pub fn notp0(&mut self) -> _NOTP0W {
                _NOTP0W { w: self }
            }
        }
    }
}
#[doc = "General Purpose I/O port (GPIO)"]
pub struct GPIO_PORT {
    register_block: gpio_port::RegisterBlock,
}
impl Deref for GPIO_PORT {
    type Target = gpio_port::RegisterBlock;
    fn deref(&self) -> &gpio_port::RegisterBlock {
        &self.register_block
    }
}
#[doc = "Pin interrupt and pattern match engine"]
pub const PIN_INT: Peripheral<PIN_INT> = unsafe { Peripheral::new(2684370944) };
#[doc = "Pin interrupt and pattern match engine"]
pub mod pin_int {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Pin Interrupt Mode register"]
        pub isel: ISEL,
        #[doc = "0x04 - Pin interrupt level or rising edge interrupt enable register"]
        pub ienr: IENR,
        #[doc = "0x08 - Pin interrupt level (rising edge) interrupt set register"]
        pub sienr: SIENR,
        #[doc = "0x0c - Pin interrupt level or rising edge interrupt clear register"]
        pub cienr: CIENR,
        #[doc = "0x10 - Pin interrupt active level or falling edge interrupt enable register"]
        pub ienf: IENF,
        #[doc = "0x14 - Pin interrupt active level or falling edge interrupt set register"]
        pub sienf: SIENF,
        #[doc = "0x18 - Pin interrupt active level (falling edge) interrupt clear register"]
        pub cienf: CIENF,
        #[doc = "0x1c - Pin interrupt rising edge register"]
        pub rise: RISE,
        #[doc = "0x20 - Pin interrupt falling edge register"]
        pub fall: FALL,
        #[doc = "0x24 - Pin interrupt status register"]
        pub ist: IST,
        #[doc = "0x28 - GPIO pattern match interrupt control register"]
        pub pmctrl: PMCTRL,
        #[doc = "0x2c - GPIO pattern match interrupt bit-slice source register"]
        pub pmsrc: PMSRC,
        #[doc = "0x30 - GPIO pattern match interrupt bit slice configuration register"]
        pub pmcfg: PMCFG,
    }
    #[doc = "Pin Interrupt Mode register"]
    pub struct ISEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin Interrupt Mode register"]
    pub mod isel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ISEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMODER {
            bits: u8,
        }
        impl PMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMODEW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive"]
            #[inline(always)]
            pub fn pmode(&self) -> PMODER {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PMODER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive"]
            #[inline(always)]
            pub fn pmode(&mut self) -> _PMODEW {
                _PMODEW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level or rising edge interrupt enable register"]
    pub struct IENR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level or rising edge interrupt enable register"]
    pub mod ienr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IENR {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENRLR {
            bits: u8,
        }
        impl ENRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt."]
            #[inline(always)]
            pub fn enrl(&self) -> ENRLR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ENRLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt."]
            #[inline(always)]
            pub fn enrl(&mut self) -> _ENRLW {
                _ENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level (rising edge) interrupt set register"]
    pub struct SIENR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level (rising edge) interrupt set register"]
    pub mod sienr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIENR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt."]
            #[inline(always)]
            pub fn setenrl(&mut self) -> _SETENRLW {
                _SETENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt level or rising edge interrupt clear register"]
    pub struct CIENR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt level or rising edge interrupt clear register"]
    pub mod cienr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CIENR {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENRLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt."]
            #[inline(always)]
            pub fn cenrl(&mut self) -> _CENRLW {
                _CENRLW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level or falling edge interrupt enable register"]
    pub struct IENF {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level or falling edge interrupt enable register"]
    pub mod ienf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IENF {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ENAFR {
            bits: u8,
        }
        impl ENAFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH."]
            #[inline(always)]
            pub fn enaf(&self) -> ENAFR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ENAFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH."]
            #[inline(always)]
            pub fn enaf(&mut self) -> _ENAFW {
                _ENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level or falling edge interrupt set register"]
    pub struct SIENF {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level or falling edge interrupt set register"]
    pub mod sienf {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIENF {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SETENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SETENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt."]
            #[inline(always)]
            pub fn setenaf(&mut self) -> _SETENAFW {
                _SETENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt active level (falling edge) interrupt clear register"]
    pub struct CIENF {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt active level (falling edge) interrupt clear register"]
    pub mod cienf {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CIENF {
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENAFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENAFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled."]
            #[inline(always)]
            pub fn cenaf(&mut self) -> _CENAFW {
                _CENAFW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt rising edge register"]
    pub struct RISE {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt rising edge register"]
    pub mod rise {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RISE {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RDETR {
            bits: u8,
        }
        impl RDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _RDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RDETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin."]
            #[inline(always)]
            pub fn rdet(&self) -> RDETR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RDETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin."]
            #[inline(always)]
            pub fn rdet(&mut self) -> _RDETW {
                _RDETW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt falling edge register"]
    pub struct FALL {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt falling edge register"]
    pub mod fall {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FALL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FDETR {
            bits: u8,
        }
        impl FDETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FDETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FDETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin."]
            #[inline(always)]
            pub fn fdet(&self) -> FDETR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FDETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin."]
            #[inline(always)]
            pub fn fdet(&mut self) -> _FDETW {
                _FDETW { w: self }
            }
        }
    }
    #[doc = "Pin interrupt status register"]
    pub struct IST {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin interrupt status register"]
    pub mod ist {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IST {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSTATR {
            bits: u8,
        }
        impl PSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSTATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSTATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register)."]
            #[inline(always)]
            pub fn pstat(&self) -> PSTATR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PSTATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin. Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register)."]
            #[inline(always)]
            pub fn pstat(&mut self) -> _PSTATW {
                _PSTATW { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt control register"]
    pub struct PMCTRL {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt control register"]
    pub mod pmctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL_PMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEL_PMATCHR {
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            PIN_INTERRUPT_INTER,
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            PATTERN_MATCH_INTER,
        }
        impl SEL_PMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    SEL_PMATCHR::PIN_INTERRUPT_INTER => false,
                    SEL_PMATCHR::PATTERN_MATCH_INTER => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> SEL_PMATCHR {
                match value {
                    false => SEL_PMATCHR::PIN_INTERRUPT_INTER,
                    true => SEL_PMATCHR::PATTERN_MATCH_INTER,
                }
            }
            #[doc = "Checks if the value of the field is `PIN_INTERRUPT_INTER`"]
            #[inline(always)]
            pub fn is_pin_interrupt_inter(&self) -> bool {
                *self == SEL_PMATCHR::PIN_INTERRUPT_INTER
            }
            #[doc = "Checks if the value of the field is `PATTERN_MATCH_INTER`"]
            #[inline(always)]
            pub fn is_pattern_match_inter(&self) -> bool {
                *self == SEL_PMATCHR::PATTERN_MATCH_INTER
            }
        }
        #[doc = "Possible values of the field `ENA_RXEV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA_RXEVR {
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            DISABLED_RXEV_OUTPU,
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            ENABLED_RXEV_OUTPUT,
        }
        impl ENA_RXEVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline(always)]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline(always)]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA_RXEVR::DISABLED_RXEV_OUTPU => false,
                    ENA_RXEVR::ENABLED_RXEV_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: bool) -> ENA_RXEVR {
                match value {
                    false => ENA_RXEVR::DISABLED_RXEV_OUTPU,
                    true => ENA_RXEVR::ENABLED_RXEV_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED_RXEV_OUTPU`"]
            #[inline(always)]
            pub fn is_disabled_rxev_outpu(&self) -> bool {
                *self == ENA_RXEVR::DISABLED_RXEV_OUTPU
            }
            #[doc = "Checks if the value of the field is `ENABLED_RXEV_OUTPUT`"]
            #[inline(always)]
            pub fn is_enabled_rxev_output(&self) -> bool {
                *self == ENA_RXEVR::ENABLED_RXEV_OUTPUT
            }
        }
        #[doc = r" Value of the field"]
        pub struct PMATR {
            bits: u8,
        }
        impl PMATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `SEL_PMATCH`"]
        pub enum SEL_PMATCHW {
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            PIN_INTERRUPT_INTER,
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            PATTERN_MATCH_INTER,
        }
        impl SEL_PMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    SEL_PMATCHW::PIN_INTERRUPT_INTER => false,
                    SEL_PMATCHW::PATTERN_MATCH_INTER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SEL_PMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SEL_PMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SEL_PMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin interrupt. Interrupts are driven in response to the standard pin interrupt function"]
            #[inline(always)]
            pub fn pin_interrupt_inter(self) -> &'a mut W {
                self.variant(SEL_PMATCHW::PIN_INTERRUPT_INTER)
            }
            #[doc = "Pattern match. Interrupts are driven in response to pattern matches."]
            #[inline(always)]
            pub fn pattern_match_inter(self) -> &'a mut W {
                self.variant(SEL_PMATCHW::PATTERN_MATCH_INTER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA_RXEV`"]
        pub enum ENA_RXEVW {
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            DISABLED_RXEV_OUTPU,
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            ENABLED_RXEV_OUTPUT,
        }
        impl ENA_RXEVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA_RXEVW::DISABLED_RXEV_OUTPU => false,
                    ENA_RXEVW::ENABLED_RXEV_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA_RXEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA_RXEVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: ENA_RXEVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled. RxEv output to the cpu is disabled."]
            #[inline(always)]
            pub fn disabled_rxev_outpu(self) -> &'a mut W {
                self.variant(ENA_RXEVW::DISABLED_RXEV_OUTPU)
            }
            #[doc = "Enabled. RxEv output to the cpu is enabled."]
            #[inline(always)]
            pub fn enabled_rxev_output(self) -> &'a mut W {
                self.variant(ENA_RXEVW::ENABLED_RXEV_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PMATW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PMATW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 255;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function."]
            #[inline(always)]
            pub fn sel_pmatch(&self) -> SEL_PMATCHR {
                SEL_PMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enables the RxEv output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true."]
            #[inline(always)]
            pub fn ena_rxev(&self) -> ENA_RXEVR {
                ENA_RXEVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 24:31 - This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs."]
            #[inline(always)]
            pub fn pmat(&self) -> PMATR {
                let bits = {
                    const MASK: u8 = 255;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PMATR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function."]
            #[inline(always)]
            pub fn sel_pmatch(&mut self) -> _SEL_PMATCHW {
                _SEL_PMATCHW { w: self }
            }
            #[doc = "Bit 1 - Enables the RxEv output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true."]
            #[inline(always)]
            pub fn ena_rxev(&mut self) -> _ENA_RXEVW {
                _ENA_RXEVW { w: self }
            }
            #[doc = "Bits 24:31 - This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs."]
            #[inline(always)]
            pub fn pmat(&mut self) -> _PMATW {
                _PMATW { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt bit-slice source register"]
    pub struct PMSRC {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt bit-slice source register"]
    pub mod pmsrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMSRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SRC0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC0R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC0R::INPUT_0_SELECTS_PIN => 0,
                    SRC0R::INPUT_1_SELECTS_PIN => 1,
                    SRC0R::INPUT_2_SELECTS_PIN => 2,
                    SRC0R::INPUT_3_SELECTS_PIN => 3,
                    SRC0R::INPUT_4_SELECTS_PIN => 4,
                    SRC0R::INPUT_5_SELECTS_PIN => 5,
                    SRC0R::INPUT_6_SELECTS_PIN => 6,
                    SRC0R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC0R {
                match value {
                    0 => SRC0R::INPUT_0_SELECTS_PIN,
                    1 => SRC0R::INPUT_1_SELECTS_PIN,
                    2 => SRC0R::INPUT_2_SELECTS_PIN,
                    3 => SRC0R::INPUT_3_SELECTS_PIN,
                    4 => SRC0R::INPUT_4_SELECTS_PIN,
                    5 => SRC0R::INPUT_5_SELECTS_PIN,
                    6 => SRC0R::INPUT_6_SELECTS_PIN,
                    7 => SRC0R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC0R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC1R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC1R::INPUT_0_SELECTS_PIN => 0,
                    SRC1R::INPUT_1_SELECTS_PIN => 1,
                    SRC1R::INPUT_2_SELECTS_PIN => 2,
                    SRC1R::INPUT_3_SELECTS_PIN => 3,
                    SRC1R::INPUT_4_SELECTS_PIN => 4,
                    SRC1R::INPUT_5_SELECTS_PIN => 5,
                    SRC1R::INPUT_6_SELECTS_PIN => 6,
                    SRC1R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC1R {
                match value {
                    0 => SRC1R::INPUT_0_SELECTS_PIN,
                    1 => SRC1R::INPUT_1_SELECTS_PIN,
                    2 => SRC1R::INPUT_2_SELECTS_PIN,
                    3 => SRC1R::INPUT_3_SELECTS_PIN,
                    4 => SRC1R::INPUT_4_SELECTS_PIN,
                    5 => SRC1R::INPUT_5_SELECTS_PIN,
                    6 => SRC1R::INPUT_6_SELECTS_PIN,
                    7 => SRC1R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC1R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC2R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC2R::INPUT_0_SELECTS_PIN => 0,
                    SRC2R::INPUT_1_SELECTS_PIN => 1,
                    SRC2R::INPUT_2_SELECTS_PIN => 2,
                    SRC2R::INPUT_3_SELECTS_PIN => 3,
                    SRC2R::INPUT_4_SELECTS_PIN => 4,
                    SRC2R::INPUT_5_SELECTS_PIN => 5,
                    SRC2R::INPUT_6_SELECTS_PIN => 6,
                    SRC2R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC2R {
                match value {
                    0 => SRC2R::INPUT_0_SELECTS_PIN,
                    1 => SRC2R::INPUT_1_SELECTS_PIN,
                    2 => SRC2R::INPUT_2_SELECTS_PIN,
                    3 => SRC2R::INPUT_3_SELECTS_PIN,
                    4 => SRC2R::INPUT_4_SELECTS_PIN,
                    5 => SRC2R::INPUT_5_SELECTS_PIN,
                    6 => SRC2R::INPUT_6_SELECTS_PIN,
                    7 => SRC2R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC2R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC3R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC3R::INPUT_0_SELECTS_PIN => 0,
                    SRC3R::INPUT_1_SELECTS_PIN => 1,
                    SRC3R::INPUT_2_SELECTS_PIN => 2,
                    SRC3R::INPUT_3_SELECTS_PIN => 3,
                    SRC3R::INPUT_4_SELECTS_PIN => 4,
                    SRC3R::INPUT_5_SELECTS_PIN => 5,
                    SRC3R::INPUT_6_SELECTS_PIN => 6,
                    SRC3R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC3R {
                match value {
                    0 => SRC3R::INPUT_0_SELECTS_PIN,
                    1 => SRC3R::INPUT_1_SELECTS_PIN,
                    2 => SRC3R::INPUT_2_SELECTS_PIN,
                    3 => SRC3R::INPUT_3_SELECTS_PIN,
                    4 => SRC3R::INPUT_4_SELECTS_PIN,
                    5 => SRC3R::INPUT_5_SELECTS_PIN,
                    6 => SRC3R::INPUT_6_SELECTS_PIN,
                    7 => SRC3R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC3R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC4R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC4R::INPUT_0_SELECTS_PIN => 0,
                    SRC4R::INPUT_1_SELECTS_PIN => 1,
                    SRC4R::INPUT_2_SELECTS_PIN => 2,
                    SRC4R::INPUT_3_SELECTS_PIN => 3,
                    SRC4R::INPUT_4_SELECTS_PIN => 4,
                    SRC4R::INPUT_5_SELECTS_PIN => 5,
                    SRC4R::INPUT_6_SELECTS_PIN => 6,
                    SRC4R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC4R {
                match value {
                    0 => SRC4R::INPUT_0_SELECTS_PIN,
                    1 => SRC4R::INPUT_1_SELECTS_PIN,
                    2 => SRC4R::INPUT_2_SELECTS_PIN,
                    3 => SRC4R::INPUT_3_SELECTS_PIN,
                    4 => SRC4R::INPUT_4_SELECTS_PIN,
                    5 => SRC4R::INPUT_5_SELECTS_PIN,
                    6 => SRC4R::INPUT_6_SELECTS_PIN,
                    7 => SRC4R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC4R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC5R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC5R::INPUT_0_SELECTS_PIN => 0,
                    SRC5R::INPUT_1_SELECTS_PIN => 1,
                    SRC5R::INPUT_2_SELECTS_PIN => 2,
                    SRC5R::INPUT_3_SELECTS_PIN => 3,
                    SRC5R::INPUT_4_SELECTS_PIN => 4,
                    SRC5R::INPUT_5_SELECTS_PIN => 5,
                    SRC5R::INPUT_6_SELECTS_PIN => 6,
                    SRC5R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC5R {
                match value {
                    0 => SRC5R::INPUT_0_SELECTS_PIN,
                    1 => SRC5R::INPUT_1_SELECTS_PIN,
                    2 => SRC5R::INPUT_2_SELECTS_PIN,
                    3 => SRC5R::INPUT_3_SELECTS_PIN,
                    4 => SRC5R::INPUT_4_SELECTS_PIN,
                    5 => SRC5R::INPUT_5_SELECTS_PIN,
                    6 => SRC5R::INPUT_6_SELECTS_PIN,
                    7 => SRC5R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC5R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC6R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC6R::INPUT_0_SELECTS_PIN => 0,
                    SRC6R::INPUT_1_SELECTS_PIN => 1,
                    SRC6R::INPUT_2_SELECTS_PIN => 2,
                    SRC6R::INPUT_3_SELECTS_PIN => 3,
                    SRC6R::INPUT_4_SELECTS_PIN => 4,
                    SRC6R::INPUT_5_SELECTS_PIN => 5,
                    SRC6R::INPUT_6_SELECTS_PIN => 6,
                    SRC6R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC6R {
                match value {
                    0 => SRC6R::INPUT_0_SELECTS_PIN,
                    1 => SRC6R::INPUT_1_SELECTS_PIN,
                    2 => SRC6R::INPUT_2_SELECTS_PIN,
                    3 => SRC6R::INPUT_3_SELECTS_PIN,
                    4 => SRC6R::INPUT_4_SELECTS_PIN,
                    5 => SRC6R::INPUT_5_SELECTS_PIN,
                    6 => SRC6R::INPUT_6_SELECTS_PIN,
                    7 => SRC6R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC6R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Possible values of the field `SRC7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRC7R {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRC7R::INPUT_0_SELECTS_PIN => 0,
                    SRC7R::INPUT_1_SELECTS_PIN => 1,
                    SRC7R::INPUT_2_SELECTS_PIN => 2,
                    SRC7R::INPUT_3_SELECTS_PIN => 3,
                    SRC7R::INPUT_4_SELECTS_PIN => 4,
                    SRC7R::INPUT_5_SELECTS_PIN => 5,
                    SRC7R::INPUT_6_SELECTS_PIN => 6,
                    SRC7R::INPUT_7_SELECTS_PIN => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> SRC7R {
                match value {
                    0 => SRC7R::INPUT_0_SELECTS_PIN,
                    1 => SRC7R::INPUT_1_SELECTS_PIN,
                    2 => SRC7R::INPUT_2_SELECTS_PIN,
                    3 => SRC7R::INPUT_3_SELECTS_PIN,
                    4 => SRC7R::INPUT_4_SELECTS_PIN,
                    5 => SRC7R::INPUT_5_SELECTS_PIN,
                    6 => SRC7R::INPUT_6_SELECTS_PIN,
                    7 => SRC7R::INPUT_7_SELECTS_PIN,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INPUT_0_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_0_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_0_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_1_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_1_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_1_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_2_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_2_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_2_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_3_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_3_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_3_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_4_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_4_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_4_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_5_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_5_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_5_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_6_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_6_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_6_SELECTS_PIN
            }
            #[doc = "Checks if the value of the field is `INPUT_7_SELECTS_PIN`"]
            #[inline(always)]
            pub fn is_input_7_selects_pin(&self) -> bool {
                *self == SRC7R::INPUT_7_SELECTS_PIN
            }
        }
        #[doc = "Values that can be written to the field `SRC0`"]
        pub enum SRC0W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC0W::INPUT_0_SELECTS_PIN => 0,
                    SRC0W::INPUT_1_SELECTS_PIN => 1,
                    SRC0W::INPUT_2_SELECTS_PIN => 2,
                    SRC0W::INPUT_3_SELECTS_PIN => 3,
                    SRC0W::INPUT_4_SELECTS_PIN => 4,
                    SRC0W::INPUT_5_SELECTS_PIN => 5,
                    SRC0W::INPUT_6_SELECTS_PIN => 6,
                    SRC0W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 0."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC0W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC1`"]
        pub enum SRC1W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC1W::INPUT_0_SELECTS_PIN => 0,
                    SRC1W::INPUT_1_SELECTS_PIN => 1,
                    SRC1W::INPUT_2_SELECTS_PIN => 2,
                    SRC1W::INPUT_3_SELECTS_PIN => 3,
                    SRC1W::INPUT_4_SELECTS_PIN => 4,
                    SRC1W::INPUT_5_SELECTS_PIN => 5,
                    SRC1W::INPUT_6_SELECTS_PIN => 6,
                    SRC1W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 1."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC1W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC2`"]
        pub enum SRC2W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC2W::INPUT_0_SELECTS_PIN => 0,
                    SRC2W::INPUT_1_SELECTS_PIN => 1,
                    SRC2W::INPUT_2_SELECTS_PIN => 2,
                    SRC2W::INPUT_3_SELECTS_PIN => 3,
                    SRC2W::INPUT_4_SELECTS_PIN => 4,
                    SRC2W::INPUT_5_SELECTS_PIN => 5,
                    SRC2W::INPUT_6_SELECTS_PIN => 6,
                    SRC2W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 2."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC2W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC3`"]
        pub enum SRC3W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC3W::INPUT_0_SELECTS_PIN => 0,
                    SRC3W::INPUT_1_SELECTS_PIN => 1,
                    SRC3W::INPUT_2_SELECTS_PIN => 2,
                    SRC3W::INPUT_3_SELECTS_PIN => 3,
                    SRC3W::INPUT_4_SELECTS_PIN => 4,
                    SRC3W::INPUT_5_SELECTS_PIN => 5,
                    SRC3W::INPUT_6_SELECTS_PIN => 6,
                    SRC3W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 3."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC3W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC4`"]
        pub enum SRC4W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC4W::INPUT_0_SELECTS_PIN => 0,
                    SRC4W::INPUT_1_SELECTS_PIN => 1,
                    SRC4W::INPUT_2_SELECTS_PIN => 2,
                    SRC4W::INPUT_3_SELECTS_PIN => 3,
                    SRC4W::INPUT_4_SELECTS_PIN => 4,
                    SRC4W::INPUT_5_SELECTS_PIN => 5,
                    SRC4W::INPUT_6_SELECTS_PIN => 6,
                    SRC4W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 4."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC4W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC5`"]
        pub enum SRC5W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC5W::INPUT_0_SELECTS_PIN => 0,
                    SRC5W::INPUT_1_SELECTS_PIN => 1,
                    SRC5W::INPUT_2_SELECTS_PIN => 2,
                    SRC5W::INPUT_3_SELECTS_PIN => 3,
                    SRC5W::INPUT_4_SELECTS_PIN => 4,
                    SRC5W::INPUT_5_SELECTS_PIN => 5,
                    SRC5W::INPUT_6_SELECTS_PIN => 6,
                    SRC5W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 5."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC5W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC6`"]
        pub enum SRC6W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC6W::INPUT_0_SELECTS_PIN => 0,
                    SRC6W::INPUT_1_SELECTS_PIN => 1,
                    SRC6W::INPUT_2_SELECTS_PIN => 2,
                    SRC6W::INPUT_3_SELECTS_PIN => 3,
                    SRC6W::INPUT_4_SELECTS_PIN => 4,
                    SRC6W::INPUT_5_SELECTS_PIN => 5,
                    SRC6W::INPUT_6_SELECTS_PIN => 6,
                    SRC6W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 6."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC6W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SRC7`"]
        pub enum SRC7W {
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            INPUT_0_SELECTS_PIN,
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            INPUT_1_SELECTS_PIN,
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            INPUT_2_SELECTS_PIN,
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            INPUT_3_SELECTS_PIN,
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            INPUT_4_SELECTS_PIN,
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            INPUT_5_SELECTS_PIN,
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            INPUT_6_SELECTS_PIN,
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            INPUT_7_SELECTS_PIN,
        }
        impl SRC7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRC7W::INPUT_0_SELECTS_PIN => 0,
                    SRC7W::INPUT_1_SELECTS_PIN => 1,
                    SRC7W::INPUT_2_SELECTS_PIN => 2,
                    SRC7W::INPUT_3_SELECTS_PIN => 3,
                    SRC7W::INPUT_4_SELECTS_PIN => 4,
                    SRC7W::INPUT_5_SELECTS_PIN => 5,
                    SRC7W::INPUT_6_SELECTS_PIN => 6,
                    SRC7W::INPUT_7_SELECTS_PIN => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRC7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRC7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: SRC7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Input 0. Selects pin interrupt input 0 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_0_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_0_SELECTS_PIN)
            }
            #[doc = "Input 1. Selects pin interrupt input 1 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_1_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_1_SELECTS_PIN)
            }
            #[doc = "Input 2. Selects pin interrupt input 2 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_2_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_2_SELECTS_PIN)
            }
            #[doc = "Input 3. Selects pin interrupt input 3 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_3_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_3_SELECTS_PIN)
            }
            #[doc = "Input 4. Selects pin interrupt input 4 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_4_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_4_SELECTS_PIN)
            }
            #[doc = "Input 5. Selects pin interrupt input 5 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_5_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_5_SELECTS_PIN)
            }
            #[doc = "Input 6. Selects pin interrupt input 6 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_6_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_6_SELECTS_PIN)
            }
            #[doc = "Input 7. Selects pin interrupt input 7 as the source to bit slice 7."]
            #[inline(always)]
            pub fn input_7_selects_pin(self) -> &'a mut W {
                self.variant(SRC7W::INPUT_7_SELECTS_PIN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 8:10 - Selects the input source for bit slice 0"]
            #[inline(always)]
            pub fn src0(&self) -> SRC0R {
                SRC0R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Selects the input source for bit slice 1"]
            #[inline(always)]
            pub fn src1(&self) -> SRC1R {
                SRC1R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:16 - Selects the input source for bit slice 2"]
            #[inline(always)]
            pub fn src2(&self) -> SRC2R {
                SRC2R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 17:19 - Selects the input source for bit slice 3"]
            #[inline(always)]
            pub fn src3(&self) -> SRC3R {
                SRC3R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 20:22 - Selects the input source for bit slice 4"]
            #[inline(always)]
            pub fn src4(&self) -> SRC4R {
                SRC4R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:25 - Selects the input source for bit slice 5"]
            #[inline(always)]
            pub fn src5(&self) -> SRC5R {
                SRC5R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:28 - Selects the input source for bit slice 6"]
            #[inline(always)]
            pub fn src6(&self) -> SRC6R {
                SRC6R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 29:31 - Selects the input source for bit slice 7"]
            #[inline(always)]
            pub fn src7(&self) -> SRC7R {
                SRC7R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:10 - Selects the input source for bit slice 0"]
            #[inline(always)]
            pub fn src0(&mut self) -> _SRC0W {
                _SRC0W { w: self }
            }
            #[doc = "Bits 11:13 - Selects the input source for bit slice 1"]
            #[inline(always)]
            pub fn src1(&mut self) -> _SRC1W {
                _SRC1W { w: self }
            }
            #[doc = "Bits 14:16 - Selects the input source for bit slice 2"]
            #[inline(always)]
            pub fn src2(&mut self) -> _SRC2W {
                _SRC2W { w: self }
            }
            #[doc = "Bits 17:19 - Selects the input source for bit slice 3"]
            #[inline(always)]
            pub fn src3(&mut self) -> _SRC3W {
                _SRC3W { w: self }
            }
            #[doc = "Bits 20:22 - Selects the input source for bit slice 4"]
            #[inline(always)]
            pub fn src4(&mut self) -> _SRC4W {
                _SRC4W { w: self }
            }
            #[doc = "Bits 23:25 - Selects the input source for bit slice 5"]
            #[inline(always)]
            pub fn src5(&mut self) -> _SRC5W {
                _SRC5W { w: self }
            }
            #[doc = "Bits 26:28 - Selects the input source for bit slice 6"]
            #[inline(always)]
            pub fn src6(&mut self) -> _SRC6W {
                _SRC6W { w: self }
            }
            #[doc = "Bits 29:31 - Selects the input source for bit slice 7"]
            #[inline(always)]
            pub fn src7(&mut self) -> _SRC7W {
                _SRC7W { w: self }
            }
        }
    }
    #[doc = "GPIO pattern match interrupt bit slice configuration register"]
    pub struct PMCFG {
        register: VolatileCell<u32>,
    }
    #[doc = "GPIO pattern match interrupt bit slice configuration register"]
    pub mod pmcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PMCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline(always)]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline(always)]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline(always)]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline(always)]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PROD_ENDPTSR {
            bits: u8,
        }
        impl PROD_ENDPTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `CFG0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG0R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG0R::CONSTANT_1_THIS_BIT => 0,
                    CFG0R::RISING_EDGE_MATCH_O => 1,
                    CFG0R::FALLING_EDGE_MATCH_ => 2,
                    CFG0R::RISING_OR_FALLING_ED => 3,
                    CFG0R::HIGH_LEVEL_MATCH_F => 4,
                    CFG0R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG0R::CONSTANT_0_THIS_BIT => 6,
                    CFG0R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG0R {
                match value {
                    0 => CFG0R::CONSTANT_1_THIS_BIT,
                    1 => CFG0R::RISING_EDGE_MATCH_O,
                    2 => CFG0R::FALLING_EDGE_MATCH_,
                    3 => CFG0R::RISING_OR_FALLING_ED,
                    4 => CFG0R::HIGH_LEVEL_MATCH_F,
                    5 => CFG0R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG0R::CONSTANT_0_THIS_BIT,
                    7 => CFG0R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG0R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG0R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG0R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG0R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG0R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG0R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG0R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG0R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG1R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG1R::CONSTANT_1_THIS_BIT => 0,
                    CFG1R::RISING_EDGE_MATCH_O => 1,
                    CFG1R::FALLING_EDGE_MATCH_ => 2,
                    CFG1R::RISING_OR_FALLING_ED => 3,
                    CFG1R::HIGH_LEVEL_MATCH_F => 4,
                    CFG1R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG1R::CONSTANT_0_THIS_BIT => 6,
                    CFG1R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG1R {
                match value {
                    0 => CFG1R::CONSTANT_1_THIS_BIT,
                    1 => CFG1R::RISING_EDGE_MATCH_O,
                    2 => CFG1R::FALLING_EDGE_MATCH_,
                    3 => CFG1R::RISING_OR_FALLING_ED,
                    4 => CFG1R::HIGH_LEVEL_MATCH_F,
                    5 => CFG1R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG1R::CONSTANT_0_THIS_BIT,
                    7 => CFG1R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG1R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG1R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG1R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG1R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG1R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG1R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG1R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG1R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG2R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG2R::CONSTANT_1_THIS_BIT => 0,
                    CFG2R::RISING_EDGE_MATCH_O => 1,
                    CFG2R::FALLING_EDGE_MATCH_ => 2,
                    CFG2R::RISING_OR_FALLING_ED => 3,
                    CFG2R::HIGH_LEVEL_MATCH_F => 4,
                    CFG2R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG2R::CONSTANT_0_THIS_BIT => 6,
                    CFG2R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG2R {
                match value {
                    0 => CFG2R::CONSTANT_1_THIS_BIT,
                    1 => CFG2R::RISING_EDGE_MATCH_O,
                    2 => CFG2R::FALLING_EDGE_MATCH_,
                    3 => CFG2R::RISING_OR_FALLING_ED,
                    4 => CFG2R::HIGH_LEVEL_MATCH_F,
                    5 => CFG2R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG2R::CONSTANT_0_THIS_BIT,
                    7 => CFG2R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG2R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG2R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG2R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG2R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG2R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG2R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG2R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG2R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG3R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG3R::CONSTANT_1_THIS_BIT => 0,
                    CFG3R::RISING_EDGE_MATCH_O => 1,
                    CFG3R::FALLING_EDGE_MATCH_ => 2,
                    CFG3R::RISING_OR_FALLING_ED => 3,
                    CFG3R::HIGH_LEVEL_MATCH_F => 4,
                    CFG3R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG3R::CONSTANT_0_THIS_BIT => 6,
                    CFG3R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG3R {
                match value {
                    0 => CFG3R::CONSTANT_1_THIS_BIT,
                    1 => CFG3R::RISING_EDGE_MATCH_O,
                    2 => CFG3R::FALLING_EDGE_MATCH_,
                    3 => CFG3R::RISING_OR_FALLING_ED,
                    4 => CFG3R::HIGH_LEVEL_MATCH_F,
                    5 => CFG3R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG3R::CONSTANT_0_THIS_BIT,
                    7 => CFG3R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG3R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG3R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG3R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG3R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG3R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG3R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG3R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG3R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG4R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG4R::CONSTANT_1_THIS_BIT => 0,
                    CFG4R::RISING_EDGE_MATCH_O => 1,
                    CFG4R::FALLING_EDGE_MATCH_ => 2,
                    CFG4R::RISING_OR_FALLING_ED => 3,
                    CFG4R::HIGH_LEVEL_MATCH_F => 4,
                    CFG4R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG4R::CONSTANT_0_THIS_BIT => 6,
                    CFG4R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG4R {
                match value {
                    0 => CFG4R::CONSTANT_1_THIS_BIT,
                    1 => CFG4R::RISING_EDGE_MATCH_O,
                    2 => CFG4R::FALLING_EDGE_MATCH_,
                    3 => CFG4R::RISING_OR_FALLING_ED,
                    4 => CFG4R::HIGH_LEVEL_MATCH_F,
                    5 => CFG4R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG4R::CONSTANT_0_THIS_BIT,
                    7 => CFG4R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG4R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG4R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG4R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG4R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG4R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG4R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG4R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG4R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG5R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG5R::CONSTANT_1_THIS_BIT => 0,
                    CFG5R::RISING_EDGE_MATCH_O => 1,
                    CFG5R::FALLING_EDGE_MATCH_ => 2,
                    CFG5R::RISING_OR_FALLING_ED => 3,
                    CFG5R::HIGH_LEVEL_MATCH_F => 4,
                    CFG5R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG5R::CONSTANT_0_THIS_BIT => 6,
                    CFG5R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG5R {
                match value {
                    0 => CFG5R::CONSTANT_1_THIS_BIT,
                    1 => CFG5R::RISING_EDGE_MATCH_O,
                    2 => CFG5R::FALLING_EDGE_MATCH_,
                    3 => CFG5R::RISING_OR_FALLING_ED,
                    4 => CFG5R::HIGH_LEVEL_MATCH_F,
                    5 => CFG5R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG5R::CONSTANT_0_THIS_BIT,
                    7 => CFG5R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG5R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG5R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG5R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG5R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG5R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG5R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG5R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG5R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG6R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG6R::CONSTANT_1_THIS_BIT => 0,
                    CFG6R::RISING_EDGE_MATCH_O => 1,
                    CFG6R::FALLING_EDGE_MATCH_ => 2,
                    CFG6R::RISING_OR_FALLING_ED => 3,
                    CFG6R::HIGH_LEVEL_MATCH_F => 4,
                    CFG6R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG6R::CONSTANT_0_THIS_BIT => 6,
                    CFG6R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG6R {
                match value {
                    0 => CFG6R::CONSTANT_1_THIS_BIT,
                    1 => CFG6R::RISING_EDGE_MATCH_O,
                    2 => CFG6R::FALLING_EDGE_MATCH_,
                    3 => CFG6R::RISING_OR_FALLING_ED,
                    4 => CFG6R::HIGH_LEVEL_MATCH_F,
                    5 => CFG6R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG6R::CONSTANT_0_THIS_BIT,
                    7 => CFG6R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG6R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG6R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG6R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG6R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG6R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG6R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG6R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG6R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = "Possible values of the field `CFG7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CFG7R {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u8 {
                match *self {
                    CFG7R::CONSTANT_1_THIS_BIT => 0,
                    CFG7R::RISING_EDGE_MATCH_O => 1,
                    CFG7R::FALLING_EDGE_MATCH_ => 2,
                    CFG7R::RISING_OR_FALLING_ED => 3,
                    CFG7R::HIGH_LEVEL_MATCH_F => 4,
                    CFG7R::LOW_LEVEL_MATCH_OCC => 5,
                    CFG7R::CONSTANT_0_THIS_BIT => 6,
                    CFG7R::EVENT_MATCH_OCCURS_ => 7,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _from(value: u8) -> CFG7R {
                match value {
                    0 => CFG7R::CONSTANT_1_THIS_BIT,
                    1 => CFG7R::RISING_EDGE_MATCH_O,
                    2 => CFG7R::FALLING_EDGE_MATCH_,
                    3 => CFG7R::RISING_OR_FALLING_ED,
                    4 => CFG7R::HIGH_LEVEL_MATCH_F,
                    5 => CFG7R::LOW_LEVEL_MATCH_OCC,
                    6 => CFG7R::CONSTANT_0_THIS_BIT,
                    7 => CFG7R::EVENT_MATCH_OCCURS_,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `CONSTANT_1_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_1_this_bit(&self) -> bool {
                *self == CFG7R::CONSTANT_1_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `RISING_EDGE_MATCH_O`"]
            #[inline(always)]
            pub fn is_rising_edge_match_o(&self) -> bool {
                *self == CFG7R::RISING_EDGE_MATCH_O
            }
            #[doc = "Checks if the value of the field is `FALLING_EDGE_MATCH_`"]
            #[inline(always)]
            pub fn is_falling_edge_match_(&self) -> bool {
                *self == CFG7R::FALLING_EDGE_MATCH_
            }
            #[doc = "Checks if the value of the field is `RISING_OR_FALLING_ED`"]
            #[inline(always)]
            pub fn is_rising_or_falling_ed(&self) -> bool {
                *self == CFG7R::RISING_OR_FALLING_ED
            }
            #[doc = "Checks if the value of the field is `HIGH_LEVEL_MATCH_F`"]
            #[inline(always)]
            pub fn is_high_level_match_f(&self) -> bool {
                *self == CFG7R::HIGH_LEVEL_MATCH_F
            }
            #[doc = "Checks if the value of the field is `LOW_LEVEL_MATCH_OCC`"]
            #[inline(always)]
            pub fn is_low_level_match_occ(&self) -> bool {
                *self == CFG7R::LOW_LEVEL_MATCH_OCC
            }
            #[doc = "Checks if the value of the field is `CONSTANT_0_THIS_BIT`"]
            #[inline(always)]
            pub fn is_constant_0_this_bit(&self) -> bool {
                *self == CFG7R::CONSTANT_0_THIS_BIT
            }
            #[doc = "Checks if the value of the field is `EVENT_MATCH_OCCURS_`"]
            #[inline(always)]
            pub fn is_event_match_occurs_(&self) -> bool {
                *self == CFG7R::EVENT_MATCH_OCCURS_
            }
        }
        #[doc = r" Proxy"]
        pub struct _PROD_ENDPTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PROD_ENDPTSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 127;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG0`"]
        pub enum CFG0W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG0W::CONSTANT_1_THIS_BIT => 0,
                    CFG0W::RISING_EDGE_MATCH_O => 1,
                    CFG0W::FALLING_EDGE_MATCH_ => 2,
                    CFG0W::RISING_OR_FALLING_ED => 3,
                    CFG0W::HIGH_LEVEL_MATCH_F => 4,
                    CFG0W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG0W::CONSTANT_0_THIS_BIT => 6,
                    CFG0W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG0W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG0W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG0W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG0W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG0W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG0W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG0W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG0W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG1`"]
        pub enum CFG1W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG1W::CONSTANT_1_THIS_BIT => 0,
                    CFG1W::RISING_EDGE_MATCH_O => 1,
                    CFG1W::FALLING_EDGE_MATCH_ => 2,
                    CFG1W::RISING_OR_FALLING_ED => 3,
                    CFG1W::HIGH_LEVEL_MATCH_F => 4,
                    CFG1W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG1W::CONSTANT_0_THIS_BIT => 6,
                    CFG1W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG1W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG1W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG1W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG1W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG1W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG1W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG1W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG1W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG2`"]
        pub enum CFG2W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG2W::CONSTANT_1_THIS_BIT => 0,
                    CFG2W::RISING_EDGE_MATCH_O => 1,
                    CFG2W::FALLING_EDGE_MATCH_ => 2,
                    CFG2W::RISING_OR_FALLING_ED => 3,
                    CFG2W::HIGH_LEVEL_MATCH_F => 4,
                    CFG2W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG2W::CONSTANT_0_THIS_BIT => 6,
                    CFG2W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG2W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG2W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG2W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG2W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG2W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG2W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG2W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG2W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG3`"]
        pub enum CFG3W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG3W::CONSTANT_1_THIS_BIT => 0,
                    CFG3W::RISING_EDGE_MATCH_O => 1,
                    CFG3W::FALLING_EDGE_MATCH_ => 2,
                    CFG3W::RISING_OR_FALLING_ED => 3,
                    CFG3W::HIGH_LEVEL_MATCH_F => 4,
                    CFG3W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG3W::CONSTANT_0_THIS_BIT => 6,
                    CFG3W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG3W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG3W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG3W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG3W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG3W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG3W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG3W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG3W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG4`"]
        pub enum CFG4W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG4W::CONSTANT_1_THIS_BIT => 0,
                    CFG4W::RISING_EDGE_MATCH_O => 1,
                    CFG4W::FALLING_EDGE_MATCH_ => 2,
                    CFG4W::RISING_OR_FALLING_ED => 3,
                    CFG4W::HIGH_LEVEL_MATCH_F => 4,
                    CFG4W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG4W::CONSTANT_0_THIS_BIT => 6,
                    CFG4W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG4W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG4W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG4W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG4W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG4W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG4W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG4W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG4W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG4W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG5`"]
        pub enum CFG5W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG5W::CONSTANT_1_THIS_BIT => 0,
                    CFG5W::RISING_EDGE_MATCH_O => 1,
                    CFG5W::FALLING_EDGE_MATCH_ => 2,
                    CFG5W::RISING_OR_FALLING_ED => 3,
                    CFG5W::HIGH_LEVEL_MATCH_F => 4,
                    CFG5W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG5W::CONSTANT_0_THIS_BIT => 6,
                    CFG5W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG5W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG5W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG5W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG5W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG5W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG5W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG5W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG5W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG5W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG6`"]
        pub enum CFG6W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG6W::CONSTANT_1_THIS_BIT => 0,
                    CFG6W::RISING_EDGE_MATCH_O => 1,
                    CFG6W::FALLING_EDGE_MATCH_ => 2,
                    CFG6W::RISING_OR_FALLING_ED => 3,
                    CFG6W::HIGH_LEVEL_MATCH_F => 4,
                    CFG6W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG6W::CONSTANT_0_THIS_BIT => 6,
                    CFG6W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG6W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG6W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG6W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG6W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG6W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG6W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG6W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG6W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG6W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CFG7`"]
        pub enum CFG7W {
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            CONSTANT_1_THIS_BIT,
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_EDGE_MATCH_O,
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            FALLING_EDGE_MATCH_,
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            RISING_OR_FALLING_ED,
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            HIGH_LEVEL_MATCH_F,
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            LOW_LEVEL_MATCH_OCC,
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            CONSTANT_0_THIS_BIT,
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            EVENT_MATCH_OCCURS_,
        }
        impl CFG7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline(always)]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CFG7W::CONSTANT_1_THIS_BIT => 0,
                    CFG7W::RISING_EDGE_MATCH_O => 1,
                    CFG7W::FALLING_EDGE_MATCH_ => 2,
                    CFG7W::RISING_OR_FALLING_ED => 3,
                    CFG7W::HIGH_LEVEL_MATCH_F => 4,
                    CFG7W::LOW_LEVEL_MATCH_OCC => 5,
                    CFG7W::CONSTANT_0_THIS_BIT => 6,
                    CFG7W::EVENT_MATCH_OCCURS_ => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CFG7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CFG7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline(always)]
            pub fn variant(self, variant: CFG7W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Constant 1. This bit slice always contributes to a product term match."]
            #[inline(always)]
            pub fn constant_1_this_bit(self) -> &'a mut W {
                self.variant(CFG7W::CONSTANT_1_THIS_BIT)
            }
            #[doc = "Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_edge_match_o(self) -> &'a mut W {
                self.variant(CFG7W::RISING_EDGE_MATCH_O)
            }
            #[doc = "Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn falling_edge_match_(self) -> &'a mut W {
                self.variant(CFG7W::FALLING_EDGE_MATCH_)
            }
            #[doc = "Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared."]
            #[inline(always)]
            pub fn rising_or_falling_ed(self) -> &'a mut W {
                self.variant(CFG7W::RISING_OR_FALLING_ED)
            }
            #[doc = "High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register."]
            #[inline(always)]
            pub fn high_level_match_f(self) -> &'a mut W {
                self.variant(CFG7W::HIGH_LEVEL_MATCH_F)
            }
            #[doc = "Low level. Match occurs when there is a low level on the specified input."]
            #[inline(always)]
            pub fn low_level_match_occ(self) -> &'a mut W {
                self.variant(CFG7W::LOW_LEVEL_MATCH_OCC)
            }
            #[doc = "Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)"]
            #[inline(always)]
            pub fn constant_0_this_bit(self) -> &'a mut W {
                self.variant(CFG7W::CONSTANT_0_THIS_BIT)
            }
            #[doc = "Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)"]
            #[inline(always)]
            pub fn event_match_occurs_(self) -> &'a mut W {
                self.variant(CFG7W::EVENT_MATCH_OCCURS_)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 7;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline(always)]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression. This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice)."]
            #[inline(always)]
            pub fn prod_endpts(&self) -> PROD_ENDPTSR {
                let bits = {
                    const MASK: u8 = 127;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PROD_ENDPTSR { bits }
            }
            #[doc = "Bits 8:10 - Specifies the match-contribution condition for bit slice 0."]
            #[inline(always)]
            pub fn cfg0(&self) -> CFG0R {
                CFG0R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 11:13 - Specifies the match-contribution condition for bit slice 1."]
            #[inline(always)]
            pub fn cfg1(&self) -> CFG1R {
                CFG1R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 14:16 - Specifies the match-contribution condition for bit slice 2."]
            #[inline(always)]
            pub fn cfg2(&self) -> CFG2R {
                CFG2R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 17:19 - Specifies the match-contribution condition for bit slice 3."]
            #[inline(always)]
            pub fn cfg3(&self) -> CFG3R {
                CFG3R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 20:22 - Specifies the match-contribution condition for bit slice 4."]
            #[inline(always)]
            pub fn cfg4(&self) -> CFG4R {
                CFG4R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 23:25 - Specifies the match-contribution condition for bit slice 5."]
            #[inline(always)]
            pub fn cfg5(&self) -> CFG5R {
                CFG5R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 26:28 - Specifies the match-contribution condition for bit slice 6."]
            #[inline(always)]
            pub fn cfg6(&self) -> CFG6R {
                CFG6R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 29:31 - Specifies the match-contribution condition for bit slice 7."]
            #[inline(always)]
            pub fn cfg7(&self) -> CFG7R {
                CFG7R::_from({
                    const MASK: u8 = 7;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline(always)]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline(always)]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression. This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice)."]
            #[inline(always)]
            pub fn prod_endpts(&mut self) -> _PROD_ENDPTSW {
                _PROD_ENDPTSW { w: self }
            }
            #[doc = "Bits 8:10 - Specifies the match-contribution condition for bit slice 0."]
            #[inline(always)]
            pub fn cfg0(&mut self) -> _CFG0W {
                _CFG0W { w: self }
            }
            #[doc = "Bits 11:13 - Specifies the match-contribution condition for bit slice 1."]
            #[inline(always)]
            pub fn cfg1(&mut self) -> _CFG1W {
                _CFG1W { w: self }
            }
            #[doc = "Bits 14:16 - Specifies the match-contribution condition for bit slice 2."]
            #[inline(always)]
            pub fn cfg2(&mut self) -> _CFG2W {
                _CFG2W { w: self }
            }
            #[doc = "Bits 17:19 - Specifies the match-contribution condition for bit slice 3."]
            #[inline(always)]
            pub fn cfg3(&mut self) -> _CFG3W {
                _CFG3W { w: self }
            }
            #[doc = "Bits 20:22 - Specifies the match-contribution condition for bit slice 4."]
            #[inline(always)]
            pub fn cfg4(&mut self) -> _CFG4W {
                _CFG4W { w: self }
            }
            #[doc = "Bits 23:25 - Specifies the match-contribution condition for bit slice 5."]
            #[inline(always)]
            pub fn cfg5(&mut self) -> _CFG5W {
                _CFG5W { w: self }
            }
            #[doc = "Bits 26:28 - Specifies the match-contribution condition for bit slice 6."]
            #[inline(always)]
            pub fn cfg6(&mut self) -> _CFG6W {
                _CFG6W { w: self }
            }
            #[doc = "Bits 29:31 - Specifies the match-contribution condition for bit slice 7."]
            #[inline(always)]
            pub fn cfg7(&mut self) -> _CFG7W {
                _CFG7W { w: self }
            }
        }
    }
}
#[doc = "Pin interrupt and pattern match engine"]
pub struct PIN_INT {
    register_block: pin_int::RegisterBlock,
}
impl Deref for PIN_INT {
    type Target = pin_int::RegisterBlock;
    fn deref(&self) -> &pin_int::RegisterBlock {
        &self.register_block
    }
}
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals<'a> {
    #[doc = "CPUID"]
    pub CPUID: &'a CPUID,
    #[doc = "DCB"]
    pub DCB: &'a DCB,
    #[doc = "DWT"]
    pub DWT: &'a DWT,
    #[doc = "FPB"]
    pub FPB: &'a FPB,
    #[doc = "FPU"]
    pub FPU: &'a FPU,
    #[doc = "ITM"]
    pub ITM: &'a ITM,
    #[doc = "MPU"]
    pub MPU: &'a MPU,
    #[doc = "NVIC"]
    pub NVIC: &'a NVIC,
    #[doc = "SCB"]
    pub SCB: &'a SCB,
    #[doc = "SYST"]
    pub SYST: &'a SYST,
    #[doc = "TPIU"]
    pub TPIU: &'a TPIU,
    #[doc = "WWDT"]
    pub WWDT: &'a WWDT,
    #[doc = "MRT"]
    pub MRT: &'a MRT,
    #[doc = "WKT"]
    pub WKT: &'a WKT,
    #[doc = "SWM"]
    pub SWM: &'a SWM,
    #[doc = "PMU"]
    pub PMU: &'a PMU,
    #[doc = "CMP"]
    pub CMP: &'a CMP,
    #[doc = "FLASHCTRL"]
    pub FLASHCTRL: &'a FLASHCTRL,
    #[doc = "IOCON"]
    pub IOCON: &'a IOCON,
    #[doc = "SYSCON"]
    pub SYSCON: &'a SYSCON,
    #[doc = "I2C"]
    pub I2C: &'a I2C,
    #[doc = "SPI0"]
    pub SPI0: &'a SPI0,
    #[doc = "SPI1"]
    pub SPI1: &'a SPI1,
    #[doc = "USART0"]
    pub USART0: &'a USART0,
    #[doc = "USART1"]
    pub USART1: &'a USART1,
    #[doc = "USART2"]
    pub USART2: &'a USART2,
    #[doc = "CRC"]
    pub CRC: &'a CRC,
    #[doc = "SCT"]
    pub SCT: &'a SCT,
    #[doc = "GPIO_PORT"]
    pub GPIO_PORT: &'a GPIO_PORT,
    #[doc = "PIN_INT"]
    pub PIN_INT: &'a PIN_INT,
}
impl<'a> Peripherals<'a> {
    #[doc = r" Grants access to all the peripherals"]
    pub unsafe fn all() -> Self {
        Peripherals {
            CPUID: &*CPUID.get(),
            DCB: &*DCB.get(),
            DWT: &*DWT.get(),
            FPB: &*FPB.get(),
            FPU: &*FPU.get(),
            ITM: &*ITM.get(),
            MPU: &*MPU.get(),
            NVIC: &*NVIC.get(),
            SCB: &*SCB.get(),
            SYST: &*SYST.get(),
            TPIU: &*TPIU.get(),
            WWDT: &*WWDT.get(),
            MRT: &*MRT.get(),
            WKT: &*WKT.get(),
            SWM: &*SWM.get(),
            PMU: &*PMU.get(),
            CMP: &*CMP.get(),
            FLASHCTRL: &*FLASHCTRL.get(),
            IOCON: &*IOCON.get(),
            SYSCON: &*SYSCON.get(),
            I2C: &*I2C.get(),
            SPI0: &*SPI0.get(),
            SPI1: &*SPI1.get(),
            USART0: &*USART0.get(),
            USART1: &*USART1.get(),
            USART2: &*USART2.get(),
            CRC: &*CRC.get(),
            SCT: &*SCT.get(),
            GPIO_PORT: &*GPIO_PORT.get(),
            PIN_INT: &*PIN_INT.get(),
        }
    }
}
